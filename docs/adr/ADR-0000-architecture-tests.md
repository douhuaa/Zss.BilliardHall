# ADR-0000：架构测试（Architecture Tests）作为一等公民

## 状态

已采纳（Adopted）

---

## 背景（Context）

随着系统采用 **模块化单体（Modular Monolith）+ 垂直切片（Vertical Slice）** 架构，
仅靠代码评审和文档已无法长期、稳定地约束架构边界：

- 架构规则容易被“无意破坏”（尤其在多人协作、快速迭代时）
- ADR 文档一旦脱离代码，极易沦为“历史说明书”
- 依赖方向、模块边界、启动职责等问题，往往在系统后期才暴露，修复成本极高

因此需要一种机制，使**架构决策具备可执行性、可验证性和可持续性**。

---

## 决策（Decision）

**将架构测试（Architecture Tests）确立为架构治理的强制手段，并与 ADR 形成一一对应关系。**

具体决策如下：

1. **每一条 ADR 必须映射为至少一条可执行的架构测试**
2. 架构测试失败 = 架构决策被违反（而不是“某个测试没过”）
3. 架构测试属于“系统宪法”，其失败应阻断 CI / PR 合并
4. 架构测试关注**结构性约束**，而非实现细节或代码风格

---

## 架构测试的定义（What is Architecture Test）

架构测试用于验证以下内容：

- **程序集 / 模块之间的依赖方向是否符合 ADR**
- **启动职责、运行边界是否被破坏**
- **模块隔离是否仍然成立**

架构测试**不用于**：

- 校验代码风格或命名优雅性
- 判断某段逻辑是否“像业务”或“像技术”
- 替代单元测试或集成测试

---

## 测试组织原则（Organization Principles）

### 1️⃣ 按 ADR 组织，而非按技术层组织

- 测试目录结构以 `ADR-XXXX` 为核心
- 一个 ADR = 一个测试类（或测试集合）

示例：

```
Architecture/
└── ADR/
    ├── ADR_0001_Modular_Monolith_Tests.cs
    ├── ADR_0002_Three_Layer_Bootstrap_Tests.cs
    └── ADR_0005_Dependency_Direction_Tests.cs
```

> 目的：任何一次测试失败，都可以直接定位到被破坏的架构决策。

---

### 2️⃣ 测试名称必须显式标明 ADR 编号

- 测试类名
- 断言失败信息

都必须包含 ADR 编号，例如：

> `ADR-0005 违规：Platform 不应依赖 Application`

这是为了保证：

- 架构失败是**可沟通的**
- 架构责任是**可追溯的**

---

## 测试内容边界（What Must / Must Not Be Tested）

### ✅ 必须测试（Hard Rules）

- 层级 / 模块 / Host / Platform 之间的依赖方向
- 模块之间是否存在直接引用
- 是否违反启动模型（非 Host 出现入口点）
- 是否违反集中式依赖治理（CPM）

这些规则一旦被破坏，系统架构将**结构性退化**。

---

### 🚫 明确禁止测试（Anti-Patterns）

以下内容**不得写成架构测试**：

- 基于“类名 / 关键字”的业务语义推断
- 通过前缀 / 后缀判断技术属性
- 对模块内部实现方式的强制约束
- 对未来可能演进方向的主观假设

> 原因：这些规则维护成本高、噪音大、极易误伤正确设计。

---

## 技术选型（Implementation）

- 当前阶段：
  - 使用 **NetArchTest** 实现基于程序集与依赖的结构性约束
- 未来演进方向：
  - 对更细粒度规则（如方法级、构造函数注入）逐步引入 **Roslyn Analyzer**

NetArchTest 被视为：

> **架构烟雾报警器，而非语义审查器**

---

## 后果（Consequences）

### 正面影响

- 架构不再依赖“人记得住”
- ADR 从文档升级为“可执行宪法”
- 新成员可以通过测试快速理解系统边界

### 代价

- 初期需要额外维护测试代码
- 架构决策一旦采纳，将不再“容易推翻”

这些代价是**刻意且必要的**，用于换取长期系统稳定性。

---

## 结论（Conclusion）

**本项目明确规定：没有对应架构测试的 ADR，视为未真正落地。**

架构测试不是辅助工具，而是：

> **系统在规模化演进过程中，对抗架构腐化的最后防线。**

