# ADR-005: 事件分类体系

## 状态

**接受**

## 上下文

在垂直切片架构和模块化设计中，事件是模块间通信的关键机制。但如果不明确事件的边界和分类，会导致耦合混乱、修改影响面不清晰。

### 面临的问题

1. **事件边界不清晰**：
   - 不知道哪些事件可以自由修改
   - 不知道哪些事件影响多个消费者
   - 事件修改时不确定影响范围

2. **Module Event 随便用**：
   - "反正都在一个进程里"，随意监听其他模块事件
   - A 模块偷偷监听 B 的内部演进事件
   - B 模块一改，A 爆炸

3. **Integration Event 管理混乱**：
   - 跨服务事件随意修改
   - 删除字段导致外部系统崩溃
   - 无版本管理策略

4. **现实案例**：
   ```csharp
   // ❌ 所有事件混在一起，无法区分边界
   Modules/Tables/Events/
   ├── TableReserved.cs              // 不知道是否跨模块
   ├── PaymentCompleted.cs           // 不知道是否跨服务
   └── TableStatusChanged.cs         // 不知道是否对外
   ```

## 决策

**建立三层事件分类体系，明确每层的范围、存放位置和可修改性。**

### 三层事件分类

| 事件类型 | 范围 | 是否跨模块 | 存放位置 | 可修改性 |
|---------|------|-----------|---------|---------|
| **Domain Event** | 模块内 | ❌ | `Modules/{Module}/Events/` | ✅ 可自由修改 |
| **Module Event** | 本进程跨模块 | ⚠️ | `Modules/{Module}/PublicEvents/` | ⚠️ 需考虑消费者 |
| **Integration Event** | 跨服务 | ✅ | `BuildingBlocks/Contracts/` | ❌ 严格版本管理 |

### Domain Event（模块内部事件）

**定义**: 仅在单个模块内部使用的事件，不被其他模块消费。

**特征**:
- 内部实现细节
- 可自由修改、删除
- 不需要考虑外部影响

**示例**:
```csharp
// Modules/Tables/Events/TableStatusChanged.cs
namespace Zss.BilliardHall.Modules.Tables.Events;

internal sealed record TableStatusChanged(
    Guid TableId,
    TableStatus OldStatus,
    TableStatus NewStatus
);
```

**使用场景**:
- 聚合根内部状态变化
- 触发同模块内的其他 Handler
- 审计日志记录

### Module Event（跨模块事件）

**定义**: 在同一进程内，被多个模块消费的事件。

**特征**:
- 对外契约，需要明确标识
- 修改时需要通知所有消费方
- 需要保持向后兼容

**强制要求**: **Module Event 必须显式声明为"对外事件"**

**方式 1：文件夹命名区分**
```
Modules/Sessions/
├── Events/                    # 内部事件（Domain Event）
│   └── SessionStateChanged.cs
└── PublicEvents/              # 对外事件（Module Event）
    ├── SessionStarted.cs
    └── SessionEnded.cs
```

**方式 2：注释/Attribute 标记**
```csharp
/// <summary>
/// 会话开始事件（Module Event - 对外契约）
/// </summary>
/// <remarks>
/// 消费者：
/// - Billing 模块（计费开始）
/// - Devices 模块（设备控制）
/// 修改此事件需通知所有消费方
/// </remarks>
public sealed record SessionStarted(
    Guid SessionId,
    Guid TableId,
    Guid MemberId,
    DateTimeOffset StartedAt
);
```

**示例**:
```csharp
// Modules/Sessions/PublicEvents/SessionStarted.cs
namespace Zss.BilliardHall.Modules.Sessions.PublicEvents;

public sealed record SessionStarted(
    Guid SessionId,
    Guid TableId,
    Guid MemberId,
    DateTimeOffset StartedAt
);

// Modules/Billing/Handlers/SessionStartedHandler.cs
public class SessionStartedHandler
{
    public async Task Handle(SessionStarted evt, IDocumentSession session)
    {
        // 监听 Sessions 模块的 SessionStarted 事件
        // 触发计费开始
    }
}
```

### Integration Event（跨服务事件）

**定义**: 跨服务通信使用的事件，通过消息队列（RabbitMQ/Kafka）传递。

**特征**:
- 必须实现 `IIntegrationEvent`
- 存放在 `BuildingBlocks/Contracts/`
- **严格向后兼容，只增不改**

**不可修改铁律**:
- ❌ **不改**字段含义
- ❌ **不删**字段
- ✅ **只能加**字段（可选）
- ⚠️ **老字段哪怕废弃也要留**

**示例**:
```csharp
// BuildingBlocks/Contracts/IntegrationEvents/PaymentCompletedIntegrationEvent.cs
namespace Zss.BilliardHall.BuildingBlocks.Contracts.IntegrationEvents;

public sealed record PaymentCompletedIntegrationEvent(
    Guid PaymentId,
    Guid OrderId,
    decimal Amount,
    DateTimeOffset CompletedAt
) : IIntegrationEvent
{
    public Guid EventId { get; init; } = Guid.NewGuid();
    public DateTimeOffset OccurredAt { get; init; } = DateTimeOffset.UtcNow;
}
```

**版本演进示例**:
```csharp
// V1 - 初始版本
public sealed record PaymentCompletedIntegrationEvent(
    Guid PaymentId,
    decimal Amount
) : IIntegrationEvent;

// V2 - 新增可选字段（向后兼容）✅
public sealed record PaymentCompletedIntegrationEvent(
    Guid PaymentId,
    decimal Amount,
    string? Currency = "CNY"  // 新增可选字段
) : IIntegrationEvent;

// ❌ 错误：删除或修改字段含义
public sealed record PaymentCompletedIntegrationEvent(
    Guid PaymentId,
    decimal TaxIncludedAmount  // 改为含税金额 - 破坏兼容性！
) : IIntegrationEvent;
```

### 事件升级路径

```
Domain Event (模块内)
    ↓ 有其他模块需要监听
Module Event (跨模块)
    ↓ 需要通知外部服务
Integration Event (跨服务)
```

## 后果

### 正面影响

1. **边界清晰**：
   - 一眼看出事件的范围和影响
   - 修改时知道影响范围

2. **降低耦合**：
   - Module Event 显式声明，防止随意监听
   - Integration Event 强制兼容，保护外部系统

3. **可维护性提升**：
   - Domain Event 可自由演化
   - Module Event 有明确的消费者文档
   - Integration Event 版本可追溯

### 负面影响

1. **文件组织复杂**：
   - 需要区分 `Events/` 和 `PublicEvents/` 文件夹
   - 或需要添加注释标记

2. **开发心理负担**：
   - 创建事件时需要判断分类
   - 需要理解三层体系

### 风险缓解

1. **提供检查清单**：
   - 创建事件时逐条检查
   - Code Review 强化分类原则

2. **工具辅助**：
   - 使用 Roslyn Analyzer 检测错误分类
   - 自动化检查 Integration Event 兼容性

3. **文档和培训**：
   - 在快速上手指南中强调分类
   - 提供大量示例代码

## 替代方案

### 方案 A: 不区分事件类型

**描述**: 所有事件都放在 `Events/` 文件夹，不做区分

**优点**: 简单，无需判断

**缺点**:
- 边界不清晰，容易误用
- 修改时不知道影响范围
- 跨服务事件随意修改，导致兼容性问题

**为什么未采纳**: 简单但危险，长期维护成本高。

### 方案 B: 所有跨模块事件都是 Integration Event

**描述**: 不区分 Module Event 和 Integration Event

**优点**: 只有两层，判断简单

**缺点**:
- 进程内跨模块也要严格兼容，过于保守
- BuildingBlocks/Contracts 会膨胀
- 无法灵活演化模块间通信

**为什么未采纳**: 过度保守，限制灵活性。

### 方案 C: 使用 Namespace 区分

**描述**: 通过命名空间而非文件夹区分

**优点**: 文件组织更扁平

**缺点**:
- Namespace 不如文件夹直观
- 容易遗漏或写错 Namespace
- Code Review 难以发现问题

**为什么未采纳**: 文件夹更直观，降低出错概率。

## 检查清单

创建事件时，必须回答以下问题：

- [ ] 该事件是否会被其他模块消费？
  - 否 → Domain Event (存放在 `Events/`)
  - 是 → 继续下一步
- [ ] 该事件是否会通知外部服务？
  - 否 → Module Event (存放在 `PublicEvents/`)
  - 是 → Integration Event (存放在 `BuildingBlocks/Contracts/`)
- [ ] Module Event 是否明确标记消费者？
- [ ] Integration Event 是否实现 `IIntegrationEvent`？
- [ ] Integration Event 修改是否保持向后兼容？

## 相关决策

- [ADR-001: 采用垂直切片架构](./ADR-001-采用垂直切片架构.md)
- [ADR-013: Integration Event 向后兼容性要求](./ADR-013-IntegrationEvent兼容性.md)

## 参考资料

- [Event-Driven Architecture - Martin Fowler](https://martinfowler.com/articles/201701-event-driven.html)
- [Versioning in an Event Sourced System](https://leanpub.com/esversioning)
- 《Wolverine 模块化架构蓝图》- 2.4 事件分类与边界管理

---

**日期**: 2026-01-19  
**决策者**: 架构团队  
**最后更新**: 2026-01-19
