# ADR-001: 采用垂直切片架构而非传统分层架构

## 状态

**接受**

## 上下文

在设计 Zss.BilliardHall 自助台球系统时，我们面临架构模式的选择：

### 面临的挑战

1. **传统分层架构的问题**：
   - ABP 框架的 Domain/Application/HttpApi/Infrastructure 分层导致频繁跨层跳转
   - 一个功能修改需要同时修改多个层次的文件（Controller → AppService → Repository）
   - 新人理解成本高，需要先理解完整的分层结构才能开始开发
   - 代码组织按技术层次而非业务能力，不利于业务理解

2. **Wolverine 框架特性**：
   - Wolverine 的约定优于配置理念与传统分层冲突
   - Wolverine 的自动发现、方法参数注入等特性在垂直切片中效果更好
   - 已有 Handler、自动事务、Outbox 模式等机制，传统分层的 Service 层价值降低

3. **团队规模与项目特点**：
   - 中小型项目（自助台球系统），不需要过度工程化
   - 业务能力边界清晰（Members/Tables/Sessions/Billing/Payments）
   - 团队希望快速迭代，减少架构负担

## 决策

**采用 100% 垂直切片架构（Vertical Slice Architecture），拒绝传统分层。**

### 核心原则

1. **按业务功能组织代码**：
   - 每个 Use Case 独立一个文件夹
   - 文件夹包含 Command + Handler + Endpoint + Validator + Event
   - 示例：`Modules/Members/RegisterMember/`

2. **Handler 即 Application Service**：
   - 不再需要独立的 Service 层
   - Handler 是一等公民，拥有完整的业务处理职责
   - 利用 Wolverine 的方法参数注入，无需构造函数注入

3. **模块划分按业务能力**：
   - `Modules/Members/` - 会员管理
   - `Modules/Tables/` - 台球桌管理
   - `Modules/Sessions/` - 打球时段
   - `Modules/Billing/` - 计费
   - `Modules/Payments/` - 支付

4. **高内聚、低耦合**：
   - 每个切片独立演化
   - 模块间通过消息/事件通信，不直接依赖

### 典型切片结构

```
Modules/Tables/ReserveTable/
├── ReserveTable.cs              # Command 定义
├── ReserveTableHandler.cs       # 业务处理器
├── ReserveTableEndpoint.cs      # HTTP 端点
├── ReserveTableValidator.cs     # 输入验证（可选）
└── TableReserved.cs             # 领域事件
```

## 后果

### 正面影响

1. **开发效率提升**：
   - 功能变更限制在单个切片内，降低影响范围
   - 新人只需打开一个文件夹即可理解完整流程
   - 减少跨层跳转，代码更连贯

2. **契合 Wolverine 特性**：
   - 自动发现 Handler 无需手动配置
   - 方法参数注入简化依赖管理
   - `[Transactional]` 自动事务管理
   - Outbox 模式保证消息一致性

3. **测试友好**：
   - 每个切片可独立集成测试
   - 不需要 Mock 多层依赖
   - 测试边界清晰

4. **易于维护**：
   - 代码聚合度高，相关代码都在一起
   - 业务逻辑集中在 Handler，不分散在多个 Service
   - 功能删除只需删除一个文件夹

### 负面影响

1. **代码可能重复**：
   - 不同切片可能有相似逻辑（如价格计算）
   - 需要克制"复用洁癖"，接受适度重复

2. **学习曲线**：
   - 团队需要转变思维，从"分层思维"到"功能切片思维"
   - 需要培训团队理解垂直切片架构理念

3. **领域模型组织**：
   - 聚合根（如 `Table.cs`, `Member.cs`）需要单独放置
   - 需要明确哪些是切片专属，哪些是模块共享

### 风险缓解

1. **控制重复代码**：
   - 真正需要共享的逻辑提取到 `BuildingBlocks`
   - 遵循 5 条准入标准（详见 ADR-004）
   - 重复 3 次以上才考虑抽象

2. **团队培训**：
   - 提供《Wolverine 快速上手指南》
   - 代码示例和标准切片模板
   - Code Review 强化垂直切片原则

3. **领域模型组织**：
   - 聚合根放在模块根目录（如 `Modules/Tables/Table.cs`）
   - 复杂领域逻辑可创建 `Domain/` 子文件夹
   - 使用领域服务封装跨聚合的复杂逻辑

## 替代方案

### 方案 A: 保留 ABP 分层架构

**描述**: 继续使用 Domain/Application/HttpApi/Infrastructure 分层

**优点**:
- 团队熟悉，无学习成本
- 社区成熟，资料丰富
- 清晰的职责边界

**缺点**:
- 与 Wolverine 特性冲突，无法发挥框架优势
- 开发效率低，跨层跳转频繁
- 过度工程化，不适合中小型项目

**为什么未采纳**: Wolverine 的价值在垂直切片架构中最大化，保留分层会削弱框架优势。

### 方案 B: 混合架构（部分分层 + 部分切片）

**描述**: 核心模块用分层，简单模块用切片

**优点**:
- 渐进式迁移，风险较小
- 保留部分传统做法

**缺点**:
- 架构不一致，增加认知负担
- 团队容易混淆，不知何时用哪种方式
- 难以建立统一的代码规范

**为什么未采纳**: 一致性比灵活性更重要，混合架构会导致混乱。

### 方案 C: 纯 DDD + Clean Architecture

**描述**: 完整的领域驱动设计 + 洋葱架构

**优点**:
- 强大的领域建模能力
- 业务逻辑高度内聚

**缺点**:
- 过度设计，台球系统领域复杂度不高
- 学习曲线陡峭
- 大量样板代码（Interfaces/DTOs/Mappers）

**为什么未采纳**: 杀鸡用牛刀，不适合本项目的业务复杂度。

## 相关决策

- [ADR-002: Handler 即 Application Service](./ADR-002-Handler即ApplicationService.md)
- [ADR-003: 模块间消息通信](./ADR-003-模块间消息通信.md)
- [ADR-014: Solution 结构设计](./ADR-014-Solution结构设计.md)
- [ADR-016: 单个模块的黄金结构](./ADR-016-模块黄金结构.md)

## 参考资料

- [Vertical Slice Architecture - Jimmy Bogard](https://www.jimmybogard.com/vertical-slice-architecture/)
- [Feature Folders - Derek Comartin](https://codeopinion.com/feature-folders/)
- [Wolverine Documentation](https://wolverine.netlify.app/)
- 《Wolverine 模块化架构蓝图》- 序章：垂直切片架构理念

---

**日期**: 2026-01-19  
**决策者**: 架构团队  
**最后更新**: 2026-01-19
