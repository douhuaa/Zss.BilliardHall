# ADR-905 Copilot 提示词：执行级别分类

**适用场景**：编写架构测试、评审 ADR 可执行性、Roslyn Analyzer 开发、架构违规排查

**权威依据**：[ADR-905 执行级别分类](../adr/governance/ADR-905-enforcement-level-classification.md)

---

## ⚖️ 核心提醒

**ADR-905 的地位**：

- 📌 ADR-005 的补充文档，定义"如何验证"
- 📌 执行级别分类的唯一裁决源
- 📌 架构测试覆盖范围的判断依据
- 📌 Roslyn Analyzer 开发的指导文档

**一句话定位**：

> **ADR-005 定义"是什么"，ADR-905 定义"如何验证"。**

---

## 场景 1：为新的 ADR 规则设计验证方式

### 用户意图

"我想为 ADR-XXXX 添加一个新规则，应该怎么验证？"

### Copilot 必须做的

1. **判断规则性质**：
   ```
   请回答以下问题：
   1. 这个规则是否可以通过静态分析完全验证？
   2. 是否需要理解代码语义（如方法调用链、业务逻辑）？
   3. 是否涉及业务判断或设计权衡？
   ```

2. **根据回答推荐执行级别**：

| 如果是...           | 执行级别 | 工具                     | CI 阻断 | 示例规则                      |
|------------------|------|------------------------|-------|---------------------------|
| 纯静态约束            | L1   | NetArchTest            | ✅     | Handler 命名约定、依赖关系        |
| 需要语义分析           | L2   | Roslyn Analyzer        | ⚠️    | Endpoint 业务逻辑检查、异常使用规范   |
| 涉及业务判断/架构权衡      | L3   | PR Review + 人工审批       | ❌     | 跨模块同步调用破例、事务边界设计        |

3. **提供实施建议**：

**Level 1（静态可执行）**：
```csharp
// 创建 NetArchTest 测试
[Fact]
public void Rule_Should_Be_Enforced()
{
    var result = Types
        .InAssembly(typeof(SomeType).Assembly)
        .That()
        .ResideInNamespace("Namespace")
        .Should()
        .MeetCustomRule(new CustomRule())
        .GetResult();
    
    result.IsSuccessful.Should().BeTrue();
}
```

**Level 2（语义半自动）**：
```csharp
// 创建 Roslyn Analyzer
[DiagnosticAnalyzer(LanguageNames.CSharp)]
public class CustomAnalyzer : DiagnosticAnalyzer
{
    // 实现语义分析逻辑
}
```

**Level 3（人工 Gate）**：
```markdown
## PR 检查清单
- [ ] 是否存在跨模块同步调用？
- [ ] 如果存在，是否有充分理由？
- [ ] 是否已记录在 arch-violations.md？
```

### 示例对话

**开发者**："我想添加一个规则：Handler 不应该调用另一个模块的 Handler，应该怎么验证？"

**Copilot**：
```
根据 ADR-905 执行级别分类：

规则分析：
- 跨模块调用需要语义分析（方法调用链）
- 单纯检查 using 语句不足以判断
- 需要识别 IHandler<T> 类型的调用

推荐执行级别：Level 2（语义半自动）

实施方案：
1. **NetArchTest 启发式检查**（当前）：
   - 检查是否存在跨模块的 using 引用
   - 提供基础防护
   
2. **Roslyn Analyzer**（建议实现）：
   - 检测方法体中的 IHandler<T>.Handle() 调用
   - 检测跨模块 Handler 实例化
   - 生成警告：ADR0005_05

3. **人工审查**（必须）：
   - PR 检查清单：是否存在跨模块 Handler 调用
   - 如果存在，是否通过领域事件重构

参考：ADR-905 第 2 节 Level 2 规则列表
```

---

## 场景 2：架构测试失败，如何判断是否可以破例

### 用户意图

"架构测试失败了，但这个场景确实需要这样做，可以破例吗？"

### Copilot 必须做的

1. **确认失败的测试所属执行级别**：
   ```
   查阅 ADR-905 执行级别定义：
   - Level 1 规则：绝对禁止破例，必须修复代码
   - Level 2 规则：可以申请破例，需要充分理由
   - Level 3 规则：预期破例，重点在于记录
   ```

2. **根据级别给出建议**：

**如果是 Level 1 失败**：
```
❌ 不允许破例

Level 1 规则是静态可验证的红线约束，必须修复代码：
- 原因：规则简单明确，没有灰色地带
- 行动：重构代码以符合约束
- 参考：查阅对应 ADR 的合规实现模式

如果确实无法修复，这表明 ADR 规则本身需要修订，
请提 issue 讨论规则合理性。
```

**如果是 Level 2 失败**：
```
⚠️ 可以申请破例

Level 2 规则是语义建议，可以协商破例：
1. 在 PR 中明确标注：[ARCH-EXCEPTION: ADR-XXXX]
2. 提供详细理由：
   - 为什么必须这样做？
   - 尝试了哪些合规方案？
   - 这个破例的影响范围？
3. 记录在 arch-violations.md
4. 获得架构委员会批准

参考：ADR-905 第 2 节 Level 2 规则列表
```

**如果是 Level 3 场景**：
```
✅ 预期破例

Level 3 场景需要人工判断，架构测试可能不会失败：
1. 填写 PR 检查清单
2. 说明架构权衡和决策依据
3. 记录在 arch-violations.md
4. 获得 Tech Lead 确认

参考：ADR-905 第 3 节 Level 3 规则列表
```

### 示例对话

**开发者**："测试 `Handlers_Should_Not_Depend_On_AspNet` 失败了，但我需要在 Handler 中访问 HttpContext，可以吗？"

**Copilot**：
```
根据 ADR-905 执行级别分类：

失败规则：ADR-005.3 - Handler 不应依赖 ASP.NET 类型
执行级别：Level 1（静态可执行）

裁决：❌ 不允许破例

原因：
- Level 1 规则是架构红线，必须严格执行
- Handler 依赖 HttpContext 破坏了垂直切片架构
- 这会导致 Handler 无法独立测试

替代方案：
1. 在 Endpoint 中提取 HttpContext 信息
2. 作为 Command 参数传递给 Handler
3. Handler 只依赖纯数据

示例：
```csharp
// ❌ 错误
public class MyHandler
{
    public MyHandler(IHttpContextAccessor accessor) { }
}

// ✅ 正确
public record MyCommand(string UserId, string IpAddress);

// Endpoint 中提取
var command = new MyCommand(
    UserId: httpContext.User.FindFirst("sub").Value,
    IpAddress: httpContext.Connection.RemoteIpAddress.ToString()
);
```

参考：
- ADR-005 第 2.1 节 Command Handler 约束
- ADR-905 第 1 节 Level 1 规则列表
```

---

## 场景 3：评审新的架构测试 PR

### 用户意图

"这个 PR 添加了新的架构测试，应该如何评审？"

### Copilot 必须做的

1. **检查测试覆盖的规则级别**：
   ```
   1. 测试验证的是哪个 ADR 的哪条规则？
   2. 该规则在 ADR-905 中的执行级别是什么？
   3. 测试使用的工具是否匹配执行级别？
   ```

2. **评审测试实现**：

**Level 1 测试检查清单**：
```
✅ 检查：
- [ ] 使用 NetArchTest 或等效静态分析
- [ ] 测试失败消息清晰（包含违规类型和 ADR 引用）
- [ ] 测试是精确的，不会误报
- [ ] 测试在 CI 中运行并阻断 PR

❌ 禁止：
- Level 1 规则使用 Roslyn Analyzer（工具过重）
- 测试逻辑包含 try-catch 容忍失败
- 测试依赖外部环境（数据库、网络）
```

**Level 2 测试检查清单**：
```
✅ 检查：
- [ ] 使用 Roslyn Analyzer 或语义分析
- [ ] 测试能识别违规语义（不仅是语法）
- [ ] 测试提供清晰的修复建议
- [ ] 测试警告级别设置正确（Warning，非 Error）

⚠️ 注意：
- Level 2 测试可能有误报，需要人工判断
- 测试失败不直接阻断 PR，但需要评审
```

**Level 3 场景检查清单**：
```
✅ 检查：
- [ ] PR 模板包含相关检查项
- [ ] ARCH-VIOLATIONS.md 模板更新
- [ ] 审查指南文档更新

❌ 不应：
- 为 Level 3 场景创建自动化测试（成本 > 收益）
```

### 示例对话

**开发者**："这个 PR 添加了 Roslyn Analyzer 检查 Endpoint 业务逻辑，应该如何评审？"

**Copilot**：
```
根据 ADR-905 执行级别分类：

验证规则：ADR-005.2 - Endpoint 不应包含业务逻辑
执行级别：Level 2（语义半自动）

评审建议：

✅ 工具选择正确：
- Roslyn Analyzer 适合 Level 2 语义检查
- 比 NetArchTest 更准确

检查清单：
1. Analyzer 是否能正确识别业务逻辑？
   - 检测 if/switch 业务判断
   - 检测数据库直接操作
   - 检测复杂计算逻辑
   
2. 误报处理：
   - 是否允许 [SuppressMessage] 属性？
   - 误报时的反馈机制？
   
3. 测试覆盖：
   - 是否有单元测试验证 Analyzer 行为？
   - 正确/错误案例是否完整？

4. 文档：
   - 是否更新 ADR-905 第 2 节 Level 2 规则列表？
   - 是否创建对应的 Copilot Prompt？

5. CI 集成：
   - 警告级别设置正确（Warning，非 Error）
   - PR 检查显示警告但不阻断

参考：
- ADR-905 第 2 节 Level 2 规则列表
- ADR-005 第 3 节 Endpoint 约束
```

---

## 场景 4：解读架构测试失败消息

### 用户意图

"架构测试失败了，错误消息是什么意思？应该如何修复？"

### Copilot 必须做的

1. **分析失败消息中的规则编号**：
   ```
   失败消息格式通常为：
   "违规：ADR-XXXX.Y - 规则描述"
   
   提取信息：
   - ADR 编号：XXXX
   - 规则编号：Y
   - 执行级别：查阅 ADR-905
   ```

2. **提供执行级别上下文**：
   ```
   根据 ADR-905：
   - 该规则的执行级别是？
   - 可以破例吗？
   - 如何修复？
   ```

3. **提供具体修复建议**：
   - 引用对应 ADR 的正确实现模式
   - 链接到相关 Copilot Prompt
   - 提供代码示例

### 示例对话

**开发者**：
```
测试失败：
违规：ADR-005.7 - Modules_Should_Not_Share_Domain_Entities
类型 Orders.Domain.Order 被 Members 模块引用
```

**Copilot**：
```
根据 ADR-905 执行级别分类：

失败规则：ADR-005.7 - 模块不应共享领域实体
执行级别：Level 1（静态可执行）
CI 阻断：✅ 是

解读：
- Members 模块直接引用了 Orders 模块的 Order 实体
- 这破坏了模块边界，导致强耦合
- Level 1 规则不允许破例，必须修复

修复方案：

1. **使用数据契约（推荐）**：
```csharp
// Orders 模块定义契约
namespace Orders.Contracts;
public record OrderDto(Guid Id, string Status, decimal Total);

// Members 模块使用契约
namespace Members.UseCases;
public class GetMemberOrders
{
    private readonly IOrderQueryService _orderService;
    
    public async Task<List<OrderDto>> Handle(Guid memberId)
    {
        return await _orderService.GetOrdersByMember(memberId);
    }
}
```

2. **使用领域事件**：
```csharp
// Orders 模块发布事件
public class Order
{
    public void Complete()
    {
        // ...
        AddDomainEvent(new OrderCompleted(Id, Total));
    }
}

// Members 模块订阅事件
public class OrderCompletedHandler : IDomainEventHandler<OrderCompleted>
{
    public Task Handle(OrderCompleted @event)
    {
        // 使用事件数据，不直接依赖 Order 实体
    }
}
```

参考：
- ADR-001 第 2.2 节 模块通信方式
- ADR-905 第 1 节 Level 1 规则列表
- docs/copilot/adr-001.prompts.md 场景 3
```

---

## 常见误区

### 误区 1："测试通过 = 完全合规"

❌ **错误理解**：
"架构测试都通过了，我的代码肯定符合架构。"

✅ **正确理解**：
根据 ADR-905：
- Level 1 测试通过 = 静态约束合规
- Level 2 规则需要 Roslyn Analyzer 或人工检查
- Level 3 场景依赖人工审查和记录

**结论**：架构测试是必要条件，不是充分条件。

---

### 误区 2："Level 2 规则可以随意忽略"

❌ **错误理解**：
"Level 2 规则只是建议，可以不管。"

✅ **正确理解**：
根据 ADR-905：
- Level 2 规则是"可协商破例"，不是"可以忽略"
- 破例需要充分理由和架构审批
- 破例必须记录在 arch-violations.md

**结论**：Level 2 规则仍然是约束，只是执行方式更灵活。

---

### 误区 3："Level 1 规则太严格，应该都改成 Level 2"

❌ **错误理解**：
"所有规则都用 Roslyn Analyzer，更灵活。"

✅ **正确理解**：
根据 ADR-905：
- Level 1 规则是架构红线，必须严格执行
- 简单明确的约束用 Level 1，避免灰色地带
- Level 2 规则是语义复杂、需要权衡的场景

**结论**：执行级别是根据规则性质确定的，不是为了"灵活"。

---

## 快速参考

### 执行级别判断树

```
新规则 → 是否可以通过静态分析完全验证？
        ├─ 是 → Level 1（NetArchTest）
        └─ 否 → 是否需要理解代码语义？
                ├─ 是 → Level 2（Roslyn Analyzer）
                └─ 否 → Level 3（人工 Gate）
```

### 执行级别 vs 破例政策

| 执行级别 | 破例政策  | 记录要求      | CI 阻断 |
|------|-------|-----------|-------|
| L1   | ❌ 不允许 | 无（必须修复）   | ✅ 是   |
| L2   | ⚠️ 可协商 | 必须记录理由    | ⚠️ 警告 |
| L3   | ✅ 预期  | 必须记录权衡过程  | ❌ 否   |

---

## 相关资源

- [ADR-905 执行级别分类](../adr/governance/ADR-905-enforcement-level-classification.md)
- [ADR-005 应用内交互模型](../adr/constitutional/ADR-005-Application-Interaction-Model-Final.md)
- [ADR-900 架构测试宪法](../adr/governance/ADR-900-architecture-tests.md)
- [arch-violations.md](../governance/arch-violations.md)
- [architecture-test-failures.md](./architecture-test-failures.md)

---

**版本**：1.0  
**最后更新**：2026-01-27  
**维护**：GitHub Copilot Team
