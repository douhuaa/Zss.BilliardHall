# ADR-0121：契约命名规范 - Copilot 提示词库

本文档为 GitHub Copilot 提供 **ADR-0121（契约命名规范）** 的执行指南。

---

## 一、当我在写什么时，你应该提醒我哪些约束？

### 场景 1：创建查询接口

**触发条件**：
- 在 `Platform.Contracts/` 下创建接口
- 接口继承 `IQuery`

**检查清单**：
- ✅ 接口命名是否遵循 `I{实体}Queries` 模式（复数）？
- ✅ 接口是否继承 `IQuery` 标记接口？
- ✅ 查询方法是否返回契约 DTO（而非领域模型）？
- ✅ 查询方法是否使用正确的动词（Get, Find, List, Search）？

**示例对话**：
```
用户："帮我创建一个会员查询接口"
Copilot：
"根据 ADR-0121，查询接口应该：

命名：IMemberQueries（使用复数 Queries）
位置：Platform.Contracts/Members/IMemberQueries.cs
继承：IQuery

示例结构：
```csharp
namespace Zss.BilliardHall.Platform.Contracts.Members;

public interface IMemberQueries : IQuery
{
    Task<MemberDto?> GetByIdAsync(Guid id);
    Task<IReadOnlyList<MemberSummaryDto>> GetActiveMembersAsync();
    Task<MemberDto?> FindByEmailAsync(string email);
}
```

是否创建此接口？"
```

### 场景 2：创建契约 DTO

**触发条件**：
- 在 `Platform.Contracts/` 下创建 DTO
- DTO 需要跨模块使用

**检查清单**：
- ✅ DTO 命名是否遵循 `{实体}{限定词}Dto` 模式？
- ✅ DTO 是否实现 `IContract` 标记接口？
- ✅ DTO 是否使用 `record` 类型？
- ✅ DTO 属性是否使用 `init` 或只读？
- ✅ DTO 是否避免包含业务逻辑？

**示例对话**：
```
用户："创建一个跨模块使用的会员 DTO"
Copilot：
"根据 ADR-0121，契约 DTO 应该：

1. 使用 record 类型（不可变）
2. 实现 IContract 接口
3. 根据用途选择限定词：
   - MemberDto - 完整信息
   - MemberSummaryDto - 摘要信息
   - MemberDetailsDto - 详细信息
   - MemberBriefDto - 简要信息

您的使用场景是？我将创建相应的契约 DTO。"
```

### 场景 3：在模块中使用契约

**触发条件**：
- 在模块的 Handler 中注入查询接口
- 特别是在 Command Handler 中

**检查清单**：
- ⚠️ 这是 Command Handler 吗？**Command Handler 不应依赖其他模块的查询接口**
- ✅ Query Handler 可以使用契约查询
- ✅ Endpoint 可以使用契约

**示例对话**：
```
用户："在 CreateOrderHandler 中注入 IMemberQueries"
Copilot：
"⚠️ 警告：根据 ADR-0121 和 ADR-0001，Command Handler 不应依赖其他模块的查询接口。

当前：CreateOrderHandler（Command Handler）
尝试注入：IMemberQueries（Members 模块的查询接口）

这违反了模块隔离原则。推荐方案：

1. **本地副本（推荐）**：
   - 在 Orders 模块维护会员状态的本地投影
   - 通过订阅 MemberActivated/Deactivated 事件保持同步
   
2. **命令验证**：
   - 发布验证命令到 Members 模块
   - 等待验证结果

详见：docs/copilot/adr-0001.prompts.md（场景 3）"
```

---

## 二、哪些写法必须阻止？

### ❌ 反模式 1：查询接口命名错误

```csharp
// ❌ 错误：使用单数 Query
public interface IMemberQuery : IQuery { }

// ❌ 错误：缺少 I 前缀
public interface MemberQueries : IQuery { }

// ❌ 错误：使用 Service 后缀
public interface IMemberService : IQuery { }
public interface IMemberQueryService : IQuery { }

// ✅ 正确：I + 实体 + Queries
public interface IMemberQueries : IQuery { }
public interface IOrderQueries : IQuery { }
```

**建议**：
"查询接口命名不符合 ADR-0121 规范。
格式：I{实体}Queries（使用复数 Queries）
示例：IMemberQueries, IOrderQueries

当前：{错误命名}
应该：{正确命名}"

### ❌ 反模式 2：查询方法返回领域模型

```csharp
// ❌ 错误：返回领域模型
public interface IMemberQueries : IQuery
{
    Task<Member> GetByIdAsync(Guid id);     // 不应返回 Member 实体
    Task<List<Order>> GetOrdersAsync();      // 不应返回 Order 实体
}

// ✅ 正确：返回契约 DTO
public interface IMemberQueries : IQuery
{
    Task<MemberDto?> GetByIdAsync(Guid id);
    Task<IReadOnlyList<OrderSummaryDto>> GetOrdersAsync();
}
```

**建议**：
"查询接口不应返回领域模型。根据 ADR-0121：
- 查询接口必须返回契约 DTO
- 领域模型属于模块内部，不应暴露

当前返回：{领域模型类型}
应该返回：{Dto类型}（契约 DTO）

这样能保持模块隔离，避免暴露内部实现。"

### ❌ 反模式 3：可变的契约 DTO

```csharp
// ❌ 错误：使用 class 和 set 属性
public class MemberDto : IContract
{
    public Guid Id { get; set; }            // 应该用 init
    public string Name { get; set; }
}

// ❌ 错误：包含业务方法
public record MemberDto : IContract
{
    public Guid Id { get; init; }
    public bool IsActive { get; init; }
    
    public bool CanPlaceOrder()             // 不应包含业务逻辑
    {
        return IsActive && CreditScore > 60;
    }
}

// ✅ 正确：不可变的数据结构
public record MemberDto : IContract
{
    public required Guid Id { get; init; }
    public required string Name { get; init; }
    public bool IsActive { get; init; }
}
```

**建议**：
"契约 DTO 必须是不可变的数据结构。根据 ADR-0121：
- 使用 record 类型，不是 class
- 属性使用 init，不是 set
- 不包含业务方法或逻辑
- 只传递数据，不包含行为

请修改为不可变的 record。"

### ❌ 反模式 4：Command Handler 依赖查询接口

```csharp
// ❌ 错误：Command Handler 依赖其他模块查询
public class CreateOrderCommandHandler
{
    private readonly IMemberQueries _memberQueries;  // 违规！
    
    public CreateOrderCommandHandler(IMemberQueries memberQueries)
    {
        _memberQueries = memberQueries;
    }
    
    public async Task Handle(CreateOrderCommand command)
    {
        // 使用契约做业务决策
        var member = await _memberQueries.GetByIdAsync(command.MemberId);
        if (member?.IsActive != true)  // 违规！基于契约做业务判断
        {
            throw new Exception("会员未激活");
        }
    }
}

// ✅ 正确：维护本地副本或使用命令验证
public class CreateOrderCommandHandler
{
    private readonly IDocumentSession _session;
    
    public async Task Handle(CreateOrderCommand command)
    {
        // 方案1：从本地投影查询
        var memberStatus = await _session
            .Query<MemberStatusProjection>()  // Orders 模块的本地副本
            .FirstOrDefaultAsync(m => m.MemberId == command.MemberId);
        
        if (memberStatus?.IsActive != true)
        {
            throw new BusinessException("会员未激活");
        }
        
        // 或方案2：发布验证命令
        // await _bus.InvokeAsync(new ValidateMemberCommand(command.MemberId));
    }
}
```

**建议**：
"⚠️ 严重违规：Command Handler 不应依赖其他模块的查询接口。

这违反了：
- ADR-0001：模块隔离原则
- ADR-0121：契约使用规则

推荐方案：
1. **本地副本**：在模块内维护必要数据的副本，通过事件同步
2. **命令验证**：发布验证命令，由源模块处理

详见：docs/copilot/adr-0001.prompts.md（场景 3）"

### ❌ 反模式 5：契约定义在错误位置

```csharp
// ❌ 错误：在模块项目中定义跨模块契约
// src/Modules/Members/Contracts/IMemberQueries.cs
namespace Zss.BilliardHall.Modules.Members.Contracts;
public interface IMemberQueries { }  // 应该在 Platform.Contracts

// ✅ 正确：在 Platform.Contracts 中定义
// src/Platform/Contracts/Members/IMemberQueries.cs
namespace Zss.BilliardHall.Platform.Contracts.Members;
public interface IMemberQueries : IQuery { }
```

**建议**：
"跨模块契约必须定义在 Platform.Contracts 项目中。

当前位置：{模块}/Contracts/
正确位置：Platform/Contracts/{模块名}/

修复方法：
1. 在 Platform.Contracts 创建 {模块名}/ 目录
2. 移动契约文件到该目录
3. 更新命名空间为 Zss.BilliardHall.Platform.Contracts.{模块名}
4. 更新所有引用"

---

## 三、CI 失败时，你应该如何解释？

### 失败场景 1：查询接口命名不规范

**CI 错误信息**：
```
ADR-0121.1: 查询接口应遵循命名约定
Failed: 'IMemberQuery' does not follow naming convention
Expected pattern: I{Entity}Queries (plural)
Correct name: IMemberQueries
```

**人话翻译**：
"查询接口命名不规范。

当前：IMemberQuery
应该：IMemberQueries（使用复数）

根据 ADR-0121，查询接口应该：
- 使用 I 前缀
- 实体名使用单数
- 使用复数 Queries 后缀

修复方法：
1. 重命名接口为 IMemberQueries
2. 重命名文件为 IMemberQueries.cs
3. 更新所有引用"

### 失败场景 2：契约 DTO 不是 record

**CI 错误信息**：
```
ADR-0121.2: 契约 DTO 必须使用 record 类型
Failed: 'MemberDto' is a class, should be a record
Contracts must be immutable data structures
```

**人话翻译**：
"契约 DTO 必须是不可变的数据结构。

当前：public class MemberDto
应该：public record MemberDto

根据 ADR-0121，契约 DTO 必须：
- 使用 record 类型（不可变）
- 属性使用 init（不是 set）
- 实现 IContract 接口

修复方法：
1. 将 class 改为 record
2. 将所有 set 改为 init
3. 添加 : IContract 继承
4. 必填属性添加 required 修饰符"

### 失败场景 3：Command Handler 依赖查询接口

**CI 错误信息**：
```
ADR-0121.3: Command Handler 不应依赖查询接口
Failed: 'CreateOrderCommandHandler' depends on 'IMemberQueries'
Command Handlers must not depend on IQuery interfaces from other modules
Violation: Module isolation principle (ADR-0001)
```

**人话翻译**：
"Command Handler 不应依赖其他模块的查询接口。

违规代码：
```csharp
public class CreateOrderCommandHandler
{
    private readonly IMemberQueries _memberQueries;  // ❌ 违规
}
```

这违反了模块隔离原则（ADR-0001）。

推荐方案：
1. **本地副本（推荐）**：
   ```csharp
   // 在 Orders 模块维护 MemberStatusProjection
   // 通过订阅 MemberActivated/Deactivated 事件同步
   var memberStatus = await _session.Query<MemberStatusProjection>()
       .FirstOrDefaultAsync(m => m.MemberId == command.MemberId);
   ```

2. **命令验证**：
   ```csharp
   // 发布验证命令
   var result = await _bus.InvokeAsync<ValidationResult>(
       new ValidateMemberCommand(command.MemberId));
   ```

详见：docs/copilot/adr-0001.prompts.md"

---

## 四、典型问答（FAQ）

### Q1: 什么时候契约应该放在 Platform.Contracts？

**A:** 当契约需要**跨模块**使用时：

**放在 Platform.Contracts**：
- 模块暴露给其他模块的查询接口
- 跨模块使用的 DTO
- 事件载荷中的数据契约

**放在模块内部**：
- 仅在模块内部使用的 DTO
- 模块内部的 Request/Response
- 不对外暴露的数据结构

### Q2: 查询接口为什么要用复数 Queries？

**A:** 表示接口包含**多个查询方法**：

```csharp
// ✅ 复数表示包含多个查询
public interface IMemberQueries : IQuery
{
    Task<MemberDto?> GetByIdAsync(Guid id);
    Task<MemberDto?> FindByEmailAsync(string email);
    Task<IReadOnlyList<MemberDto>> GetActiveMembersAsync();
}
```

这是约定俗成的命名模式，与 `IRepository` 类似。

### Q3: 契约 DTO 可以嵌套吗？

**A:** 可以，但要谨慎：

```csharp
// ✅ 可以嵌套契约 DTO
public record OrderSummaryDto : IContract
{
    public required Guid Id { get; init; }
    public required MemberBriefDto Member { get; init; }  // 嵌套
}

// ✅ 更好：使用 ID 引用（推荐）
public record OrderSummaryDto : IContract
{
    public required Guid Id { get; init; }
    public required Guid MemberId { get; init; }  // ID 引用
}
```

建议：
- 避免过深嵌套
- 优先使用 ID 引用
- 嵌套对象也必须是契约

### Q4: 契约版本化什么时候需要？

**A:** 当需要破坏性变更且旧版本仍需支持时：

**需要版本化**：
- 属性重命名或删除
- 属性类型变更
- 重大语义变更

**不需要版本化**：
- 添加新属性（向后兼容）
- 内部模块间契约（可直接修改）

版本化示例：
```csharp
namespace Platform.Contracts.Members.V1;
public record MemberDtoV1 : IContract { }

namespace Platform.Contracts.Members.V2;
public record MemberDtoV2 : IContract { }
```

---

## 五、快速检查清单

### PR 前自检（契约命名）

**查询接口**：
- [ ] 命名遵循 `I{实体}Queries` 模式（复数）
- [ ] 继承 `IQuery` 标记接口
- [ ] 所有方法返回契约 DTO（不是领域模型）
- [ ] 查询方法使用正确动词（Get, Find, List, Search）
- [ ] 定义在 `Platform.Contracts/{模块名}/` 目录

**契约 DTO**：
- [ ] 命名遵循 `{实体}{限定词}Dto` 模式
- [ ] 使用 `record` 类型
- [ ] 实现 `IContract` 接口
- [ ] 属性使用 `init` 或只读
- [ ] 不包含业务逻辑或方法
- [ ] 定义在 `Platform.Contracts/{模块名}/` 目录

**契约使用**：
- [ ] Command Handler 不依赖其他模块的查询接口
- [ ] Query Handler 可以返回契约 DTO
- [ ] Endpoint 可以使用契约进行请求/响应

---

## 六、查询方法命名指南

| 动词 | 含义 | 返回值 | 示例 |
|------|------|--------|------|
| **Get** | 按唯一标识获取 | `Task<{Dto}?>` | `GetByIdAsync(Guid id)` |
| **Find** | 按条件查找 | `Task<{Dto}?>` | `FindByEmailAsync(string email)` |
| **List** | 获取列表 | `Task<IReadOnlyList<{Dto}>>` | `ListActiveMembersAsync()` |
| **Search** | 搜索（分页） | `Task<PagedResult<{Dto}>>` | `SearchMembersAsync(criteria)` |

**返回值规范**：
- 单个实体：使用 `Task<{Dto}?>` （nullable）
- 列表：使用 `Task<IReadOnlyList<{Dto}>>`
- 分页：使用 `Task<PagedResult<{Dto}>>`

---

## 六、编写架构测试的经验教训

### 关键原则：契约规范完全可以自动化验证

ADR-0121 的所有规范都属于 Level 1 或 Level 2，**不是** Level 3（人工 Gate）：
- ✅ 查询接口必须以 Queries（复数）结尾 - Level 2（反射检查）
- ✅ 查询接口必须继承 IQuery - Level 1（NetArchTest/反射）
- ✅ 契约 DTO 必须实现 IContract - Level 1（NetArchTest/反射）
- ✅ 禁止使用 Service 后缀 - Level 1（NetArchTest）

### 测试中的常见陷阱

**陷阱 1**：将标记接口也当作查询接口
```csharp
// ❌ 错误：IQuery 本身不是查询接口
.Where(t => t.Name.Contains("Query"))  // 会匹配到 IQuery

// ✅ 正确：排除标记接口
.Where(t => t.Name.Contains("Query"))
.Where(t => t.Name != "IQuery" && t.Name != "IContract")
```

**陷阱 2**：API 使用错误
```csharp
// ❌ Assert.Empty 不接受第二个参数（错误消息）
Assert.Empty(violations, "错误消息");

// ✅ 使用 Assert.True + Count
Assert.True(violations.Count == 0, "错误消息");
```

详细经验总结见：[ADR-0110 Copilot Prompts - 第六章](/docs/copilot/adr-0110.prompts.md#六编写架构测试的常见错误和正确做法)

---

## 七、相关 ADR 和文档

- [ADR-0121：契约命名规范](/docs/adr/structure/ADR-0121-contract-naming-conventions.md)
- [ADR-0001：模块化单体与垂直切片架构](/docs/adr/constitutional/ADR-0001-modular-monolith-vertical-slice-architecture.md)
- [ADR-0120：功能切片命名规范](/docs/adr/structure/ADR-0120-feature-naming-conventions.md)
- [Platform Contracts README](/src/Platform/Contracts/README.md)

---

## 版本历史

| 版本 | 日期 | 变更说明 |
|------|------|---------|
| 1.1 | 2026-01-22 | 新增"编写架构测试的经验教训"章节 |
| 1.0 | 2026-01-22 | 初始版本，配合 ADR-0121 创建 |
