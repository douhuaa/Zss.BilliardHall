# ADR-907 Copilot 提示词：ArchitectureTests 执法治理体系

**适用场景**：编写架构测试、组织测试代码、架构测试失败排查、CI/Analyzer 配置

**权威依据**：[ADR-907 ArchitectureTests 执法治理体系](../adr/governance/ADR-907-architecture-tests-enforcement-governance.md)

> 📋 **v2.0 更新说明**：
> 
> ADR-907 v2.0 引入了 Rule/Clause 双层编号体系：
> - **Rule**：主要规则（ADR-907.1 ～ ADR-907.4）
> - **Clause**：具体条款（如 ADR-907.2_1, ADR-907.2_2）
> - 每个 Clause 对应一个可测试的架构约束
> - 测试方法必须一一映射到 Clause
> 
> 详见 ADR-907 v2.0 Decision 部分的"统一铁律"。

---

## ⚖️ 核心提醒

**ADR-907 的地位**：

- 📌 整合 ADR-903、ADR-904、ADR-906 的唯一执法规则
- 📌 ArchitectureTests 命名、组织、断言、CI 映射的完整规范
- 📌 架构测试从编写到执行的全生命周期治理
- 📌 支持 L1/L2 执行等级和破例机制

**一句话定位**：

> **ADR-907 让 ArchitectureTests 成为 ADR 的"可执行镜像"。**

---

## 场景 1：为新 ADR 创建架构测试

### 用户意图

"我刚写了一个新的 ADR，需要创建对应的架构测试。"

### Copilot 必须做的

1. **检查 ADR 编号和测试文件命名**：
   ```
   根据 ADR-907 §2（命名与组织规范）：
   
   ✅ 测试文件位置：
   src/tests/ArchitectureTests/ADR/ADR_<编号>_Architecture_Tests.cs
   
   ✅ 命名格式：
   - 推荐：ADR_0907_Architecture_Tests.cs（4位编号）
   - 可接受：ADR_907_Architecture_Tests.cs（3位编号）
   
   ✅ 命名空间：
   namespace Zss.BilliardHall.Tests.ArchitectureTests.ADR;
   
   ❌ 错误示例：
   - ADR907Tests.cs（缺少下划线）
   - ADR-907-Tests.cs（使用连字符）
   - ADR_907_Tests.cs（缺少 Architecture）
   ```

2. **提供测试类模板**：
   ```csharp
   using NetArchTest.Rules;
   using System.Reflection;
   using Xunit;
   
   namespace Zss.BilliardHall.Tests.ArchitectureTests.ADR;
   
   /// <summary>
   /// ADR-XXXX: [ADR 标题]
   /// [简要说明本 ADR 的核心约束]
   /// 
   /// 测试覆盖映射：
   /// - ADR-XXXX.1: [子规则描述] → [测试方法名]
   /// - ADR-XXXX.2: [子规则描述] → [测试方法名]
   /// 
   /// 关联文档：
   /// - ADR: docs/adr/[category]/ADR-XXXX-[title].md
   /// - Prompts: docs/copilot/adr-XXXX.prompts.md
   /// </summary>
   public sealed class ADR_XXXX_Architecture_Tests
   {
       [Fact(DisplayName = "ADR-XXXX.1: [子规则描述]")]
       public void Rule_Should_Be_Enforced()
       {
           // 实现测试逻辑
           
           Assert.True(result.IsSuccessful,
               $"❌ ADR-XXXX.1 违规：[违规描述]\n\n" +
               $"违规类型：{string.Join(", ", failingTypes)}\n\n" +
               $"修复建议：\n" +
               $"  1. [修复步骤 1]\n" +
               $"  2. [修复步骤 2]\n\n" +
               $"参考：docs/adr/[category]/ADR-XXXX-[title].md");
       }
   }
   ```

3. **提醒必须遵守的规则**：
   ```
   根据 ADR-907，必须确保：
   
   ✅ 单一 ADR 映射（§2.3）：
   - 一个测试类只覆盖一个 ADR
   - DisplayName 必须引用正确的 ADR 编号
   - 可以引用依赖的 ADR（如 ADR-0000、ADR-905）
   
   ✅ 方法命名（§2.5）：
   - 格式：ADR_<编号>_<子规则>_<行为描述>
   - 或在 DisplayName 中明确：ADR-XXXX.Y
   
   ✅ 失败消息（§2.6）：
   - 必须包含 ADR 编号和子规则
   - 格式：❌ ADR-XXXX.Y 违规：...
   - 包含修复建议和文档链接
   
   ✅ 有效断言（§3）：
   - 至少 1 个有效断言
   - 禁止 Assert.True(true) 等形式化断言
   - 断言必须验证结构约束
   ```

4. **测试技术选项（根据 ADR-907.1_1）**：
   ```
   ArchitectureTests 支持多种测试方式：
   
   ✅ NetArchTest.Rules（推荐）：
   - 适合验证命名空间、类型依赖、继承关系
   - 提供流畅的 API 和清晰的断言
   
   ✅ 文件系统扫描：
   - 适合验证目录结构、文件命名规范
   - 使用 Directory.GetFiles / Directory.GetDirectories
   
   ✅ Roslyn / Reflection：
   - 适合深度代码分析和自定义规则
   - 可以检查代码语义、特性（Attribute）、方法签名
   
   选择原则：
   - 优先使用 NetArchTest（如适用）
   - 对于 ADR-907.1 自身的元验证测试，建议使用文件系统扫描
   - 复杂规则可混合使用多种技术
   ```

### 示例对话

**开发者**："我创建了 ADR-950，规定 Repository 接口必须在 Domain 层，如何写测试？"

**Copilot**：
```
根据 ADR-907 架构测试规范：

1. 创建测试文件：
   src/tests/ArchitectureTests/ADR/ADR_0950_Architecture_Tests.cs

2. 使用以下模板：

```csharp
using NetArchTest.Rules;
using Xunit;

namespace Zss.BilliardHall.Tests.ArchitectureTests.ADR;

/// <summary>
/// ADR-950: Repository 接口必须在 Domain 层
/// 验证 Repository 接口的位置和命名约束
/// 
/// 测试覆盖映射：
/// - ADR-950.1: Repository 接口必须在 Domain 命名空间 → Repository_Interfaces_Must_Be_In_Domain
/// - ADR-950.2: Repository 接口必须以 IRepository 结尾 → Repository_Interfaces_Must_Follow_Naming
/// </summary>
public sealed class ADR_0950_Architecture_Tests
{
    [Theory(DisplayName = "ADR-950.1: Repository 接口必须在 Domain 命名空间")]
    [ClassData(typeof(ModuleAssemblyData))]
    public void Repository_Interfaces_Must_Be_In_Domain(Assembly moduleAssembly)
    {
        var result = Types
            .InAssembly(moduleAssembly)
            .That()
            .HaveNameEndingWith("Repository")
            .And()
            .AreInterfaces()
            .Should()
            .ResideInNamespace("Domain")
            .GetResult();

        Assert.True(result.IsSuccessful,
            $"❌ ADR-950.1 违规：Repository 接口必须位于 Domain 命名空间\n\n" +
            $"违规接口：{string.Join(", ", result.FailingTypes?.Select(t => t.FullName) ?? Array.Empty<string>())}\n\n" +
            $"修复建议：\n" +
            $"  1. 将 Repository 接口移至 Domain 层\n" +
            $"  2. 命名空间格式：Modules.<ModuleName>.Domain\n\n" +
            $"参考：docs/adr/structure/ADR-950-repository-location.md");
    }
}
```

3. 创建对应的 Prompts 文件：
   docs/copilot/adr-0950.prompts.md

参考：
- ADR-907 §2 命名与组织规范
- 现有测试示例：ADR_0123_Architecture_Tests.cs
```

---

## 场景 2：架构测试失败排查

### 用户意图

"架构测试失败了，不知道如何修复。"

### Copilot 必须做的

1. **识别失败的测试和规则**：
   ```
   从失败消息中提取：
   - ADR 编号：ADR-XXXX
   - 子规则：XXXX.Y
   - 执行级别：L1 或 L2
   ```

2. **判断是否可以破例**：
   ```
   根据 ADR-907 §4（Enforcement）：
   
   L1 规则失败：
   ❌ 不允许破例，必须修复代码
   - L1 规则是可自动验证的红线约束
   - 必须按照修复建议调整代码
   
   L2 规则失败：
   ⚠️ 可以申请破例
   - 需要充分理由和架构审批
   - 必须记录在破例机制中（ADR-0000）
   ```

3. **提供修复指导**：
   ```
   1. 查阅对应的 ADR 文档
   2. 参考测试失败消息中的修复建议
   3. 查看对应的 Copilot Prompts
   4. 参考现有的合规实现
   ```

### 示例对话

**开发者**：
```
测试失败：
❌ ADR-907.4 违规：以下测试类命名不符合规范
  • ADR_920_Architecture_Tests.cs
```

**Copilot**：
```
根据 ADR-907 §2.4 测试类命名规范：

问题诊断：
- 文件名 ADR_920_Architecture_Tests.cs 使用 3 位编号
- 推荐使用 4 位编号格式

修复方案：

方案 1（推荐）：重命名为 4 位格式
```bash
git mv src/tests/ArchitectureTests/ADR/ADR_920_Architecture_Tests.cs \
       src/tests/ArchitectureTests/ADR/ADR_0920_Architecture_Tests.cs
```

方案 2：保持 3 位格式（如果这是约定）
- ADR-907.4 测试也接受 3 位编号
- 但推荐整个项目统一使用 4 位格式

注意事项：
1. 重命名后需要更新类名和命名空间
2. 更新类内部的 DisplayName 中的 ADR 引用
3. 确保测试编译通过

参考：
- ADR-907 §2.4 测试类命名正则校验
- 示例：ADR_0001_Architecture_Tests.cs
```

---

## 场景 3：组织现有的架构测试

### 用户意图

"现有的架构测试很混乱，如何按照 ADR-907 重新组织？"

### Copilot 必须做的

1. **检查当前违规情况**：
   ```
   运行 ADR-907 架构测试：
   
   dotnet test --filter "FullyQualifiedName~ADR_0907"
   
   这会检测：
   - 命名不规范的测试文件
   - 跨 ADR 混合的测试
   - 缺少断言的测试
   - 使用 Skip 的测试
   ```

2. **提供重组方案**：
   ```
   根据 ADR-907 §2.2 目录结构要求：
   
   ✅ 正确结构：
   src/tests/ArchitectureTests/
   ├── ADR/
   │   ├── ADR_0001_Architecture_Tests.cs
   │   ├── ADR_0002_Architecture_Tests.cs
   │   └── ADR_0907_Architecture_Tests.cs
   ├── Governance/
   ├── Heuristics/
   └── TestData.cs
   
   ❌ 错误结构：
   - 测试文件不在 ADR 目录下
   - 多个 ADR 测试混在一个文件中
   - 测试文件命名不符合规范
   ```

3. **提供迁移步骤**：
   ```
   迁移清单：
   
   1. 创建 /ADR/ 目录（如果不存在）
   2. 按 ADR 拆分测试文件
   3. 重命名为规范格式
   4. 更新类名和命名空间
   5. 添加测试注释（映射到 ADR 子规则）
   6. 确保失败消息包含 ADR 引用
   7. 运行测试验证
   ```

---

## 场景 4：配置 CI/Analyzer 集成

### 用户意图

"如何确保架构测试在 CI 中正确执行？"

### Copilot 必须做的

1. **检查项目配置**：
   ```
   根据 ADR-907 §4.1 CI/Analyzer 自动注册：
   
   必需组件：
   ✅ ArchitectureTests.csproj 存在
   ✅ 引用 xUnit 测试框架
   ✅ 引用 NetArchTest.Rules
   ✅ CI 配置文件存在（.github/workflows）
   ```

2. **提供 CI 配置模板**：
   ```yaml
   # .github/workflows/architecture-tests.yml
   name: Architecture Tests
   
   on:
     pull_request:
       branches: [main, develop]
     push:
       branches: [main]
   
   jobs:
     architecture-tests:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4
         
         - name: Setup .NET
           uses: actions/setup-dotnet@v4
           with:
             dotnet-version: '10.0.x'
         
         - name: Restore dependencies
           run: dotnet restore
         
         - name: Build
           run: dotnet build --no-restore
         
         - name: Run Architecture Tests
           run: |
             dotnet test \
               src/tests/ArchitectureTests/ArchitectureTests.csproj \
               --no-build \
               --verbosity normal \
               --logger "trx;LogFileName=architecture-tests.trx"
         
         - name: Publish Test Results
           if: always()
           uses: dorny/test-reporter@v1
           with:
             name: Architecture Test Results
             path: '**/architecture-tests.trx'
             reporter: dotnet-trx
             fail-on-error: true
   ```

3. **配置执行级别策略**：
   ```
   根据 ADR-907 §4.3 L1/L2 执行级别：
   
   L1 规则（失败阻断）：
   - 在 CI 中设置 fail-on-error: true
   - 测试失败直接阻断 PR 合并
   
   L2 规则（告警）：
   - 使用 Console.WriteLine 输出警告
   - 不阻断 CI，但在 PR 中可见
   - 需要人工 Code Review 确认
   ```

---

## 场景 5：处理 Skip 和条件禁用

### 用户意图

"某个架构测试暂时无法通过，可以 Skip 吗？"

### Copilot 必须做的

1. **检查是否可以 Skip**：
   ```
   根据 ADR-907 §2.8 禁止 Skip/条件禁用：
   
   ❌ 不允许：
   [Fact(Skip = "暂时跳过")]
   public void Some_Test() { }
   
   ❌ 不允许：
   [SkipOnCI]
   public void Some_Test() { }
   ```

2. **提供正确的处理方式**：
   ```
   如果测试无法通过：
   
   方案 1：修复代码（推荐）
   - 按照测试要求调整代码
   - 这是 L1 规则的唯一解决方案
   
   方案 2：申请破例（仅限 ADR-907.4_6 - L2 规则）
   - ⚠️ 注意：从 ADR-907 v2.0 起，仅 ADR-907.4_6（ADR 生命周期同步）为 L2 级别
   - 其他所有规则均为 L1 级别，不允许破例
   - L2 规则破例流程：
     * 通过 ADR-0000 破例机制
     * 记录：ADR 编号、测试类/方法、原因、到期时间
     * 获得架构审批
     * 在代码中添加注释说明破例
   
   方案 3：修订 ADR（规则本身有问题）
   - 提出 ADR 修订 RFC
   - 经架构委员会批准后修订
   - 同步更新测试
   ```

### 示例对话

**开发者**："测试 `Modules_Should_Not_Reference_Other_Modules` 失败了，但这是遗留代码，可以先 Skip 吗？"

**Copilot**：
```
根据 ADR-907 §2.8 和 ADR-0000 破例机制：

❌ 不能直接 Skip：
- ADR-907 明确禁止使用 Skip 或条件禁用
- Skip 会让架构测试失去意义

✅ 正确处理方式：

1. 评估规则级别：
   - ADR-0001.1 是 L1 规则（模块隔离）
   - L1 规则不允许破例

2. 短期方案（技术债）：
   ```markdown
   ## 技术债记录
   
   **违规**：ADR-0001.1 - 模块不应相互引用
   **位置**：Members 模块引用 Orders.Domain.Order
   **原因**：遗留代码，需重构
   **影响**：破坏模块边界，增加耦合
   **偿还计划**：
   - Q1: 创建 OrderDto 数据契约
   - Q1: 重构 Members 模块使用契约
   - Q2: 移除直接依赖
   **负责人**：@架构师
   **到期日期**：2026-03-31
   ```

3. 长期方案（重构）：
   - 创建数据契约代替直接依赖
   - 使用领域事件解耦
   - 参考 ADR-0001 §2.2 模块通信方式

重要：
- 技术债必须有明确的偿还计划
- 定期审查技术债清单
- 不能让技术债无限累积

参考：
- ADR-0000 破例与偿还机制
- ADR-907 §2.8 Skip/条件禁用检测
- ADR-905 执行级别分类
```

---

## 常见误区

### 误区 1："一个测试文件可以测试多个 ADR"

❌ **错误理解**：
"为了减少文件数量，我把相关的 ADR 测试放在一起。"

✅ **正确理解**：
根据 ADR-907 §2.3：
- 一个测试类只能覆盖一个 ADR
- 这确保了测试和 ADR 的清晰映射
- 便于维护和追溯

---

### 误区 2："测试方法名随意，只要 DisplayName 正确就行"

❌ **错误理解**：
"方法名不重要，反正有 DisplayName。"

✅ **正确理解**：
根据 ADR-907 §2.5：
- 方法名应该映射 ADR 子规则
- 推荐格式：ADR_<编号>_<子规则>_<行为描述>
- 方法名是代码的文档，应该清晰

---

### 误区 3："Assert.True(true) 也是断言"

❌ **错误理解**：
"只要有 Assert 语句就行，内容不重要。"

✅ **正确理解**：
根据 ADR-907 §3：
- 禁止形式化断言（Assert.True(true)）
- 断言必须验证实际的结构约束
- ⚠️ 从 v2.0 起，这些都是 L1 规则，会直接阻断 CI

---

### 误区 4："Skip 一下没关系，以后再修"

❌ **错误理解**：
"先 Skip 让 CI 通过，以后有时间再修。"

✅ **正确理解**：
根据 ADR-907 §2.8：
- 禁止使用 Skip 或条件禁用
- Skip 的测试会被 ADR-907.2_8 (L1) 检测出来
- L1 规则会直接阻断 CI，无法通过破例

---

## 快速参考

### 测试文件命名规则

```
✅ 正确：
- ADR_0001_Architecture_Tests.cs（4位，推荐）
- ADR_907_Architecture_Tests.cs（3位，可接受）

❌ 错误：
- ADR-0001-Tests.cs
- ADR_0001_Tests.cs
- ADR0001ArchitectureTests.cs
```

### 测试方法命名规则

```
✅ 推荐：
- ADR_0001_1_Modules_Should_Not_Reference_Other_Modules
- Repository_Interfaces_Must_Be_In_Domain（DisplayName 包含 ADR-XXXX.Y）

❌ 不推荐：
- Test1（无意义）
- ShouldPass（不明确）
```

### 失败消息格式

```csharp
Assert.True(result.IsSuccessful,
    $"❌ ADR-XXXX.Y 违规：[违规描述]\n\n" +
    $"违规类型：{string.Join(", ", failingTypes)}\n\n" +
    $"修复建议：\n" +
    $"  1. [步骤 1]\n" +
    $"  2. [步骤 2]\n\n" +
    $"参考：docs/adr/[path]/ADR-XXXX-[title].md");
```

### 执行级别对照

| 规则编号 | 执行级别 | 失败处理 |
|---------|---------|---------|
| ADR-907.1_1~1_3 | L1 | 必须修复，不能 Skip |
| ADR-907.2_1~2_8 | L1 | 必须修复，不能 Skip |
| ADR-907.3_1~3_4 | L1 | 必须修复，不能 Skip |
| ADR-907.4_1~4_5 | L1 | 必须修复，不能 Skip |
| ADR-907.4_6 | L2 | 记录告警，可协商 |

> ⚠️ **注意**：从 ADR-907 v2.0 最新更新起，大部分规则已提升为 L1 级别（阻断级），
> 仅 ADR-907.4_6（ADR 生命周期同步校验）保持 L2 级别。

---

## 相关资源

- [ADR-907 ArchitectureTests 执法治理体系](../adr/governance/ADR-907-architecture-tests-enforcement-governance.md)
- [ADR-0000 架构测试宪法](../adr/governance/ADR-0000-architecture-tests.md)
- [ADR-905 执行级别分类](../adr/governance/ADR-905-enforcement-level-classification.md)
- [ADR-0900 ADR 新增与修订流程](../adr/governance/ADR-0900-adr-process.md)
- [architecture-test-failures.md](./architecture-test-failures.md)

---

**版本**：2.1  
**最后更新**：2026-02-02  
**维护**：GitHub Copilot Team  
**变更说明**：对齐 ADR-907 最新更新（执行级别调整 + 测试选项说明）
