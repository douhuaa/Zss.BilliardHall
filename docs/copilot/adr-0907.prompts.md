# ADR-907 Copilot 提示词：ArchitectureTests 执法治理体系

**适用场景**：编写架构测试、组织测试代码、架构测试失败排查、CI/Analyzer 配置

**权威依据**：[ADR-907 ArchitectureTests 执法治理体系](../adr/governance/ADR-907-architecture-tests-enforcement-governance.md)

---

## ⚖️ 核心提醒

**ADR-907 的地位**：

- 📌 整合 ADR-903、ADR-904、ADR-906 的唯一执法规则
- 📌 ArchitectureTests 命名、组织、断言、CI 映射的完整规范
- 📌 架构测试从编写到执行的全生命周期治理
- 📌 支持 L1/L2 执行等级和破例机制

**一句话定位**：

> **ADR-907 让 ArchitectureTests 成为 ADR 的"可执行镜像"。**

---

## 场景 1：为新 ADR 创建架构测试

### 用户意图

"我刚写了一个新的 ADR，需要创建对应的架构测试。"

### Copilot 必须做的

1. **检查 ADR 编号和测试文件命名**：
   ```
   根据 ADR-907 §2（命名与组织规范）：
   
   ✅ 测试文件位置：
   src/tests/ArchitectureTests/ADR/ADR_<编号>_<规则编号>_Tests.cs
   
   ✅ 命名格式（规则独立测试，避免类膨胀）：
   - 推荐：ADR_0907_1_Tests.cs、ADR_0907_2_Tests.cs（每个规则独立测试类）
   - 兼容：ADR_0907_Architecture_Tests.cs（单一规则或汇总测试）
   
   ✅ 命名空间：
   namespace Zss.BilliardHall.Tests.ArchitectureTests.ADR;
   
   ❌ 错误示例：
   - ADR907Tests.cs（缺少下划线）
   - ADR-907-Tests.cs（使用连字符）
   - ADR_907_Tests.cs（缺少规则编号或 Architecture）
   - 多个规则混合在同一个测试类
   ```

2. **提供测试类模板（规则级别）**：
   ```csharp
   using NetArchTest.Rules;
   using System.Reflection;
   using Xunit;
   
   namespace Zss.BilliardHall.Tests.ArchitectureTests.ADR;
   
   /// <summary>
   /// ADR-XXXX.Y: [规则描述]
   /// 验证 ADR-XXXX 的第 Y 条规则：[具体规则说明]
   /// 
   /// 测试覆盖映射：
   /// - 场景 1: [行为场景描述] → [测试方法名]
   /// - 场景 2: [行为场景描述] → [测试方法名]
   /// 
   /// 关联文档：
   /// - ADR: docs/adr/[category]/ADR-XXXX-[title].md
   /// - Prompts: docs/copilot/adr-XXXX.prompts.md
   /// </summary>
   public sealed class ADR_XXXX_Y_Tests
   {
       [Fact(DisplayName = "ADR-XXXX.Y: [场景描述]")]
       public void Scenario_1_Should_Be_Validated()
       {
           // 实现测试逻辑
           
           Assert.True(result.IsSuccessful,
               $"❌ ADR-XXXX.Y 违规：[违规描述]\n\n" +
               $"违规类型：{string.Join(", ", failingTypes)}\n\n" +
               $"修复建议：\n" +
               $"  1. [修复步骤 1]\n" +
               $"  2. [修复步骤 2]\n\n" +
               $"参考：docs/adr/[category]/ADR-XXXX-[title].md");
       }
       
       [Fact(DisplayName = "ADR-XXXX.Y: [另一个场景描述]")]
       public void Scenario_2_Should_Be_Validated()
       {
           // 实现另一个场景的测试逻辑
       }
   }
   ```

3. **提醒必须遵守的规则**：
   ```
   根据 ADR-907，必须确保：
   
   ✅ 规则独立测试（§2.3，避免类膨胀）：
   - 每一条具体架构规则使用独立的测试类
   - 禁止多个规则混合在同一个测试类
   - 测试类命名：ADR_<编号>_<规则编号>_Tests
   
   ✅ 单一 ADR 映射（§2.4）：
   - 一个测试类只覆盖一个 ADR 的一个规则
   - DisplayName 必须引用正确的 ADR 编号和规则编号
   - 可以引用依赖的 ADR（如 ADR-0000、ADR-905）
   
   ✅ 方法命名（§2.6）：
   - 测试方法对应规则下的具体行为场景
   - 方法命名需能映射具体规则及行为
   - 在 DisplayName 中明确：ADR-XXXX.Y: <场景描述>
   
   ✅ 失败消息（§2.7）：
   - 必须包含 ADR 编号和规则编号
   - 格式：❌ ADR-XXXX.Y 违规：...
   - 包含修复建议和文档链接
   
   ✅ 有效断言（§3）：
   - 至少 1 个有效断言
   - 禁止 Assert.True(true) 等形式化断言
   - 断言必须验证结构约束
   ```

### 示例对话

**开发者**："我创建了 ADR-950，规定 Repository 接口必须在 Domain 层，如何写测试？"

**Copilot**：
```
根据 ADR-907 架构测试规范：

1. 创建测试文件：
   src/tests/ArchitectureTests/ADR/ADR_0950_Architecture_Tests.cs

2. 使用以下模板：

```csharp
using NetArchTest.Rules;
using Xunit;

namespace Zss.BilliardHall.Tests.ArchitectureTests.ADR;

/// <summary>
/// ADR-950: Repository 接口必须在 Domain 层
/// 验证 Repository 接口的位置和命名约束
/// 
/// 测试覆盖映射：
/// - ADR-950.1: Repository 接口必须在 Domain 命名空间 → Repository_Interfaces_Must_Be_In_Domain
/// - ADR-950.2: Repository 接口必须以 IRepository 结尾 → Repository_Interfaces_Must_Follow_Naming
/// </summary>
public sealed class ADR_0950_Architecture_Tests
{
    [Theory(DisplayName = "ADR-950.1: Repository 接口必须在 Domain 命名空间")]
    [ClassData(typeof(ModuleAssemblyData))]
    public void Repository_Interfaces_Must_Be_In_Domain(Assembly moduleAssembly)
    {
        var result = Types
            .InAssembly(moduleAssembly)
            .That()
            .HaveNameEndingWith("Repository")
            .And()
            .AreInterfaces()
            .Should()
            .ResideInNamespace("Domain")
            .GetResult();

        Assert.True(result.IsSuccessful,
            $"❌ ADR-950.1 违规：Repository 接口必须位于 Domain 命名空间\n\n" +
            $"违规接口：{string.Join(", ", result.FailingTypes?.Select(t => t.FullName) ?? Array.Empty<string>())}\n\n" +
            $"修复建议：\n" +
            $"  1. 将 Repository 接口移至 Domain 层\n" +
            $"  2. 命名空间格式：Modules.<ModuleName>.Domain\n\n" +
            $"参考：docs/adr/structure/ADR-950-repository-location.md");
    }
}
```

3. 创建对应的 Prompts 文件：
   docs/copilot/adr-0950.prompts.md

参考：
- ADR-907 §2 命名与组织规范
- 现有测试示例：ADR_0123_Architecture_Tests.cs
```

---

## 场景 2：架构测试失败排查

### 用户意图

"架构测试失败了，不知道如何修复。"

### Copilot 必须做的

1. **识别失败的测试和规则**：
   ```
   从失败消息中提取：
   - ADR 编号：ADR-XXXX
   - 子规则：XXXX.Y
   - 执行级别：L1 或 L2
   ```

2. **判断是否可以破例**：
   ```
   根据 ADR-907 §4（Enforcement）：
   
   L1 规则失败：
   ❌ 不允许破例，必须修复代码
   - L1 规则是可自动验证的红线约束
   - 必须按照修复建议调整代码
   
   L2 规则失败：
   ⚠️ 可以申请破例
   - 需要充分理由和架构审批
   - 必须记录在破例机制中（ADR-0000）
   ```

3. **提供修复指导**：
   ```
   1. 查阅对应的 ADR 文档
   2. 参考测试失败消息中的修复建议
   3. 查看对应的 Copilot Prompts
   4. 参考现有的合规实现
   ```

### 示例对话

**开发者**：
```
测试失败：
❌ ADR-907.4 违规：以下测试类命名不符合规范
  • ADR_920_Architecture_Tests.cs
```

**Copilot**：
```
根据 ADR-907 §2.4 测试类命名规范：

问题诊断：
- 文件名 ADR_920_Architecture_Tests.cs 使用 3 位编号
- 推荐使用 4 位编号格式

修复方案：

方案 1（推荐）：重命名为 4 位格式
```bash
git mv src/tests/ArchitectureTests/ADR/ADR_920_Architecture_Tests.cs \
       src/tests/ArchitectureTests/ADR/ADR_0920_Architecture_Tests.cs
```

方案 2：保持 3 位格式（如果这是约定）
- ADR-907.4 测试也接受 3 位编号
- 但推荐整个项目统一使用 4 位格式

注意事项：
1. 重命名后需要更新类名和命名空间
2. 更新类内部的 DisplayName 中的 ADR 引用
3. 确保测试编译通过

参考：
- ADR-907 §2.4 测试类命名正则校验
- 示例：ADR_0001_Architecture_Tests.cs
```

---

## 场景 3：组织现有的架构测试

### 用户意图

"现有的架构测试很混乱，如何按照 ADR-907 重新组织？"

### Copilot 必须做的

1. **检查当前违规情况**：
   ```
   运行 ADR-907 架构测试：
   
   dotnet test --filter "FullyQualifiedName~ADR_0907"
   
   这会检测：
   - 命名不规范的测试文件
   - 跨 ADR 混合的测试
   - 缺少断言的测试
   - 使用 Skip 的测试
   ```

2. **提供重组方案**：
   ```
   根据 ADR-907 §2.2 目录结构要求：
   
   ✅ 正确结构：
   src/tests/ArchitectureTests/
   ├── ADR/
   │   ├── ADR_0001_Architecture_Tests.cs
   │   ├── ADR_0002_Architecture_Tests.cs
   │   └── ADR_0907_Architecture_Tests.cs
   ├── Governance/
   ├── Heuristics/
   └── TestData.cs
   
   ❌ 错误结构：
   - 测试文件不在 ADR 目录下
   - 多个 ADR 测试混在一个文件中
   - 测试文件命名不符合规范
   ```

3. **提供迁移步骤**：
   ```
   迁移清单：
   
   1. 创建 /ADR/ 目录（如果不存在）
   2. 按 ADR 拆分测试文件
   3. 重命名为规范格式
   4. 更新类名和命名空间
   5. 添加测试注释（映射到 ADR 子规则）
   6. 确保失败消息包含 ADR 引用
   7. 运行测试验证
   ```

---

## 场景 4：配置 CI/Analyzer 集成

### 用户意图

"如何确保架构测试在 CI 中正确执行？"

### Copilot 必须做的

1. **检查项目配置**：
   ```
   根据 ADR-907 §4.1 CI/Analyzer 自动注册：
   
   必需组件：
   ✅ ArchitectureTests.csproj 存在
   ✅ 引用 xUnit 测试框架
   ✅ 引用 NetArchTest.Rules
   ✅ CI 配置文件存在（.github/workflows）
   ```

2. **提供 CI 配置模板**：
   ```yaml
   # .github/workflows/architecture-tests.yml
   name: Architecture Tests
   
   on:
     pull_request:
       branches: [main, develop]
     push:
       branches: [main]
   
   jobs:
     architecture-tests:
       runs-on: ubuntu-latest
       steps:
         - uses: actions/checkout@v4
         
         - name: Setup .NET
           uses: actions/setup-dotnet@v4
           with:
             dotnet-version: '10.0.x'
         
         - name: Restore dependencies
           run: dotnet restore
         
         - name: Build
           run: dotnet build --no-restore
         
         - name: Run Architecture Tests
           run: |
             dotnet test \
               src/tests/ArchitectureTests/ArchitectureTests.csproj \
               --no-build \
               --verbosity normal \
               --logger "trx;LogFileName=architecture-tests.trx"
         
         - name: Publish Test Results
           if: always()
           uses: dorny/test-reporter@v1
           with:
             name: Architecture Test Results
             path: '**/architecture-tests.trx'
             reporter: dotnet-trx
             fail-on-error: true
   ```

3. **配置执行级别策略**：
   ```
   根据 ADR-907 §4.3 L1/L2 执行级别：
   
   L1 规则（失败阻断）：
   - 在 CI 中设置 fail-on-error: true
   - 测试失败直接阻断 PR 合并
   
   L2 规则（告警）：
   - 使用 Console.WriteLine 输出警告
   - 不阻断 CI，但在 PR 中可见
   - 需要人工 Code Review 确认
   ```

---

## 场景 5：处理 Skip 和条件禁用

### 用户意图

"某个架构测试暂时无法通过，可以 Skip 吗？"

### Copilot 必须做的

1. **检查是否可以 Skip**：
   ```
   根据 ADR-907 §2.8 禁止 Skip/条件禁用：
   
   ❌ 不允许：
   [Fact(Skip = "暂时跳过")]
   public void Some_Test() { }
   
   ❌ 不允许：
   [SkipOnCI]
   public void Some_Test() { }
   ```

2. **提供正确的处理方式**：
   ```
   如果测试无法通过：
   
   方案 1：修复代码（推荐）
   - 按照测试要求调整代码
   - 这是 L1 规则的唯一解决方案
   
   方案 2：申请破例（仅 L2 规则）
   - 通过 ADR-0000 破例机制
   - 记录：ADR 编号、测试类/方法、原因、到期时间
   - 获得架构审批
   - 在代码中添加注释说明破例
   
   方案 3：修订 ADR（规则本身有问题）
   - 提出 ADR 修订 RFC
   - 经架构委员会批准后修订
   - 同步更新测试
   ```

### 示例对话

**开发者**："测试 `Modules_Should_Not_Reference_Other_Modules` 失败了，但这是遗留代码，可以先 Skip 吗？"

**Copilot**：
```
根据 ADR-907 §2.8 和 ADR-0000 破例机制：

❌ 不能直接 Skip：
- ADR-907 明确禁止使用 Skip 或条件禁用
- Skip 会让架构测试失去意义

✅ 正确处理方式：

1. 评估规则级别：
   - ADR-0001.1 是 L1 规则（模块隔离）
   - L1 规则不允许破例

2. 短期方案（技术债）：
   ```markdown
   ## 技术债记录
   
   **违规**：ADR-0001.1 - 模块不应相互引用
   **位置**：Members 模块引用 Orders.Domain.Order
   **原因**：遗留代码，需重构
   **影响**：破坏模块边界，增加耦合
   **偿还计划**：
   - Q1: 创建 OrderDto 数据契约
   - Q1: 重构 Members 模块使用契约
   - Q2: 移除直接依赖
   **负责人**：@架构师
   **到期日期**：2026-03-31
   ```

3. 长期方案（重构）：
   - 创建数据契约代替直接依赖
   - 使用领域事件解耦
   - 参考 ADR-0001 §2.2 模块通信方式

重要：
- 技术债必须有明确的偿还计划
- 定期审查技术债清单
- 不能让技术债无限累积

参考：
- ADR-0000 破例与偿还机制
- ADR-907 §2.8 Skip/条件禁用检测
- ADR-905 执行级别分类
```

---

## 常见误区

### 误区 1："一个测试文件可以测试多个 ADR"

❌ **错误理解**：
"为了减少文件数量，我把相关的 ADR 测试放在一起。"

✅ **正确理解**：
根据 ADR-907 §2.3：
- 一个测试类只能覆盖一个 ADR
- 这确保了测试和 ADR 的清晰映射
- 便于维护和追溯

---

### 误区 2："测试方法名随意，只要 DisplayName 正确就行"

❌ **错误理解**：
"方法名不重要，反正有 DisplayName。"

✅ **正确理解**：
根据 ADR-907 §2.5：
- 方法名应该映射 ADR 子规则
- 推荐格式：ADR_<编号>_<子规则>_<行为描述>
- 方法名是代码的文档，应该清晰

---

### 误区 3："Assert.True(true) 也是断言"

❌ **错误理解**：
"只要有 Assert 语句就行，内容不重要。"

✅ **正确理解**：
根据 ADR-907 §3：
- 禁止形式化断言（Assert.True(true)）
- 断言必须验证实际的结构约束
- 空测试会被 L2 规则检测出来

---

### 误区 4："Skip 一下没关系，以后再修"

❌ **错误理解**：
"先 Skip 让 CI 通过，以后有时间再修。"

✅ **正确理解**：
根据 ADR-907 §2.8：
- 禁止使用 Skip 或条件禁用
- Skip 的测试会被 ADR-907.8 检测出来
- 必须通过破例机制正式处理

---

## 快速参考

### 测试文件命名规则

```
✅ 正确（规则独立测试，避免类膨胀）：
- ADR_0001_1_Tests.cs（按规则拆分，推荐）
- ADR_0001_2_Tests.cs（每个规则独立测试类）
- ADR_907_1_Tests.cs（3位编号也可）
- ADR_0907_Architecture_Tests.cs（兼容：单一规则或汇总测试）

❌ 错误：
- ADR-0001-Tests.cs（使用连字符）
- ADR_0001_Tests.cs（缺少规则编号或 Architecture）
- ADR0001ArchitectureTests.cs（缺少下划线）
- 多个规则混合在同一个测试类
```

### 测试方法命名规则

```
✅ 推荐（映射规则下的具体行为场景）：
- Scenario_1_Module_Cannot_Reference_Another_Module
- When_Creating_Repository_Interface_Must_Be_In_Domain
- Given_Invalid_Naming_Should_Fail_Validation（DisplayName 包含 ADR-XXXX.Y）

❌ 不推荐：
- Test1（无意义）
- ShouldPass（不明确）
- ADR_0001_1_Modules_Should_Not_Reference_Other_Modules（过于冗长，规则编号已在类名中标识）

说明：采用规则独立测试类后，规则编号已在类名（如 ADR_0001_1_Tests）中明确，
方法名无需重复规则编号，应直接描述具体测试场景。
```

### 失败消息格式

```csharp
Assert.True(result.IsSuccessful,
    $"❌ ADR-XXXX.Y 违规：[违规描述]\n\n" +
    $"违规类型：{string.Join(", ", failingTypes)}\n\n" +
    $"修复建议：\n" +
    $"  1. [步骤 1]\n" +
    $"  2. [步骤 2]\n\n" +
    $"参考：docs/adr/[path]/ADR-XXXX-[title].md");
```

### 执行级别对照

| 规则编号 | 执行级别 | 失败处理 |
|---------|---------|---------|
| ADR-907.1~907.7 | L1 | 必须修复，不能 Skip |
| ADR-907.9~907.12 | L1 | 必须修复，不能 Skip |
| ADR-907.8 | L2 | 记录告警，可协商 |
| ADR-907.13 | L2 | 记录告警，可协商 |

---

## 相关资源

- [ADR-907 ArchitectureTests 执法治理体系](../adr/governance/ADR-907-architecture-tests-enforcement-governance.md)
- [ADR-0000 架构测试宪法](../adr/governance/ADR-0000-architecture-tests.md)
- [ADR-905 执行级别分类](../adr/governance/ADR-905-enforcement-level-classification.md)
- [ADR-0900 ADR 新增与修订流程](../adr/governance/ADR-0900-adr-process.md)
- [architecture-test-failures.md](./architecture-test-failures.md)

---

**版本**：1.0  
**最后更新**：2026-01-29  
**维护**：GitHub Copilot Team
