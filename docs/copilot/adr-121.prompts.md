# ADR-121：契约（Contract）与 DTO 命名组织规范 - Copilot 提示词库

**关联 ADR**：[ADR-121](../adr/structure/ADR-121-contract-dto-naming-organization.md)  
**测试类**：`ADR_121_Architecture_Tests.cs`  
**版本**：1.0  
**最后更新**：2026-01-24  
**对应 ADR 版本**：v1.0

---

## 一、当我在写什么时，你应该提醒我哪些 ADR-121 约束？

### 场景 1：创建新的契约/DTO

**触发条件**：

- 在 `Platform/Contracts/` 下创建新类型
- 在 `Modules/{ModuleName}/Contracts/` 下创建新类型
- 创建任何以 `Dto` 或 `Contract` 结尾的类型

**你应该提醒的约束**：

```
✅ 检查清单：
1. 类型名是否以 Dto 或 Contract 结尾？
2. 是否位于正确的命名空间（.Contracts）？
3. 是否使用 record 类型（推荐）或 init-only 属性？
4. 是否只包含原始类型和其他 DTO？
5. 是否避免了业务方法？

❌ 禁止：
- 使用模糊名称（如 Data, Object, Entity）
- 包含可变属性（set 访问器）
- 包含业务逻辑方法
- 包含领域模型类型（Entity, Aggregate, ValueObject）
```

**✅ 正确示例**：

```csharp
// ✅ 推荐：使用 record 类型
namespace Zss.BilliardHall.Platform.Contracts.Members;

public record MemberInfoDto(
    Guid MemberId,
    string UserName,
    string Email
);

// ✅ 或使用 init-only 属性
public class MemberDetailContract
{
    public required Guid MemberId { get; init; }
    public required string UserName { get; init; }
    public required string Email { get; init; }
    public string? PhoneNumber { get; init; }
}
```

**❌ 错误示例**：

```csharp
// ❌ 缺少后缀
public record MemberInfo(Guid MemberId, string UserName);

// ❌ 可变属性
public class MemberInfoDto
{
    public Guid MemberId { get; set; }  // ❌
}

// ❌ 包含业务方法
public record MemberInfoDto(Guid MemberId, string UserName)
{
    public bool CanUpgrade() => /* 业务逻辑 */;  // ❌
}

// ❌ 包含领域模型类型
public record OrderDetailContract(
    Guid OrderId,
    Order Order  // ❌ 领域实体
);
```

---

### 场景 2：跨模块数据传递

**触发条件**：

- 在 Handler 中查询其他模块的数据
- 通过事件传递跨模块数据
- API 返回数据给前端

**你应该提醒的约束**：

```
✅ 检查清单：
1. 是否使用契约（Dto/Contract）而非领域模型？
2. 契约是否位于 Contracts 命名空间？
3. Command Handler 是否避免依赖契约做业务决策？
4. 是否使用原始类型（Guid, string）传递标识？

❌ 禁止：
- 跨模块传递领域实体
- Command Handler 依赖契约进行业务判断
- 在契约中嵌入跨模块业务语义
```

**✅ 正确做法**：

```csharp
// ✅ Query Handler 返回契约
public class GetMemberByIdQueryHandler : IQueryHandler<GetMemberById, MemberInfoDto>
{
    public async Task<MemberInfoDto> Handle(GetMemberById query)
    {
        var member = await _repository.GetByIdAsync(query.MemberId);
        
        // ✅ 转换为契约
        return new MemberInfoDto(
            member.Id,
            member.UserName,
            member.Email
        );
    }
}

// ✅ Command Handler 使用原始类型，不依赖契约做业务决策
public class CreateOrderHandler : ICommandHandler<CreateOrder>
{
    public async Task<Guid> Handle(CreateOrder command)
    {
        // ✅ 只使用 ID（原始类型）
        var order = new Order(command.MemberId, command.Items);
        
        // ✅ 业务逻辑在领域模型中
        order.Calculate();
        
        await _repository.SaveAsync(order);
        return order.Id;
    }
}

// ✅ 事件传递契约数据
public record OrderCreatedEvent(
    Guid OrderId,
    Guid MemberId,
    decimal TotalAmount,
    DateTime CreatedAt
);
```

**❌ 错误做法**：

```csharp
// ❌ Command Handler 依赖契约做业务决策
public class CreateOrderHandler
{
    public async Task<Guid> Handle(CreateOrder command)
    {
        // ❌ 查询契约用于业务判断
        var memberDto = await _queryBus.Send(new GetMemberById(command.MemberId));
        
        if (memberDto.Balance > 1000)  // ❌ 基于 DTO 的业务决策
        {
            // 业务逻辑
        }
    }
}

// ❌ 直接传递领域实体
public record OrderCreatedEvent(
    Guid OrderId,
    Member Member,  // ❌ 领域实体
    Order Order     // ❌ 领域实体
);
```

---

### 场景 3：契约版本演进

**触发条件**：

- 需要修改现有契约
- 添加/删除/重命名契约属性
- 契约已被其他模块使用

**你应该提醒的约束**：

```
✅ 检查清单：
1. 是破坏性变更还是非破坏性变更？
2. 破坏性变更是否创建了新版本（V2, V3）？
3. 是否使用 [Obsolete] 标记旧版本？
4. 是否记录了版本历史和迁移指南？
5. 旧版本是否保留到所有消费方迁移完成？
6. 嵌套 DTO 是否也需要版本管理？

版本判断：
- 非破坏性：添加可选属性 → 无需版本号
- 破坏性：删除/重命名属性、改变类型 → 创建新版本

废弃策略：
- 阶段 1：使用 [Obsolete("...", false)] 标记（警告级别）
- 阶段 2：6 个月后升级为 [Obsolete("...", true)]（错误级别）
- 阶段 3：12 个月后完全移除旧版本
```

**✅ 正确做法**：

```csharp
// 原始版本（标记为废弃）
[Obsolete("Use MemberInfoDtoV2 instead. This version will be removed after 2025-01-01.", false)]
public record MemberInfoDto(Guid MemberId, string UserName);

// V2 版本（添加必需属性 Email，破坏性变更）
/// <summary>
/// 会员信息契约 V2
/// </summary>
/// <remarks>
/// 版本历史：
/// - V1 (2024-01-01): 初始版本，包含 MemberId 和 UserName
/// - V2 (2024-06-01): 添加 Email 字段（破坏性变更）
/// 
/// 迁移指南：
/// 1. V1 用户需要更新到 V2，提供 Email 字段
/// 2. V2 将在 2025-01-01 后成为默认版本，V1 标记为废弃
/// 3. 迁移文档：docs/migrations/member-info-v1-to-v2.md
/// 
/// 自动化迁移：
/// - 使用 Roslyn analyzer 检测 V1 使用并提供代码修复
/// - CI 管道会警告使用废弃版本的 PR
/// </remarks>
[Obsolete("Use MemberInfoDtoV3 for new implementations.", false)]
public record MemberInfoDtoV2(
    Guid MemberId,
    string UserName,
    string Email
);

// V3 版本（最新版本）
public record MemberInfoDtoV3(
    Guid MemberId,
    string UserName,
    string Email,
    string PhoneNumber
);

// 嵌套 DTO 也需要版本管理
[Obsolete("Use OrderItemDtoV2 for new implementations.", false)]
public record OrderItemDto(
    Guid ProductId,
    string ProductName,
    int Quantity,
    decimal UnitPrice
);

public record OrderItemDtoV2(
    Guid ProductId,
    string ProductName,
    int Quantity,
    decimal UnitPrice,
    decimal DiscountRate  // 新增字段
);
```

**❌ 错误做法**：

```csharp
// ❌ 直接修改原契约（破坏性变更）
public record MemberInfoDto(
    Guid MemberId,
    string UserName,
    string Email  // ❌ 添加必需属性，破坏现有使用方
);

// ❌ 没有 [Obsolete] 标记
public record MemberInfoDto(Guid MemberId, string UserName);  // 应该标记废弃

// ❌ 没有版本历史和迁移指南
public record MemberInfoDtoV2(
    Guid MemberId,
    string UserName,
    string Email
);
// 缺少注释说明变更原因和迁移指南
```

---

### 场景 4：模块内 DTO vs 跨模块契约

**触发条件**：

- 在 Features 目录下创建 DTO
- 需要决定 DTO 的可见性范围
- 考虑是否对外暴露数据

**你应该提醒的约束**：

```
✅ 检查清单：
1. 这个 DTO 是否需要跨模块使用？
   - 是 → 放在 Contracts 目录，使用 Dto/Contract 后缀
   - 否 → 可以放在 Features 目录，仅模块内使用

2. DTO 的命名是否明确其范围？
   - 跨模块契约：MemberInfoDto, OrderDetailContract
   - 模块内 DTO：MemberDto（在注释中说明）

3. 是否避免模块内 DTO 泄露到其他模块？
```

**✅ 正确组织**：

```
src/
  Platform/
    Contracts/
      Members/
        MemberInfoDto.cs         # ✅ 跨模块契约
  Modules/
    Members/
      Features/
        GetMemberById/
          MemberDto.cs           # ✅ 模块内 DTO（注释说明）
```

```csharp
// ✅ 跨模块契约（在 Platform.Contracts）
namespace Zss.BilliardHall.Platform.Contracts.Members;

public record MemberInfoDto(
    Guid MemberId,
    string UserName,
    string Email
);

// ✅ 模块内 DTO（在 Features 目录）
namespace Zss.BilliardHall.Modules.Members.Features.GetMemberById;

/// <summary>
/// 会员 DTO（数据传输对象）
/// 注意：这是模块内部的 DTO，不是跨模块的 Contract
/// 如果需要暴露给其他模块，应该定义在 Platform.Contracts 中
/// </summary>
public record MemberDto(
    Guid Id,
    string Name,
    string Email
);
```

---

## 二、哪些写法必须阻止？

### 反模式 1：契约包含领域模型

**❌ 错误示例**：

```csharp
// ❌ 契约包含领域实体
using Zss.BilliardHall.Modules.Orders.Domain;

public record OrderDetailContract(
    Guid OrderId,
    Order Order,              // ❌ 领域实体
    Member Member,            // ❌ 领域实体
    List<OrderItem> Items     // ❌ 领域实体集合
);
```

**✅ 正确做法**：

```csharp
// ✅ 契约只包含原始类型和其他 DTO
public record OrderDetailContract(
    Guid OrderId,
    Guid MemberId,                           // ✅ 原始类型
    string MemberName,                       // ✅ 原始类型
    IReadOnlyList<OrderItemDto> Items,       // ✅ DTO 集合
    decimal TotalAmount                      // ✅ 原始类型
);

public record OrderItemDto(
    Guid ProductId,
    string ProductName,
    int Quantity,
    decimal UnitPrice
);
```

---

### 反模式 2：Command Handler 依赖契约做业务决策

**❌ 错误示例**：

```csharp
public class CreateOrderHandler
{
    public async Task<Guid> Handle(CreateOrder command)
    {
        // ❌ 查询契约用于业务判断
        var memberDto = await _queryBus.Send(new GetMemberById(command.MemberId));
        
        if (memberDto.Balance > 1000)  // ❌ 基于 DTO 的业务决策
        {
            // 创建订单
        }
        else
        {
            throw new InsufficientBalanceException();
        }
    }
}
```

**✅ 正确做法**：

```csharp
public class CreateOrderHandler
{
    public async Task<Guid> Handle(CreateOrder command)
    {
        // ✅ 加载聚合根
        var member = await _memberRepository.GetByIdAsync(command.MemberId);
        
        // ✅ 在领域模型上执行业务逻辑
        if (!member.CanPlaceOrder())
        {
            throw new InsufficientBalanceException();
        }
        
        var order = new Order(member.Id, command.Items);
        await _orderRepository.SaveAsync(order);
        return order.Id;
    }
}
```

---

### 反模式 3：契约包含业务方法

**❌ 错误示例**：

```csharp
// ❌ 契约包含业务方法
public record MemberInfoDto(Guid MemberId, string UserName, decimal Balance)
{
    // ❌ 业务判断方法
    public bool CanUpgrade() => Balance > 1000;
    
    // ❌ 状态修改方法
    public void AddBalance(decimal amount) => /* 修改状态 */;
    
    // ❌ 验证方法
    public bool IsValid() => !string.IsNullOrEmpty(UserName);
}
```

**✅ 正确做法**：

```csharp
// ✅ 契约只包含数据
public record MemberInfoDto(
    Guid MemberId,
    string UserName,
    decimal Balance
);

// ✅ 业务逻辑在领域模型中
public class Member
{
    public bool CanUpgrade() => Balance > 1000;  // ✅ 在领域模型中
}

// ✅ 验证逻辑在 Validator 中
public class MemberValidator
{
    public bool IsValid(Member member) => !string.IsNullOrEmpty(member.UserName);
}
```

---

### 反模式 4：契约命名模糊

**❌ 错误示例**：

```csharp
// ❌ 缺少后缀
public record Member(Guid Id, string Name);
public record MemberInfo(Guid Id, string Name);

// ❌ 使用模糊名称
public record MemberData(Guid Id);
public record MemberObject(Guid Id);
public record MemberEntity(Guid Id);  // Entity 保留给领域模型

// ❌ 泛型名称
public record DataObject<T>(T Data);
public record Response(object Data);
```

**✅ 正确做法**：

```csharp
// ✅ 明确的命名
public record MemberInfoDto(Guid MemberId, string UserName, string Email);
public record MemberDetailContract(Guid MemberId, string UserName, string Email, string PhoneNumber);
public record MemberSummaryDto(Guid MemberId, string UserName);
public record MemberListDto(Guid MemberId, string UserName, DateTime LastActiveAt);
```

---

## 三、架构测试失败时如何解读？

### 测试失败：ADR-121.1

**错误消息**：

```
❌ ADR-121.1 违规: 契约类型缺少 'Dto' 或 'Contract' 后缀

违规类型: Zss.BilliardHall.Platform.Contracts.Members.MemberInfo
```

**原因分析**：

- 类型位于 Contracts 命名空间，但缺少必需的后缀

**修复步骤**：

1. 重命名类型，添加 `Dto` 或 `Contract` 后缀
2. 根据用途选择合适的后缀：
   - 信息摘要：`MemberInfoDto`
   - 详细信息：`MemberDetailContract`
   - 列表项：`MemberListDto`

---

### 测试失败：ADR-121.2

**错误消息**：

```
❌ ADR-121.2 违规: 契约属性必须是只读的

违规类型: Zss.BilliardHall.Platform.Contracts.Members.MemberInfoDto
可变属性: UserName
```

**原因分析**：

- 契约属性使用了公共 `set` 访问器，违反不可变性约束

**修复步骤**：

1. 推荐：使用 `record` 类型（自动不可变）
2. 或使用 `init` 访问器替代 `set`
3. 或移除 `set` 访问器，使用只读属性

---

### 测试失败：ADR-121.4

**错误消息**：

```
❌ ADR-121.4 违规: 契约包含领域模型类型

违规契约: Zss.BilliardHall.Platform.Contracts.Orders.OrderDetailContract
领域模型类型: Zss.BilliardHall.Modules.Orders.Domain.Order
```

**原因分析**：

- 契约直接引用了领域实体，违反模块隔离原则

**修复步骤**：

1. 创建对应的 DTO：`OrderDto`
2. 只传递必要的数据，不传递领域对象
3. 或使用原始类型（如 `Guid OrderId`）

---

## 四、快速决策树

```
需要在模块间传递数据？
├─ 是
│  ├─ 创建契约类型（Dto/Contract）
│  ├─ 放在 Platform.Contracts 或 Modules/{Module}/Contracts
│  ├─ 使用 record 类型
│  └─ 只包含原始类型和其他 DTO
└─ 否
   ├─ 可以使用模块内 DTO
   ├─ 放在 Features 目录
   └─ 在注释中说明不对外暴露

需要修改契约？
├─ 非破坏性变更（添加可选属性）
│  └─ 直接添加，无需版本号
└─ 破坏性变更（删除/重命名/改变类型）
   ├─ 创建新版本（V2, V3）
   ├─ 记录版本历史
   └─ 保留旧版本直到迁移完成

Command Handler 需要数据？
├─ 需要业务判断
│  └─ 加载领域模型，不使用契约
└─ 只需要标识
   └─ 使用原始类型（Guid, string）
```

---

## 五、常见问题

### Q1: 什么时候使用 Dto，什么时候使用 Contract？

**A**：两者在技术上等价，选择取决于团队习惯：

- **Dto**：更通用，适用于所有数据传输场景
- **Contract**：强调跨模块契约性质，更正式

**建议**：在同一项目中保持一致，或按用途区分：

- 查询返回：使用 `Dto`
- 跨模块契约：使用 `Contract`

---

### Q2: 计算属性算不算业务方法？

**A**：计算属性（基于现有数据的只读属性）是允许的：

```csharp
// ✅ 允许：计算属性
public record OrderDetailContract(
    Guid OrderId,
    IReadOnlyList<OrderItemDto> Items,
    decimal SubTotal
)
{
    // ✅ 基于现有数据计算，无副作用
    public decimal TotalAmount => Items.Sum(i => i.TotalPrice);
}
```

---

### Q3: 契约可以嵌套吗？

**A**：可以，契约可以包含其他契约（DTO）：

```csharp
// ✅ 允许：契约嵌套
public record OrderDetailContract(
    Guid OrderId,
    IReadOnlyList<OrderItemDto> Items  // ✅ 嵌套 DTO
);

public record OrderItemDto(
    Guid ProductId,
    string ProductName,
    int Quantity
);
```

---

### Q4: 模块内 DTO 需要遵守所有约束吗？

**A**：模块内 DTO（在 Features 目录下）有更大灵活性：

- 可以不使用 `Dto` 后缀（但建议使用）
- 可以不在 Contracts 命名空间
- 但仍建议保持不可变性和无业务方法

**⚠️ 注意**：模块内 DTO 不得被其他模块引用。

---

## 六、参考资源

- [ADR-121: 契约与 DTO 命名组织规范](../adr/structure/ADR-121-contract-dto-naming-organization.md)
- [ADR-001: 模块化单体与垂直切片架构](../adr/constitutional/ADR-001-modular-monolith-vertical-slice-architecture.md)
- [ADR-005: 应用内交互模型](../adr/constitutional/ADR-005-Application-Interaction-Model-Final.md)
- [ADR-120: 领域事件命名规范](../adr/structure/ADR-120-domain-event-naming-convention.md)
- [Martin Fowler: DTO Pattern](https://martinfowler.com/eaaCatalog/dataTransferObject.html)

---

## 七、版本历史

| 版本  | 日期         | 变更说明        | 修订人            |
|-----|------------|-------------|----------------|
| 1.0 | 2026-01-24 | 初稿发布，定义提示词库 | GitHub Copilot |
