# ADR-0005：应用内交互模型与执行边界 - Copilot 提示词库

**关联 ADR**：[ADR-0005](../adr/constitutional/ADR-0005-Application-Interaction-Model-Final.md)  
**测试类**：`ADR_0005_Architecture_Tests.cs`  
**版本**：1.0  
**最后更新**：2026-01-21

---

## 一、当我在写什么时，你应该提醒我哪些 ADR-0005 约束？

### 场景 1：创建新的业务用例

**触发条件**：
- 添加新的 Use Case 文件夹
- 创建 Command 或 Query
- 实现 Handler

**你应该提醒的约束**：
```
✅ 检查清单：
1. Use Case 是否有明确的 Command 或 Query？
2. 是否有对应的 Handler 实现？
3. Handler 是否是该业务用例的唯一权威？
4. Endpoint 是否只负责转发，不包含业务逻辑？

Use Case 结构：
UseCases/
  CreateOrder/
    CreateOrder.cs         ← Command
    CreateOrderHandler.cs  ← Handler
    CreateOrderEndpoint.cs ← Endpoint（可选）

❌ 禁止：
- Endpoint 包含业务逻辑
- Handler 之间相互调用
- Handler 维护长期状态
```

---

### 场景 2：实现 Command Handler

**触发条件**：
- 创建或修改 Command Handler
- 处理写入操作

**你应该提醒的约束**：
```
✅ Command Handler 职责：
1. 接收 Command，执行业务逻辑
2. 修改状态，保存数据
3. 发布领域事件（如果需要通知其他模块）

❌ Command Handler 禁止：
- 返回业务数据（除了 ID）
- 依赖 Contracts 进行业务决策
- 承载长期状态
- 直接调用其他模块的 Handler

标准模板：
public class CreateOrderHandler : ICommandHandler<CreateOrder>
{
    public async Task Handle(CreateOrder command)
    {
        // 1. 加载或创建聚合
        var order = new Order(command.MemberId, command.Items);
        
        // 2. 执行业务逻辑
        order.Calculate();
        
        // 3. 保存状态
        await _repository.SaveAsync(order);
        
        // 4. 发布事件（可选）
        await _eventBus.Publish(new OrderCreated(order.Id));
    }
}
```

---

### 场景 3：实现 Query Handler

**触发条件**：
- 创建或修改 Query Handler
- 处理读取操作

**你应该提醒的约束**：
```
✅ Query Handler 职责：
1. 接收 Query
2. 查询数据
3. 返回 Contracts（DTO）

✅ Query Handler 特权：
- 可以返回 Contracts
- 可以跨模块查询（通过 Contracts）
- 可以优化查询性能

❌ Query Handler 禁止：
- 修改状态
- 执行业务逻辑
- 发布事件
- 返回领域模型

标准模板：
public class GetOrderByIdHandler : IQueryHandler<GetOrderById, OrderDto>
{
    public async Task<OrderDto> Handle(GetOrderById query)
    {
        // 直接查询并返回 DTO
        return await _queryService.GetOrderByIdAsync(query.OrderId);
    }
}
```

---

### 场景 4：模块间通信

**触发条件**：
- 需要在一个模块中访问另一个模块的数据
- 需要跨模块执行业务逻辑

**你应该提醒的约束**：
```
✅ 模块间通信方式：

1. **异步事件**（推荐）：
   - 发布者不知道订阅者
   - 不等待响应
   - 最终一致性
   
   示例：
   await _eventBus.Publish(new OrderCreated(orderId, memberId));

2. **同步查询**（谨慎使用）：
   - 通过 Contracts 查询数据
   - 只用于读取，不用于业务决策
   
   示例：
   var memberDto = await _queryBus.Send(new GetMemberById(memberId));

3. **原始类型**：
   - 传递标识符（Guid, int, string）
   
   示例：
   var orderId = command.MemberId; // Guid

❌ 绝对禁止：
- 模块间同步调用 Command Handler
- 共享领域模型
- 分布式事务
```

---

### 场景 5：创建 Endpoint

**触发条件**：
- 添加新的 HTTP Endpoint
- 暴露 API

**你应该提醒的约束**：
```
✅ Endpoint 职责：
1. 接收 HTTP 请求
2. 映射为 Command 或 Query
3. 转发给 Handler
4. 返回响应

❌ Endpoint 禁止：
- 包含业务逻辑
- 直接访问数据库
- 直接调用领域模型

标准模板：
public class CreateOrderEndpoint : IEndpoint
{
    public void MapEndpoint(IEndpointRouteBuilder builder)
    {
        builder.MapPost("/orders", async (
            CreateOrderRequest request, 
            IMessageBus bus) =>
        {
            // 1. 映射为 Command
            var command = new CreateOrder(
                request.MemberId, 
                request.Items);
            
            // 2. 转发给 Handler
            var orderId = await bus.InvokeAsync(command);
            
            // 3. 返回响应
            return Results.Created($"/orders/{orderId}", orderId);
        });
    }
}
```

---

## 二、哪些写法必须阻止？

### 反模式 1：Endpoint 包含业务逻辑

**❌ 错误示例**：
```csharp
app.MapPost("/orders", async (CreateOrderRequest request) =>
{
    // ❌ 业务逻辑不应该在 Endpoint 中
    if (request.Amount > 10000)
    {
        return Results.BadRequest("金额超限");
    }
    
    var order = new Order(request.MemberId, request.Items);
    await dbContext.SaveChangesAsync();
    return Results.Ok(order.Id);
});
```

**✅ 正确做法**：
```csharp
app.MapPost("/orders", async (CreateOrderRequest request, IMessageBus bus) =>
{
    // ✅ Endpoint 只负责转发
    var command = new CreateOrder(request.MemberId, request.Items);
    var orderId = await bus.InvokeAsync(command);
    return Results.Created($"/orders/{orderId}", orderId);
});

// 业务逻辑在 Handler 中
public class CreateOrderHandler
{
    public async Task<Guid> Handle(CreateOrder command)
    {
        // ✅ 业务逻辑在这里
        if (command.Amount > 10000)
        {
            throw new InvalidOrderAmountException();
        }
        
        var order = new Order(command.MemberId, command.Items);
        await _repository.SaveAsync(order);
        return order.Id;
    }
}
```

---

### 反模式 2：Command Handler 依赖 Contracts

**❌ 错误示例**：
```csharp
public class RechargeBalanceHandler
{
    public async Task Handle(RechargeBalance command)
    {
        // ❌ Command Handler 不应该依赖 Contracts 进行业务决策
        var memberDto = await _queryBus.Send(new GetMemberById(command.MemberId));
        
        if (memberDto.Balance + command.Amount > 10000)
        {
            throw new InvalidOperationException("余额超限");
        }
        
        // ❌ 基于 DTO 的数据更新
        await _dbContext.ExecuteSqlAsync($"UPDATE Members SET Balance = {memberDto.Balance + command.Amount}");
    }
}
```

**✅ 正确做法**：
```csharp
public class RechargeBalanceHandler
{
    public async Task Handle(RechargeBalance command)
    {
        // ✅ 加载领域模型
        var member = await _repository.GetByIdAsync(command.MemberId);
        
        // ✅ 业务逻辑在领域模型中
        member.Recharge(command.Amount); // 内部包含余额验证
        
        // ✅ 保存领域模型
        await _repository.SaveAsync(member);
    }
}

// 领域模型中的业务规则
public class Member
{
    public void Recharge(decimal amount)
    {
        if (Balance + amount > 10000)
        {
            throw new BalanceExceededException();
        }
        
        Balance += amount;
        AddDomainEvent(new BalanceRecharged(Id, amount));
    }
}
```

---

### 反模式 3：Handler 维护长期状态

**❌ 错误示例**：
```csharp
public class OrderProcessingHandler
{
    // ❌ Handler 不应该维护长期状态
    private readonly Dictionary<Guid, Order> _pendingOrders = new();
    
    public async Task Handle(ProcessOrder command)
    {
        var order = _pendingOrders[command.OrderId];
        order.Process();
        _pendingOrders.Remove(command.OrderId);
    }
}
```

**✅ 正确做法**：
```csharp
public class ProcessOrderHandler
{
    // ✅ Handler 无状态，从持久化中加载
    public async Task Handle(ProcessOrder command)
    {
        var order = await _repository.GetByIdAsync(command.OrderId);
        order.Process();
        await _repository.SaveAsync(order);
    }
}
```

---

### 反模式 4：模块间同步调用 Command

**❌ 错误示例**：
```csharp
// 在 Orders 模块中
public class CreateOrderHandler
{
    public async Task Handle(CreateOrder command)
    {
        var order = new Order(command.MemberId, command.Items);
        await _repository.SaveAsync(order);
        
        // ❌ 不允许同步调用其他模块的 Command
        await _commandBus.Send(new UpdateMemberStatistics(command.MemberId));
    }
}
```

**✅ 正确做法**：
```csharp
// 在 Orders 模块中
public class CreateOrderHandler
{
    public async Task Handle(CreateOrder command)
    {
        var order = new Order(command.MemberId, command.Items);
        await _repository.SaveAsync(order);
        
        // ✅ 通过异步事件通知
        await _eventBus.Publish(new OrderCreated(order.Id, command.MemberId));
    }
}

// 在 Members 模块中订阅事件
public class OrderCreatedHandler
{
    public async Task Handle(OrderCreated @event)
    {
        // ✅ 异步更新统计
        var member = await _repository.GetByIdAsync(@event.MemberId);
        member.IncrementOrderCount();
        await _repository.SaveAsync(member);
    }
}
```

---

## 三、CI 失败时，你应该如何解释？

### 失败消息：Endpoint 包含业务逻辑

**CI 输出示例**：
```
❌ Test Failed: Endpoints_Should_Not_Contain_Business_Logic
   Expected: Endpoints only map and forward
   Actual: Found business logic in CreateOrderEndpoint
```

**你应该这样解释**：
```
根据 ADR-0005，Endpoint 不应该包含业务逻辑。

问题分析：
- Endpoint 中发现业务判断或数据处理
- Endpoint 只负责 HTTP → Command/Query → Handler

修复建议：
1. 将业务逻辑移到 Handler
2. Endpoint 只保留：
   - 接收请求
   - 映射为 Command/Query
   - 调用 Handler
   - 返回响应

示例重构：
// ❌ 当前
app.MapPost("/orders", async (request) => {
    if (request.Amount > 10000) { ... } // 业务逻辑
    var order = new Order(...);
    await dbContext.SaveAsync(order);
});

// ✅ 重构后
app.MapPost("/orders", async (request, bus) => {
    var command = new CreateOrder(request.MemberId, request.Items);
    var orderId = await bus.InvokeAsync(command);
    return Results.Created($"/orders/{orderId}", orderId);
});
```

---

### 失败消息：Command Handler 返回业务数据

**CI 输出示例**：
```
❌ Test Failed: Command_Handler_Should_Not_Return_Data
   Expected: Command returns void or ID only
   Actual: CreateOrderHandler returns OrderDto
```

**你应该这样解释**：
```
根据 ADR-0005，Command Handler 不应该返回业务数据。

问题分析：
- Command 用于修改状态，不用于查询
- 返回业务数据会导致 CQRS 边界模糊

修复建议：
1. Command Handler 只返回 ID 或 void
2. 如果需要查询数据，使用单独的 Query

示例修复：
// ❌ Command 返回业务数据
public async Task<OrderDto> Handle(CreateOrder command)
{
    var order = new Order(...);
    await _repository.SaveAsync(order);
    return new OrderDto { ... }; // ❌ 不应该返回
}

// ✅ Command 只返回 ID
public async Task<Guid> Handle(CreateOrder command)
{
    var order = new Order(...);
    await _repository.SaveAsync(order);
    return order.Id; // ✅ 只返回 ID
}

// ✅ 需要数据时，使用 Query
var orderId = await _bus.InvokeAsync(new CreateOrder(...));
var orderDto = await _bus.InvokeAsync(new GetOrderById(orderId));
```

---

### 失败消息：Query Handler 修改状态

**CI 输出示例**：
```
❌ Test Failed: Query_Handler_Should_Not_Modify_State
   Expected: Query only reads data
   Actual: GetOrdersHandler modifies state
```

**你应该这样解释**：
```
根据 ADR-0005，Query Handler 不应该修改状态。

问题分析：
- Query 用于读取数据，不应该有副作用
- 修改状态会导致不可预测的行为

修复建议：
1. 移除 Query Handler 中的状态修改
2. 如果需要修改状态，使用 Command

示例修复：
// ❌ Query 修改状态
public async Task<OrderDto[]> Handle(GetOrders query)
{
    var orders = await _repository.GetAllAsync();
    
    // ❌ 不应该在 Query 中修改状态
    foreach (var order in orders)
    {
        order.MarkAsViewed();
    }
    
    await _repository.SaveChangesAsync();
    return orders.Select(o => o.ToDto()).ToArray();
}

// ✅ Query 只读取
public async Task<OrderDto[]> Handle(GetOrders query)
{
    var orders = await _repository.GetAllAsync();
    return orders.Select(o => o.ToDto()).ToArray();
}

// ✅ 修改状态使用 Command
await _bus.InvokeAsync(new MarkOrderAsViewed(orderId));
```

---

## 四、典型问答（FAQ）

### Q1: Command 和 Query 应该如何选择？

**A:**
使用以下决策树：

```
需求是否修改状态？
├─ 是 → 使用 Command
│   - CreateOrder
│   - UpdateOrder
│   - CancelOrder
│
└─ 否 → 使用 Query
    - GetOrderById
    - GetOrdersByMember
    - SearchOrders
```

**CQRS 原则**：
- Command：修改状态，返回 void 或 ID
- Query：读取数据，返回 DTO

---

### Q2: Handler 之间可以相互调用吗？

**A:**
**原则上不推荐**，但有例外：

**❌ 不允许**：
- Command Handler 调用其他 Command Handler
- 模块间 Handler 调用

**✅ 允许**（谨慎使用）：
- Command Handler 调用 Query（查询辅助数据）
- 同一模块内的 Helper 逻辑提取

**推荐做法**：
```csharp
// ✅ Command Handler 可以调用 Query
public class CreateOrderHandler
{
    public async Task Handle(CreateOrder command)
    {
        // ✅ 查询辅助数据
        var memberDto = await _queryBus.Send(new GetMemberById(command.MemberId));
        
        if (!memberDto.IsActive)
        {
            throw new InactiveMemberException();
        }
        
        var order = new Order(command.MemberId, command.Items);
        await _repository.SaveAsync(order);
    }
}
```

---

### Q3: 如何处理跨模块的一致性？

**A:**
**优先使用最终一致性**：

1. **异步事件**（推荐）：
   ```csharp
   // Orders 模块
   await _eventBus.Publish(new OrderCreated(orderId, memberId));
   
   // Members 模块订阅
   public async Task Handle(OrderCreated @event)
   {
       // 更新会员统计
   }
   ```

2. **Saga 模式**（复杂场景）：
   - 用于处理长时间运行的业务流程
   - 包含补偿逻辑

**❌ 不允许**：
- 分布式事务
- 模块间同步调用 Command

---

### Q4: Endpoint 应该返回什么？

**A:**
取决于操作类型：

**Command（修改操作）**：
```csharp
// ✅ 返回 201 Created + ID
app.MapPost("/orders", async (request, bus) =>
{
    var orderId = await bus.InvokeAsync(new CreateOrder(...));
    return Results.Created($"/orders/{orderId}", orderId);
});

// ✅ 返回 204 No Content
app.MapDelete("/orders/{id}", async (Guid id, bus) =>
{
    await bus.InvokeAsync(new DeleteOrder(id));
    return Results.NoContent();
});
```

**Query（查询操作）**：
```csharp
// ✅ 返回 200 OK + 数据
app.MapGet("/orders/{id}", async (Guid id, bus) =>
{
    var orderDto = await bus.InvokeAsync(new GetOrderById(id));
    return Results.Ok(orderDto);
});
```

---

## 五、快速检查清单

在提交 PR 前，请对照以下清单：

- [ ] 每个 Use Case 是否有明确的 Command/Query 和 Handler？
- [ ] Endpoint 是否只负责转发，不包含业务逻辑？
- [ ] Command Handler 是否只返回 void 或 ID？
- [ ] Query Handler 是否不修改状态？
- [ ] Command Handler 是否没有依赖 Contracts 进行业务决策？
- [ ] Handler 是否无状态（不维护长期状态）？
- [ ] 模块间通信是否使用异步事件？
- [ ] 架构测试是否全部通过？

---

## 六、CQRS 快速参考

| 类型 | 职责 | 允许 | 禁止 |
|------|------|------|------|
| **Command** | 修改状态 | 执行业务逻辑、保存数据、发布事件 | 返回业务数据、查询优化 |
| **Query** | 读取数据 | 查询数据、返回 DTO、性能优化 | 修改状态、执行业务逻辑 |
| **Handler** | 处理用例 | 加载聚合、执行业务、保存状态 | 维护长期状态、调用其他 Handler |
| **Endpoint** | HTTP 适配 | 接收请求、映射 Command/Query、返回响应 | 业务逻辑、直接访问数据库 |

---

## 七、测试覆盖自检清单

### 7.1 ADR-测试映射表

| ADR 约束 | 测试方法 | 测试内容 |
|---------|---------|---------|
| ADR-0005.1 | `Handlers_Should_Have_Clear_Naming_Convention` | Handler 应有明确的命名约定（CommandHandler/QueryHandler/EventHandler） |
| ADR-0005.2 | `Endpoints_Should_Not_Contain_Business_Logic` | Endpoint 不应包含业务逻辑，注入依赖应少于 5 个 |
| ADR-0005.3 | `Handlers_Should_Not_Depend_On_AspNet` | Handler 不应依赖 ASP.NET Core 类型 |
| ADR-0005.4 | `Handlers_Should_Be_Stateless` | Handler 应该是无状态的，不包含非 readonly 字段 |
| ADR-0005.5 | `Modules_Should_Not_Have_Synchronous_Cross_Module_Calls` | 模块间不应有未审批的同步调用 |
| ADR-0005.6 | `Async_Methods_Should_Follow_Naming_Convention` | 异步方法应以 Async 结尾（Handle 方法除外） |
| ADR-0005.7 | `Modules_Should_Not_Share_Domain_Entities` | 模块不应共享领域实体 |
| ADR-0005.8 | `QueryHandlers_Can_Return_Contracts` | Query Handler 可以返回 Contracts（正面测试） |
| ADR-0005.9 | `Command_And_Query_Handlers_Should_Be_Separated` | Command Handler 和 Query Handler 应明确分离 |
| ADR-0005.10 | `CommandHandlers_Should_Not_Return_Business_Data` | Command Handler 不应返回业务数据，只返回 void 或 ID |
| ADR-0005.11 | `Handlers_Should_Use_Structured_Exceptions` | Handler 应使用结构化异常 |
| ADR-0005.12 | `All_Handlers_Should_Be_In_Module_Assemblies` | 所有 Handler 应在模块程序集中 |

### 7.2 自检问题

在提交代码前，请确认：

**Use Case 组织**：
- [ ] 是否每个 Use Case 有明确的 Command 或 Query？
- [ ] 是否每个 Command/Query 有对应的 Handler？
- [ ] Handler 是否是该业务用例的唯一权威？

**Handler 实现**：
- [ ] Handler 命名是否包含 Command/Query/Event 标识？
- [ ] Handler 是否不依赖 ASP.NET Core 类型？
- [ ] Handler 所有字段是否都是 readonly？
- [ ] Handler 是否没有注入其他模块的类型？

**CQRS 分离**：
- [ ] Command Handler 是否只返回 void 或 ID？
- [ ] Query Handler 是否不修改状态？
- [ ] Command Handler 是否没有依赖 Contracts 进行业务决策？

**Endpoint 实现**：
- [ ] Endpoint 构造函数依赖是否少于 5 个？
- [ ] Endpoint 是否只负责：接收 → 映射 → 转发 → 返回？

**异步约定**：
- [ ] 异步方法（除 Handle）是否都以 Async 结尾？

### 7.3 如何编写符合映射要求的测试

#### 示例 1：验证 Handler 命名约定

```csharp
[Theory(DisplayName = "ADR-0005.1: Handler 应有明确的命名约定")]
[ClassData(typeof(ModuleAssemblyData))]
public void Handlers_Should_Have_Clear_Naming_Convention(Assembly moduleAssembly)
{
    var handlers = Types.InAssembly(moduleAssembly)
        .That().HaveNameEndingWith("Handler")
        .GetTypes();

    foreach (var handler in handlers)
    {
        var isCommandHandler = handler.Name.Contains("Command");
        var isQueryHandler = handler.Name.Contains("Query");
        var isEventHandler = handler.Name.Contains("Event");

        Assert.True(isCommandHandler || isQueryHandler || isEventHandler,
            $"❌ ADR-0005.1 违规: Handler 命名不清晰\n\n" +
            $"违规类型: {handler.FullName}\n\n" +
            $"问题分析:\n" +
            $"Handler 命名未明确表达业务意图（Command/Query/Event）\n\n" +
            $"修复建议:\n" +
            $"1. 将 Handler 重命名为 *CommandHandler（如 CreateOrderCommandHandler）\n" +
            $"2. 或重命名为 *QueryHandler（如 GetOrderByIdQueryHandler）\n" +
            $"3. 或重命名为 *EventHandler（如 OrderCreatedEventHandler）\n\n" +
            $"参考: docs/copilot/adr-0005.prompts.md（场景 1-3）");
    }
}
```

**关键点**：
- 测试名称包含 ADR 编号（ADR-0005.1）
- 失败消息包含清晰的违规类型和问题分析
- 提供具体的修复建议（编号列表，2-3 项）
- 引用相关文档章节

#### 示例 2：验证 Command Handler 不返回业务数据

```csharp
[Theory(DisplayName = "ADR-0005.10: Command Handler 不应返回业务数据")]
[ClassData(typeof(ModuleAssemblyData))]
public void CommandHandlers_Should_Not_Return_Business_Data(Assembly moduleAssembly)
{
    var commandHandlers = Types.InAssembly(moduleAssembly)
        .That().HaveNameEndingWith("CommandHandler")
        .GetTypes();

    foreach (var handler in commandHandlers)
    {
        var handleMethods = handler.GetMethods(BindingFlags.Public | BindingFlags.Instance)
            .Where(m => m.Name == "Handle")
            .ToList();

        foreach (var method in handleMethods)
        {
            var returnType = method.ReturnType;

            // 提取 Task<T> 中的 T
            if (returnType.IsGenericType && returnType.GetGenericTypeDefinition().Name.StartsWith("Task"))
            {
                returnType = returnType.GetGenericArguments().FirstOrDefault() ?? returnType;
            }

            // 允许的返回类型：void, Task, Unit, bool, int, Guid
            var allowedTypes = new[] { "Void", "Task", "Unit", "Boolean", "Int32", "Int64", "Guid" };

            if (!allowedTypes.Contains(returnType.Name))
            {
                if (returnType.Namespace?.StartsWith("Zss.BilliardHall") == true)
                {
                    Assert.Fail(
                        $"❌ ADR-0005.10 违规: Command Handler 返回业务数据\n\n" +
                        $"违规 Handler: {handler.FullName}.{method.Name}\n" +
                        $"返回类型: {returnType.FullName}\n\n" +
                        $"问题分析:\n" +
                        $"Command Handler 用于修改状态，不应返回业务数据\n\n" +
                        $"修复建议:\n" +
                        $"1. Command Handler 只返回 void 或 ID（Guid, int）\n" +
                        $"2. 如需查询数据，创建单独的 Query Handler\n" +
                        $"3. 先执行 Command，再通过 Query 获取数据\n\n" +
                        $"参考: docs/copilot/adr-0005.prompts.md（反模式 2, FAQ Q4）");
                }
            }
        }
    }
}
```

**关键点**：
- 通过反射检查方法返回类型
- 提取泛型类型参数（如 Task<T> 中的 T）
- 提供详细的违规信息和修复建议
- 关联到反模式和 FAQ 文档

### 7.4 验证脚本

运行以下命令验证所有 ADR-0005 测试：

```bash
# 运行所有 ADR-0005 测试
dotnet test --filter "FullyQualifiedName~ADR_0005"

# 运行特定约束测试
dotnet test --filter "DisplayName~ADR-0005.1"
dotnet test --filter "DisplayName~ADR-0005.10"

# 查看详细输出
dotnet test --filter "FullyQualifiedName~ADR_0005" --logger "console;verbosity=detailed"

# 检查 Handler 相关测试
dotnet test --filter "DisplayName~Handler"

# 检查 CQRS 相关测试
dotnet test --filter "DisplayName~Command" --filter "DisplayName~Query"
```

### 7.5 更新提示

当添加新的 ADR-0005 约束时：

1. **更新 ADR 文档**：在相应章节添加 **【必须架构测试覆盖】** 标记
2. **添加测试方法**：在 `ADR_0005_Architecture_Tests.cs` 中添加对应测试
3. **更新映射表**：
   - 在 ADR-0005 文档的"快速参考表"中添加新行
   - 在测试类头部注释的"ADR 映射清单"中添加新行
   - 在本文档的"ADR-测试映射表"中添加新行
4. **更新提示词库**：在相应场景或反模式中添加示例
5. **验证覆盖**：运行测试确保新约束被正确覆盖

---

## 八、相关资源

- [ADR-0005 完整文档](../adr/constitutional/ADR-0005-Application-Interaction-Model-Final.md)
- [架构测试类](../../src/tests/ArchitectureTests/ADR/ADR_0005_Architecture_Tests.cs)
- [ADR-0001 模块化单体](../adr/constitutional/ADR-0001-modular-monolith-vertical-slice-architecture.md)
- [CQRS 模式](https://martinfowler.com/bliki/CQRS.html)

---

## 九、版本历史

| 版本 | 日期       | 变更说明 |
|------|------------|----------|
| 1.1  | 2026-01-21 | 添加测试覆盖自检清单（七、测试覆盖自检清单） |
| 1.0  | 2026-01-21 | 初始版本 |
