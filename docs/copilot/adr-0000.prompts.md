# ADR-0000：架构测试与 CI 治理宪法 - Copilot 提示词库

**版本**：1.0  
**最后更新**：2026-01-23  
**对应 ADR**：[ADR-0000](../adr/governance/ADR-0000-architecture-tests.md)  

---

## 一、当我在写什么时，你应该提醒我哪些约束？

### 场景 1：开发者想要跳过或注释掉架构测试

**触发条件**：
- 开发者说"这个架构测试太严格了，我想跳过它"
- 开发者在测试上添加 `[Fact(Skip = "...")]`
- 开发者注释掉架构测试代码

**你应该提醒**：

```
❌ 禁止：跳过架构测试

根据 ADR-0000，架构测试失败 = 架构违规，不能跳过。

如果确实需要临时违反约束：
✅ 使用破例流程：
   1. 在 PR 标题添加 [ARCH-VIOLATION] 标签
   2. 填写破例说明（理由、影响、归还计划）
   3. 在 ARCH-VIOLATIONS.md 中记录
   4. 获得架构师批准
   5. 设定归还期限

如果认为约束本身有问题：
✅ 修订 ADR 流程：
   1. 创建 Issue 讨论约束的合理性
   2. 如果确认需要修改，走 ADR 修订流程
   3. 同步更新测试代码

参考：docs/adr/governance/ADR-0000-architecture-tests.md
```

### 场景 2：开发者创建新的 ADR

**触发条件**：
- 开发者创建新的 ADR 文档
- 开发者询问"ADR 需要测试吗"

**你应该提醒**：

```
✅ 必须创建架构测试

根据 ADR-0000，每个 ADR 都必须有对应的架构测试。

创建 ADR 时的完整清单：
1. ✅ ADR 文档（docs/adr/ADR-XXXX-xxx.md）
2. ✅ 架构测试（src/tests/ArchitectureTests/ADR/ADR_XXXX_Architecture_Tests.cs）
3. ✅ Copilot Prompts（docs/copilot/adr-XXXX.prompts.md）

架构测试要求：
- 测试类命名：ADR_XXXX_Architecture_Tests
- 测试方法必须包含 ADR 编号（方法名或 DisplayName）
- 失败消息格式：ADR-XXXX 违规：{原因}\n修复建议：{建议}
- 标记需要测试的约束：【必须架构测试覆盖】

参考：
- docs/ADR-TEST-MAPPING-SPECIFICATION.md
- docs/adr/governance/ADR-0000-architecture-tests.md
```

### 场景 3：架构测试失败

**触发条件**：
- CI 报告架构测试失败
- 本地运行测试失败
- 开发者询问"为什么架构测试失败"

**你应该提醒**：

```
⚠️ 架构测试失败 = 架构违规

根据 ADR-0000：
- 架构测试失败必须修复，CI 会阻断合并
- 不能跳过测试或修改测试让它通过

修复步骤：
1. 查看失败消息中的 ADR 编号
2. 阅读对应的 ADR 文档了解约束
3. 修改代码以符合架构约束
4. 如果确实需要违反约束，使用破例流程

常见架构测试：
- ADR-0001: 模块隔离、垂直切片
- ADR-0002: 层级依赖、Host 边界
- ADR-0003: 命名空间规则
- ADR-0004: 中央包管理
- ADR-0005: Handler 和 CQRS 模式

参考：docs/copilot/architecture-test-failures.md
```

### 场景 4：修订现有 ADR

**触发条件**：
- 开发者修改 ADR 文档
- 开发者添加/修改约束

**你应该提醒**：

```
⚠️ 修订 ADR 必须同步更新测试

根据 ADR-0000，ADR、测试、Prompts 必须保持一致。

修订 ADR 时的同步清单：
1. ✅ 更新 ADR 文档
2. ✅ 如果约束变更，更新架构测试
3. ✅ 更新 Copilot Prompts 文件
4. ✅ 运行映射校验脚本：./scripts/validate-adr-test-mapping.sh
5. ✅ 在版本历史中记录变更

特别注意：
- 新增约束 → 必须添加【必须架构测试覆盖】标记和测试
- 删除约束 → 同步删除对应的测试
- 修改约束 → 更新测试逻辑和失败消息

参考：docs/adr/governance/ADR-0900-adr-process.md
```

---

## 二、哪些写法必须阻止？

### ❌ 反模式 1：跳过架构测试

**错误示例**：
```csharp
[Fact(Skip = "这个测试太严格了")]
public void Modules_Should_Not_Reference_Other_Modules()
{
    // 测试代码
}
```

**为什么错误**：
- 违反 ADR-0000：禁止跳过架构测试
- 失去架构保护，可能导致系统退化
- 破坏 CI 的防护作用

**✅ 正确做法**：
```
如果确实需要违反约束：
1. 使用破例流程（[ARCH-VIOLATION] PR 标签）
2. 记录在 ARCH-VIOLATIONS.md
3. 设定归还期限
4. 获得架构师批准
```

---

### ❌ 反模式 2：修改测试让它通过

**错误示例**：
```csharp
// 开发者修改测试，添加例外让自己的代码通过
[Fact]
public void Modules_Should_Not_Reference_Other_Modules()
{
    var result = Types.InAssembly(moduleAssembly)
        .ShouldNot()
        .HaveDependencyOn($"Zss.BilliardHall.Modules.{other}")
        .GetResult();
    
    // ❌ 错误：添加例外让违规代码通过
    if (moduleName == "MyModule" && other == "OtherModule")
        return; // 我的特殊情况
    
    Assert.True(result.IsSuccessful, ...);
}
```

**为什么错误**：
- 破坏架构约束的完整性
- 制造了隐蔽的违规
- 可能导致其他人也效仿

**✅ 正确做法**：
```csharp
// 如果确实需要例外：
// 1. 在 ADR 文档中明确说明例外情况
// 2. 在测试中添加清晰的注释和 ADR 引用
// 3. 使用命名的白名单常量，不要硬编码
private static readonly HashSet<string> ApprovedCrossModuleReferences = new()
{
    // ADR-0001 批准的例外（Issue #123）
    // 原因：ModuleA 需要访问 ModuleB 的公共契约
    // 归还期限：2026-06-01
    "ModuleA->ModuleB"
};
```

---

### ❌ 反模式 3：创建 ADR 但不创建测试

**错误示例**：
```markdown
# ADR-0010：新的架构约束

## 决策
模块间通信必须设置超时...

## 实施
请大家自觉遵守...
```

**为什么错误**：
- 违反 ADR-0000：每个 ADR 都必须有测试
- 没有自动化验证，约束无法强制执行
- 容易被遗忘或忽视

**✅ 正确做法**：
```
1. 创建 ADR 文档
2. 同时创建架构测试
3. 同时创建 Copilot Prompts
4. 运行映射校验确保三者一致
```

---

### ❌ 反模式 4：测试失败消息不包含 ADR 编号

**错误示例**：
```csharp
[Fact]
public void Should_Not_Violate_Architecture()
{
    Assert.True(result.IsSuccessful, 
        "Architecture violation detected"); // ❌ 没有 ADR 编号
}
```

**为什么错误**：
- 测试失败时无法快速定位对应的 ADR
- 开发者不知道违反了哪条约束
- 难以追溯和修复

**✅ 正确做法**：
```csharp
[Fact(DisplayName = "ADR-0001.1: 模块不应相互引用")]
public void Modules_Should_Not_Reference_Other_Modules()
{
    Assert.True(result.IsSuccessful,
        $"❌ ADR-0001.1 违规: 模块 {moduleName} 不应依赖模块 {other}。\n" +
        $"违规类型: {string.Join(", ", violations)}。\n" +
        $"修复建议：使用领域事件或数据契约进行模块间通信。\n" +
        $"参考：docs/adr/constitutional/ADR-0001-modular-monolith-vertical-slice-architecture.md");
}
```

---

## 三、CI 失败时，你应该如何解释？

### 场景 1：架构测试失败

**CI 错误信息**：
```
Failed: ADR-0001.1: 模块不应相互引用
❌ ADR-0001.1 违规: 模块 Orders 不应依赖模块 Members。
违规类型: OrderService
修复建议：使用领域事件或数据契约进行模块间通信。
```

**人话解释**：
```
🔍 **问题诊断**

你的代码违反了模块隔离约束（ADR-0001）。

具体问题：
- Orders 模块中的 OrderService 直接引用了 Members 模块
- 这违反了模块隔离原则

📝 **修复方案**

方案 1：使用领域事件（推荐）
\`\`\`csharp
// 在 Orders 模块中发布事件
await _eventBus.Publish(new OrderCreated(orderId, memberId));
\`\`\`

方案 2：使用数据契约
\`\`\`csharp
// 查询 Members 模块的数据
var memberDto = await _queryBus.Send(new GetMemberById(memberId));
\`\`\`

方案 3：传递原始类型
\`\`\`csharp
// 只传递 ID，不传递对象
public void CreateOrder(Guid memberId) { ... }
\`\`\`

📚 **参考资料**
- ADR-0001: docs/adr/constitutional/ADR-0001-modular-monolith-vertical-slice-architecture.md
- 示例代码: docs/copilot/adr-0001.prompts.md
```

---

### 场景 2：映射校验失败

**CI 错误信息**：
```
❌ 验证失败：发现 ADR-测试映射不一致问题
ADR-0010 有 3 条必须测试的约束，但未发现任何测试方法
```

**人话解释**：
```
🔍 **问题诊断**

你创建/修改了 ADR-0010，但没有创建对应的架构测试。

根据 ADR-0000：
- 每个 ADR 都必须有对应的架构测试
- 标记为【必须架构测试覆盖】的约束必须有测试

📝 **修复步骤**

1. 创建测试文件：
   src/tests/ArchitectureTests/ADR/ADR_0010_Architecture_Tests.cs

2. 实现测试方法（至少 3 个，对应 3 条约束）

3. 确保测试方法：
   - 命名或 DisplayName 包含 ADR-0010
   - 失败消息包含 ADR 编号和修复建议

4. 运行映射校验：
   ./scripts/validate-adr-test-mapping.sh

📚 **参考资料**
- ADR-0000: docs/adr/governance/ADR-0000-architecture-tests.md
- 测试规范: docs/ADR-TEST-MAPPING-SPECIFICATION.md
```

---

## 四、典型问答（FAQ）

### Q1: 为什么架构测试这么严格？

**A:** 
架构测试是保护系统架构不退化的最后防线。

好处：
- ✅ 防止架构侵蚀（如模块耦合、层级混乱）
- ✅ 自动化执行，不依赖人工审查
- ✅ 快速反馈，在 CI 阶段就发现问题
- ✅ 新成员也能遵守架构约束

根据 ADR-0000，架构测试失败 = 架构违规，必须修复。

---

### Q2: 如果我确实需要违反架构约束怎么办？

**A:** 
使用破例流程，而不是跳过测试。

步骤：
1. 在 PR 标题添加 `[ARCH-VIOLATION]` 标签
2. 在 PR 描述中填写：
   - 违反的约束（ADR 编号）
   - 违反的原因
   - 影响评估
   - 归还计划（何时修复）
3. 在 ARCH-VIOLATIONS.md 中记录
4. 获得架构师批准
5. 设定归还期限

重要：
- 破例是临时的，不是永久的
- 连续破例三次未归还会触发架构审查
- 所有破例都会被追踪和审计

---

### Q3: ADR-测试映射是什么？为什么重要？

**A:** 
ADR-测试映射确保 ADR 文档和架构测试保持一致。

重要性：
- 防止"有 ADR 但没有测试"（约束形同虚设）
- 防止"有测试但没有 ADR"（不知道为什么测试）
- 确保三位一体（ADR + 测试 + Prompts）同步更新

验证方式：
```bash
# 运行映射校验脚本
./scripts/validate-adr-test-mapping.sh

# 检查：
# - 每个 ADR 是否有对应的测试文件
# - 每个测试方法是否包含 ADR 引用
# - 【必须架构测试覆盖】的约束是否都有测试
```

---

### Q4: 如何知道哪些约束需要测试？

**A:** 
查找 ADR 文档中标记为【必须架构测试覆盖】的条款。

标记方式：
```markdown
1. 内联标记
   - 模块不得相互引用。【必须架构测试覆盖】

2. 段落标记
   **必须测试**：此约束必须通过架构测试验证。

3. 快速参考表
   | 约束 | 测试覆盖 |
   |------|---------|
   | 模块隔离 | ✅ ADR_0001_Tests::Modules_Should_Not_Reference |
```

提示：
- 使用映射校验脚本自动检查
- 参考现有 ADR 的格式
- 在测试类头部添加映射清单注释

---

### Q5: 执行分级（Enforcement Level）是什么意思？

**A:** 
不是所有约束都能完全自动化测试，执行分级反映了自动化程度。

三个级别：

| 级别 | 说明 | 示例 |
|------|------|------|
| **L1 静态** | 完全自动化，CI 强制执行 | 模块依赖、命名空间规则 |
| **L2 语义** | 半自动化，需要人工确认 | 业务逻辑位置、命名约定 |
| **L3 人工** | 无法自动化，依赖 Code Review | 代码可读性、架构意图 |

所有级别的约束都是必须遵守的，只是验证方式不同。

参考：docs/adr/constitutional/ADR-0005-Enforcement-Levels.md

---

## 五、快速检查清单

### PR 提交前的架构合规检查

```markdown
## 架构合规性检查清单

### 代码变更
- [ ] 本地运行所有架构测试通过
- [ ] 没有跳过任何架构测试
- [ ] 没有为了通过测试而修改测试逻辑

### ADR 变更（如有）
- [ ] ADR 文档已更新
- [ ] 架构测试已同步更新
- [ ] Copilot Prompts 已同步更新
- [ ] 运行映射校验脚本通过

### 破例（如有）
- [ ] PR 标题包含 [ARCH-VIOLATION]
- [ ] PR 描述包含破例说明
- [ ] ARCH-VIOLATIONS.md 已更新
- [ ] 设定了归还期限
- [ ] 获得架构师批准

### CI
- [ ] 所有架构测试通过
- [ ] 映射校验通过
- [ ] 没有架构测试失败
```

---

## 六、测试覆盖自检清单

在审查与 ADR-0000 相关的 PR 时，请检查以下映射关系：

### 映射清单

| ADR 约束 | 测试方法 | 状态 |
|---------|---------|------|
| ADR-0000: 每条 ADR 必须有唯一测试类 | `Each_ADR_Must_Have_Exact_And_Unique_Architecture_Test` | ✅ 已覆盖 |
| ADR-0000: 测试类必须包含最少断言数 | `Architecture_Test_Classes_Must_Have_Minimum_Assertions` | ✅ 已覆盖 |
| ADR-0000: 测试失败消息必须包含 ADR 编号 | `Test_Failure_Messages_Must_Contain_ADR_Reference` | ✅ 已覆盖 |
| ADR-0000: 禁止跳过架构测试 | `Architecture_Tests_Should_Not_Be_Skipped` | ✅ 已覆盖 |

### 自检问题

当审查代码变更时，询问自己：

1. ✅ 如果有 ADR 变更，测试是否同步更新？
2. ✅ 如果有测试变更，ADR 和 Prompts 是否同步更新？
3. ✅ 测试失败消息是否清晰指明违反了哪条约束？
4. ✅ 是否有跳过的架构测试？如果有，是否使用了破例流程？
5. ✅ 映射校验脚本是否通过？

---

## 七、如何编写符合映射要求的测试

### 示例 1：验证 ADR-测试一对一映射

```csharp
/// <summary>
/// ADR-0000: 架构测试与 CI 治理宪法
/// 验证每条 ADR 都有唯一对应的架构测试类
/// </summary>
[Fact(DisplayName = "ADR-0000: 每条 ADR 必须有且仅有唯一对应的架构测试类")]
public void Each_ADR_Must_Have_Exact_And_Unique_Architecture_Test()
{
    var adrFiles = GetAllAdrFiles();
    var testTypes = GetAllArchitectureTestTypes();
    
    foreach (var adrFile in adrFiles)
    {
        var adrNumber = ExtractAdrNumber(adrFile);
        var expectedTestType = $"ADR_{adrNumber}_Architecture_Tests";
        
        var matchingTests = testTypes
            .Where(t => t.Name == expectedTestType)
            .ToList();
        
        Assert.Single(matchingTests,
            $"❌ ADR-0000 违规: {adrFile} 必须有且仅有一个对应的测试类 {expectedTestType}。\n" +
            $"实际找到 {matchingTests.Count} 个。\n" +
            $"修复建议：创建或修正测试类命名。\n" +
            $"参考：docs/adr/governance/ADR-0000-architecture-tests.md");
    }
}
```

**要点说明**：
- ✅ DisplayName 明确标注 ADR-0000
- ✅ 失败消息包含 ADR 编号、具体违规、修复建议、参考文档
- ✅ 验证了 ADR 文档和测试的一对一映射关系

### 示例 2：反作弊检查

```csharp
[Fact(DisplayName = "ADR-0000: 禁止跳过架构测试（反作弊）")]
public void Architecture_Tests_Should_Not_Be_Skipped()
{
    var testTypes = GetAllArchitectureTestTypes();
    var skippedTests = new List<string>();
    
    foreach (var testType in testTypes)
    {
        var methods = testType.GetMethods(BindingFlags.Public | BindingFlags.Instance);
        
        foreach (var method in methods)
        {
            var factAttr = method.GetCustomAttribute<FactAttribute>();
            var theoryAttr = method.GetCustomAttribute<TheoryAttribute>();
            
            if ((factAttr?.Skip != null && !string.IsNullOrEmpty(factAttr.Skip)) ||
                (theoryAttr?.Skip != null && !string.IsNullOrEmpty(theoryAttr.Skip)))
            {
                skippedTests.Add($"{testType.Name}.{method.Name}");
            }
        }
    }
    
    Assert.Empty(skippedTests,
        $"❌ ADR-0000 违规：以下架构测试被跳过：\n" +
        $"{string.Join("\n", skippedTests.Select(t => $"  • {t}"))}\n\n" +
        $"修复建议：\n" +
        $"  1. 如果代码违反约束，修改代码而不是跳过测试\n" +
        $"  2. 如果确需违反约束，使用破例流程（[ARCH-VIOLATION] PR 标签）\n" +
        $"  3. 在 ARCH-VIOLATIONS.md 中记录破例并设定归还期限\n\n" +
        $"参考：docs/adr/governance/ADR-0000-architecture-tests.md");
}
```

---

## 版本历史

| 版本 | 日期 | 变更说明 |
|------|------|---------|
| 1.0 | 2026-01-23 | 初始版本，基于 ADR-0000 v2.0 创建 |
