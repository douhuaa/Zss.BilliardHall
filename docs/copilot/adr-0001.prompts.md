# ADR-0001：模块化单体与垂直切片架构 - Copilot 提示词库

**关联 ADR**：[ADR-0001](../adr/constitutional/ADR-0001-modular-monolith-vertical-slice-architecture.md)  
**测试类**：`ADR_0001_Architecture_Tests.cs`  
**版本**：1.0  
**最后更新**：2026-01-21

---

## 一、当我在写什么时，你应该提醒我哪些 ADR-0001 约束？

### 场景 1：创建新模块

**触发条件**：
- 在 `src/Modules/` 下创建新目录
- 添加新的业务模块程序集

**你应该提醒的约束**：
```
✅ 检查清单：
1. 模块是否按业务能力划分？（如 Members、Orders、Payments）
2. 模块是否有独立的程序集边界？
3. 模块是否只暴露受控的集成点？
4. 模块内部是否采用垂直切片组织？

❌ 禁止：
- 创建"Common"、"Shared"、"Utils"等横向模块
- 模块命名不反映业务能力
- 模块对外暴露内部实现
```

---

### 场景 2：实现新的业务用例

**触发条件**：
- 添加新的 Use Case 文件夹
- 创建 Command/Query 和 Handler

**你应该提醒的约束**：
```
✅ 检查清单：
1. Use Case 是否包含完整的垂直切片？
   - Endpoint/API
   - Command/Query
   - Handler
   - 业务规则与校验
   - 持久化逻辑
2. 业务逻辑是否在 Handler 中，而非抽象为 Service？

❌ 禁止：
- 创建横向 Service 层（如 OrderService）
- 在 Endpoint 中编写业务逻辑
- 多个 Use Case 共享 Service
```

---

### 场景 3：模块间通信

**触发条件**：
- 在一个模块中引用另一个模块
- 在 Handler 中调用其他模块的代码
- 需要跨模块传递数据

**你应该提醒的约束**：
```
✅ 仅允许三种模块间通信方式：

1. **领域事件（Domain Events）**
   - 异步通信
   - 发布者不知道订阅者
   - 示例：OrderCreated、MemberRegistered

2. **数据契约（Contracts）**
   - 只读的 DTO
   - 不包含业务行为
   - 示例：MemberDto、OrderSummaryDto

3. **原始类型**
   - 标准库类型：int、string、Guid
   - 示例：MemberId（as Guid）、OrderNumber（as string）

❌ 绝对禁止：
- 直接引用其他模块的 Entity/Aggregate/ValueObject
- 共享领域模型
- 通过 Service 层跨模块调用
- 使用 Contracts 驱动业务决策（Command Handler 依赖 Contracts）
```

---

### 场景 4：添加共享代码

**触发条件**：
- 创建 BuildingBlocks 或共享类库
- 多个模块需要使用相同的代码

**你应该提醒的约束**：
```
✅ 检查清单：
1. 共享代码是否是**技术性的**，而非业务性的？
2. 是否放在 BuildingBlocks 或 Platform 中？
3. 是否只包含通用抽象，不包含业务规则？

❌ 禁止：
- 在 BuildingBlocks 中放置业务规则
- 创建"Shared Domain Model"
- Platform 层包含业务判断逻辑
```

---

## 二、哪些写法必须阻止？

### 反模式 1：跨模块直接引用内部实现

**❌ 错误示例**：
```csharp
// 在 Orders 模块中
using Zss.BilliardHall.Modules.Members.Domain;

public class CreateOrderHandler
{
    public async Task Handle(CreateOrder command)
    {
        var member = await _memberRepository.GetByIdAsync(command.MemberId);
        // ❌ 直接使用其他模块的 Entity
    }
}
```

**✅ 正确做法**：
```csharp
// 通过原始类型传递标识
public class CreateOrderHandler
{
    public async Task Handle(CreateOrder command)
    {
        var memberId = command.MemberId; // Guid
        // ✅ 只传递标识，不访问内部实现
    }
}

// 或通过契约查询数据
public class CreateOrderHandler
{
    public async Task Handle(CreateOrder command)
    {
        var memberDto = await _queryBus.Send(new GetMemberById(command.MemberId));
        // ✅ 通过契约（DTO）获取数据
    }
}
```

---

### 反模式 2：创建横向 Service 层

**❌ 错误示例**：
```csharp
// ❌ 不要创建横向 Service
public class OrderService
{
    public async Task CreateOrder(CreateOrderRequest request) { }
    public async Task CancelOrder(Guid orderId) { }
    public async Task UpdateOrder(UpdateOrderRequest request) { }
}

// ❌ 不要在多个 Use Case 中共享 Service
public class CreateOrderHandler
{
    private readonly OrderService _orderService;
    
    public async Task Handle(CreateOrder command)
    {
        await _orderService.CreateOrder(...);
    }
}
```

**✅ 正确做法**：
```csharp
// ✅ 每个 Use Case 有独立的 Handler
public class CreateOrderHandler
{
    public async Task Handle(CreateOrder command)
    {
        // 业务逻辑直接在 Handler 中
        var order = new Order(command.MemberId, command.Items);
        await _repository.SaveAsync(order);
    }
}

public class CancelOrderHandler
{
    public async Task Handle(CancelOrder command)
    {
        // 独立的业务逻辑
        var order = await _repository.GetByIdAsync(command.OrderId);
        order.Cancel();
        await _repository.SaveAsync(order);
    }
}
```

---

### 反模式 3：Command Handler 依赖 Contracts

**❌ 错误示例**：
```csharp
// ❌ Command Handler 不应该依赖 Contracts 进行业务决策
public class RechargeBalanceHandler
{
    public async Task Handle(RechargeBalance command)
    {
        var memberDto = await _queryBus.Send(new GetMemberById(command.MemberId));
        if (memberDto.Balance + command.Amount > 10000)
        {
            // ❌ 基于 DTO 的数据进行业务判断
            throw new InvalidOperationException("余额超限");
        }
    }
}
```

**✅ 正确做法**：
```csharp
// ✅ Command Handler 应该操作领域模型
public class RechargeBalanceHandler
{
    public async Task Handle(RechargeBalance command)
    {
        var member = await _repository.GetByIdAsync(command.MemberId);
        member.Recharge(command.Amount); // ✅ 业务逻辑在领域模型中
        await _repository.SaveAsync(member);
    }
}
```

---

### 反模式 4：Platform 层包含业务规则

**❌ 错误示例**：
```csharp
// ❌ Platform 层不应该包含业务判断
public class PaymentValidator
{
    public bool ValidatePaymentAmount(decimal amount)
    {
        return amount > 0 && amount < 10000; // ❌ 业务规则
    }
}
```

**✅ 正确做法**：
```csharp
// ✅ 业务规则放在模块内
// 在 Payments 模块中
public class Payment
{
    public void ValidateAmount(decimal amount)
    {
        if (amount <= 0 || amount > 10000)
        {
            throw new InvalidPaymentAmountException();
        }
    }
}
```

---

## 三、CI 失败时，你应该如何解释？

### 失败消息：模块间非法依赖

**CI 输出示例**：
```
❌ Test Failed: Modules_Should_Not_Reference_Other_Modules
   Expected: No references from 'Orders' to 'Members'
   Actual: Found reference to 'Zss.BilliardHall.Modules.Members.Domain'
```

**你应该这样解释**：
```
根据 ADR-0001，模块之间不允许直接引用内部实现。

问题分析：
- Orders 模块引用了 Members 模块的 Domain 层
- 这违反了模块隔离原则

修复建议：
1. 移除对 Members.Domain 的引用
2. 如果需要传递 MemberId，使用原始类型（Guid）
3. 如果需要查询 Member 数据，通过 Contracts（DTO）
4. 如果需要通知 Member，发布领域事件

示例修复：
- 原始类型：command.MemberId（Guid）
- 契约查询：await _queryBus.Send(new GetMemberById(memberId))
- 领域事件：await _eventBus.Publish(new OrderCreated(orderId, memberId))
```

---

### 失败消息：发现横向 Service 层

**CI 输出示例**：
```
❌ Test Failed: Modules_Should_Not_Have_Service_Layer
   Expected: No types ending with 'Service'
   Actual: Found 'OrderService' in Orders module
```

**你应该这样解释**：
```
根据 ADR-0001，模块内不允许创建横向 Service 层。

问题分析：
- 发现 OrderService，这违反了垂直切片架构
- 业务逻辑应该在 Handler 中，而非抽象为 Service

修复建议：
1. 删除 OrderService
2. 将业务逻辑分散到各个 Use Case 的 Handler 中
3. 如果有共享逻辑，考虑：
   - 放入领域模型（Entity/ValueObject）
   - 创建 BuildingBlocks 中的技术抽象（非业务）

示例重构：
OrderService.CreateOrder() 
  → CreateOrderHandler.Handle()
OrderService.CancelOrder() 
  → CancelOrderHandler.Handle()
```

---

### 失败消息：Platform 层包含业务逻辑

**CI 输出示例**：
```
❌ Test Failed: Platform_Should_Not_Contain_Business_Logic
   Expected: No business-related types in Platform
   Actual: Found 'PaymentValidator' with business rules
```

**你应该这样解释**：
```
根据 ADR-0001，Platform 层不应该包含业务规则或判断。

问题分析：
- PaymentValidator 包含业务金额判断
- Platform 层应该只提供技术能力，不感知业务

修复建议：
1. 将 PaymentValidator 移到 Payments 模块
2. Platform 层只保留技术性验证（如格式、非空）
3. 业务规则在领域模型或 Handler 中实现

示例修复：
Platform：只验证技术规则（非空、格式）
Module：验证业务规则（金额限制、状态判断）
```

---

## 四、典型问答（FAQ）

### Q1: 我想在 Orders 模块中获取 Member 的详细信息，怎么做？

**A:** 
根据 ADR-0001，有两种合规方式：

1. **通过 Contracts 查询**（推荐用于查询场景）：
   ```csharp
   var memberDto = await _queryBus.Send(new GetMemberById(memberId));
   // 使用 memberDto.Name、memberDto.Email 等
   ```

2. **通过原始类型传递标识**（推荐用于命令场景）：
   ```csharp
   var orderId = command.MemberId; // 只传递 Guid
   // 不需要访问 Member 的详细信息
   ```

❌ **不允许**：
```csharp
// ❌ 直接引用 Members 模块的 Entity
using Zss.BilliardHall.Modules.Members.Domain;
var member = await _memberRepository.GetByIdAsync(memberId);
```

---

### Q2: 我有一段逻辑需要在多个 Use Case 中共享，应该怎么做？

**A:**
取决于逻辑的性质：

1. **业务规则** → 放入领域模型（Entity/ValueObject）
   ```csharp
   public class Order
   {
       public void ApplyDiscount(decimal percentage)
       {
           // 共享的业务规则
       }
   }
   ```

2. **技术抽象** → 放入 BuildingBlocks
   ```csharp
   // BuildingBlocks.Domain
   public interface IRepository<T> { }
   ```

3. **模块间共享** → 考虑是否应该共享
   - 如果是业务规则，**不应该跨模块共享**
   - 如果是数据查询，通过 Contracts

❌ **不允许**：
```csharp
// ❌ 创建横向 Service
public class SharedOrderService { }
```

---

### Q3: 什么时候应该发布领域事件？

**A:**
当满足以下条件时，应该发布领域事件：

1. **模块需要通知其他模块**
2. **通知是异步的**（不需要立即响应）
3. **不涉及跨模块的一致性保障**

示例：
```csharp
// Orders 模块
public class CreateOrderHandler
{
    public async Task Handle(CreateOrder command)
    {
        var order = new Order(command.MemberId, command.Items);
        await _repository.SaveAsync(order);
        
        // ✅ 发布事件通知其他模块
        await _eventBus.Publish(new OrderCreated(order.Id, order.MemberId));
    }
}

// Members 模块订阅事件
public class OrderCreatedHandler
{
    public async Task Handle(OrderCreated @event)
    {
        // 更新会员的订单统计
    }
}
```

---

## 五、快速检查清单

在提交 PR 前，请对照以下清单：

- [ ] 模块是否按业务能力划分？
- [ ] 模块内部是否采用垂直切片组织？
- [ ] 是否避免了跨模块直接引用内部实现？
- [ ] 是否避免了创建横向 Service 层？
- [ ] Command Handler 是否避免依赖 Contracts 进行业务决策？
- [ ] Platform 层是否避免包含业务规则？
- [ ] 模块间通信是否只使用三种合规方式？
- [ ] 架构测试是否全部通过？

---

## 六、相关资源

- [ADR-0001 完整文档](../adr/constitutional/ADR-0001-modular-monolith-vertical-slice-architecture.md)
- [架构测试类](../../src/tests/ArchitectureTests/ADR/ADR_0001_Architecture_Tests.cs)
- [ADR-0005 应用内交互模型](../adr/constitutional/ADR-0005-Application-Interaction-Model-Final.md)
- [垂直切片架构参考](https://www.jimmybogard.com/vertical-slice-architecture/)

---

## 版本历史

| 版本 | 日期       | 变更说明 |
|------|------------|----------|
| 1.0  | 2026-01-21 | 初始版本 |
