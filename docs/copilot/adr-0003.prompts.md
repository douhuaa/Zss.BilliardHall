# ADR-0003：命名空间与项目边界规范 - Copilot 提示词库

**关联 ADR**：[ADR-0003](../adr/constitutional/ADR-0003-namespace-rules.md)  
**测试类**：`ADR_0003_Architecture_Tests.cs`  
**版本**：1.1  
**最后更新**：2026-01-21

---

## 一、当我在写什么时，你应该提醒我哪些 ADR-0003 约束？

### 场景 1：创建新项目

**触发条件**：
- 添加新的 .csproj 文件
- 在 src/ 下创建新目录

**你应该提醒的约束**：
```
✅ 检查清单：
1. 项目名称是否等于目录最后一级名称？
2. 是否遵循目录结构规范？
   - Platform/XXX
   - Application/XXX
   - Modules/XXX
   - Host/XXX
   - Tests/XXX
3. 是否没有手动设置 RootNamespace？
4. 是否依赖 Directory.Build.props 自动推导命名空间？

❌ 禁止：
- 项目名与目录名不一致
- 手动覆盖 BaseNamespace
- 在项目文件中设置 RootNamespace
- 使用 Common、Shared、Utils 等不规范名称
```

**标准项目文件模板**：
```xml
<!-- src/Modules/Orders/Orders.csproj -->
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <!-- ✅ 不要手动设置 RootNamespace -->
    <!-- ✅ 让 Directory.Build.props 自动推导 -->
  </PropertyGroup>
</Project>

<!-- 自动推导结果：Zss.BilliardHall.Modules.Orders -->
```

---

### 场景 2：编写代码时的命名空间

**触发条件**：
- 创建新的 C# 文件
- 需要声明命名空间

**你应该提醒的约束**：
```
✅ 命名空间规则：
1. 命名空间必须与目录结构一致
2. BaseNamespace 固定为 Zss.BilliardHall
3. 命名空间格式：BaseNamespace + 相对路径

示例：
文件路径：src/Modules/Orders/Domain/Order.cs
命名空间：Zss.BilliardHall.Modules.Orders.Domain

❌ 禁止：
- 命名空间与目录结构不一致
- 硬编码 Zss.BilliardHall
- 使用 Common、Shared、Utils
```

**标准命名空间模板**：
```csharp
// src/Modules/Orders/Domain/Order.cs
namespace Zss.BilliardHall.Modules.Orders.Domain;

public class Order { }

// ✅ 命名空间 = BaseNamespace + Modules.Orders.Domain
// ✅ 与目录结构完全一致
```

---

### 场景 3：引用其他项目

**触发条件**：
- 添加 ProjectReference
- 需要跨项目引用类型

**你应该提醒的约束**：
```
✅ 引用规则检查：
1. 是否遵循层级依赖规则？
   - Platform → 不依赖其他层
   - Application → 只依赖 Platform
   - Modules → 只依赖 Platform、BuildingBlocks
   - Host → 只依赖 Application、Platform
2. 命名空间引用是否正确？

❌ 禁止：
- 越界依赖（如 Platform 依赖 Modules）
- 模块间直接引用（Modules 间）
- 使用不存在的命名空间
```

---

### 场景 4：重命名项目或目录

**触发条件**：
- 重构项目结构
- 重命名目录或项目

**你应该提醒的约束**：
```
⚠️ 重命名影响：
1. 项目名必须与目录名同步更新
2. 命名空间会自动更新（由 Directory.Build.props 推导）
3. 所有引用该项目的地方需要更新

步骤：
1. 重命名目录
2. 重命名 .csproj 文件
3. 更新所有 ProjectReference
4. 运行架构测试验证

❌ 不要：
- 只改目录名不改项目名
- 只改项目名不改目录名
- 手动设置 RootNamespace "修复"不一致
```

---

## 二、哪些写法必须阻止？

### 反模式 1：手动覆盖 BaseNamespace

**❌ 错误示例**：
```xml
<!-- ❌ 不要在项目文件中设置 BaseNamespace -->
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <BaseNamespace>MyApp.Orders</BaseNamespace>
  </PropertyGroup>
</Project>
```

**✅ 正确做法**：
```xml
<!-- ✅ 依赖 Directory.Build.props 自动推导 -->
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net9.0</TargetFramework>
    <!-- 不设置任何命名空间属性 -->
  </PropertyGroup>
</Project>
```

---

### 反模式 2：命名空间与目录结构不一致

**❌ 错误示例**：
```csharp
// 文件路径：src/Modules/Orders/Domain/Order.cs
// ❌ 命名空间不匹配目录结构
namespace Zss.BilliardHall.Orders;

public class Order { }
```

**✅ 正确做法**：
```csharp
// 文件路径：src/Modules/Orders/Domain/Order.cs
// ✅ 命名空间与目录结构完全一致
namespace Zss.BilliardHall.Modules.Orders.Domain;

public class Order { }
```

---

### 反模式 3：使用不规范的命名

**❌ 错误示例**：
```
// ❌ 不规范的目录命名
src/
  Common/           ← 不允许
  Shared/           ← 不允许
  Utils/            ← 不允许
  Helpers/          ← 不允许
```

**✅ 正确做法**：
```
// ✅ 规范的目录命名
src/
  Platform/         ← 技术基座
  Application/      ← 应用层
  Modules/          ← 业务模块
    Orders/
    Members/
  BuildingBlocks/   ← 技术抽象
```

---

### 反模式 4：项目名与目录名不一致

**❌ 错误示例**：
```
// 目录：src/Modules/OrderManagement/
// 项目：Orders.csproj  ← ❌ 不一致
```

**✅ 正确做法**：
```
// 目录：src/Modules/Orders/
// 项目：Orders.csproj  ← ✅ 一致
```

---

## 三、CI 失败时，你应该如何解释？

### 失败消息：命名空间与目录不一致

**CI 输出示例**：
```
❌ Test Failed: Namespace_Should_Match_Directory_Structure
   Expected: Zss.BilliardHall.Modules.Orders.Domain
   Actual: Zss.BilliardHall.Orders
```

**你应该这样解释**：
```
根据 ADR-0003，命名空间必须与目录结构完全一致。

问题分析：
- 文件位于：src/Modules/Orders/Domain/Order.cs
- 期望命名空间：Zss.BilliardHall.Modules.Orders.Domain
- 实际命名空间：Zss.BilliardHall.Orders

修复建议：
1. 更新文件的命名空间声明
2. 确保命名空间 = BaseNamespace + 相对路径

修复示例：
// ❌ 错误
namespace Zss.BilliardHall.Orders;

// ✅ 正确
namespace Zss.BilliardHall.Modules.Orders.Domain;
```

---

### 失败消息：项目名与目录名不一致

**CI 输出示例**：
```
❌ Test Failed: Project_Name_Should_Match_Directory_Name
   Expected: Orders.csproj
   Actual: OrderManagement.csproj
   Directory: src/Modules/Orders/
```

**你应该这样解释**：
```
根据 ADR-0003，项目名必须与目录最后一级名称完全一致。

问题分析：
- 目录名：Orders
- 项目名：OrderManagement
- 两者不一致

修复建议：
1. 将项目文件重命名为 Orders.csproj
2. 更新所有 ProjectReference 引用
3. 运行架构测试验证

或者：
1. 将目录重命名为 OrderManagement
2. 同步更新命名空间
3. 运行架构测试验证

推荐使用第一种方案（重命名项目），因为目录名通常更符合业务语义。
```

---

### 失败消息：手动覆盖了 BaseNamespace

**CI 输出示例**：
```
❌ Test Failed: Should_Not_Override_BaseNamespace
   Expected: No BaseNamespace override
   Actual: Found BaseNamespace in Orders.csproj
```

**你应该这样解释**：
```
根据 ADR-0003，不允许在项目文件中手动设置 BaseNamespace。

问题分析：
- 项目文件中发现 <BaseNamespace> 设置
- 这会破坏自动推导机制

修复建议：
1. 删除项目文件中的 <BaseNamespace> 设置
2. 依赖 Directory.Build.props 自动推导
3. 如果命名空间不正确，检查目录结构是否符合规范

正确的推导规则：
- BaseNamespace: Zss.BilliardHall (统一定义)
- RootNamespace: BaseNamespace + 相对路径
- 示例：src/Modules/Orders/ → Zss.BilliardHall.Modules.Orders
```

---

### 失败消息：使用了不规范的命名

**CI 输出示例**：
```
❌ Test Failed: Should_Not_Use_Irregular_Names
   Expected: No Common/Shared/Utils directories
   Actual: Found 'src/Common/'
```

**你应该这样解释**：
```
根据 ADR-0003，不允许使用 Common、Shared、Utils 等不规范命名。

问题分析：
- 发现 src/Common/ 目录
- 这类命名通常导致代码组织混乱

修复建议：
1. 评估 Common 中的代码性质：
   - 技术性抽象 → 移到 Platform 或 BuildingBlocks
   - 业务性代码 → 移到具体的 Module
   - 跨模块共享 → 考虑是否违反了模块隔离原则

2. 删除 Common 目录

3. 更新所有引用

规范的组织方式：
✅ Platform/       ← 技术基座
✅ BuildingBlocks/ ← 技术抽象
✅ Modules/        ← 业务模块
❌ Common/         ← 不允许
❌ Shared/         ← 不允许
❌ Utils/          ← 不允许
```

---

## 四、典型问答（FAQ）

### Q1: 我想创建一个新的业务模块，应该如何组织目录和命名空间？

**A:**
遵循以下步骤：

1. **创建目录结构**：
   ```
   src/
     Modules/
       MyNewModule/        ← 模块名（业务能力）
         Domain/           ← 领域模型
         UseCases/         ← 用例
         Contracts/        ← 对外契约
         MyNewModule.csproj
   ```

2. **创建项目文件**（不设置任何命名空间属性）：
   ```xml
   <Project Sdk="Microsoft.NET.Sdk">
     <PropertyGroup>
       <TargetFramework>net9.0</TargetFramework>
     </PropertyGroup>
   </Project>
   ```

3. **编写代码时的命名空间**：
   ```csharp
   // src/Modules/MyNewModule/Domain/MyEntity.cs
   namespace Zss.BilliardHall.Modules.MyNewModule.Domain;
   
   public class MyEntity { }
   ```

4. **验证**：
   ```bash
   dotnet test src/tests/ArchitectureTests/
   ```

---

### Q2: 我的命名空间自动推导不正确，应该怎么办？

**A:**
检查以下几点：

1. **确认 Directory.Build.props 存在且正确**：
   ```xml
   <PropertyGroup>
     <BaseNamespace>Zss.BilliardHall</BaseNamespace>
   </PropertyGroup>
   ```

2. **确认目录结构符合规范**：
   - Platform/XXX
   - Application/XXX
   - Modules/XXX
   - Host/XXX

3. **确认项目名与目录名一致**：
   - 目录：src/Modules/Orders/
   - 项目：Orders.csproj

4. **删除项目文件中的手动设置**：
   ```xml
   <!-- ❌ 删除这些 -->
   <RootNamespace>...</RootNamespace>
   <BaseNamespace>...</BaseNamespace>
   ```

5. **重新构建并验证**：
   ```bash
   dotnet clean
   dotnet build
   ```

---

### Q3: 我可以在子目录中再创建子项目吗？

**A:**
可以，但要遵循规则：

**✅ 允许的结构**：
```
src/
  Modules/
    Orders/
      Orders.csproj              ← Zss.BilliardHall.Modules.Orders
      Infrastructure/
        Infrastructure.csproj    ← Zss.BilliardHall.Modules.Orders.Infrastructure
```

**命名空间自动推导**：
- Orders.csproj → Zss.BilliardHall.Modules.Orders
- Infrastructure.csproj → Zss.BilliardHall.Modules.Orders.Infrastructure

**注意**：
- 项目名必须与目录名一致
- 命名空间会自动包含完整路径

---

### Q4: 为什么不允许使用 Common、Shared 等命名？

**A:**
因为这类命名通常导致：

1. **职责不清**：
   - Common 是什么？技术？业务？
   - 所有人都往里扔代码

2. **依赖混乱**：
   - 所有项目都依赖 Common
   - 形成循环依赖

3. **架构腐化**：
   - 模块隔离被打破
   - 无法清晰划分边界

**正确做法**：
- 技术性代码 → Platform 或 BuildingBlocks
- 业务性代码 → 归属到具体的 Module
- 跨模块共享 → 通过 Contracts 或事件

---

## 五、快速检查清单

在提交 PR 前，请对照以下清单：

- [ ] 项目名是否等于目录最后一级名称？
- [ ] 命名空间是否与目录结构一致？
- [ ] 是否没有手动设置 BaseNamespace 或 RootNamespace？
- [ ] 是否没有使用 Common、Shared、Utils 等不规范命名？
- [ ] 目录结构是否符合规范（Platform/Application/Modules/Host/Tests）？
- [ ] 架构测试是否全部通过？

---

## 六、命名空间推导规则快速参考

| 目录路径 | 项目名 | 自动推导的命名空间 |
|---------|--------|-------------------|
| src/Platform/Logging/ | Logging.csproj | Zss.BilliardHall.Platform.Logging |
| src/Application/ | Application.csproj | Zss.BilliardHall.Application |
| src/Modules/Orders/ | Orders.csproj | Zss.BilliardHall.Modules.Orders |
| src/Host/Web/ | Web.csproj | Zss.BilliardHall.Host.Web |
| src/Tests/ArchitectureTests/ | ArchitectureTests.csproj | Zss.BilliardHall.Tests.ArchitectureTests |

---

## 六、测试覆盖自检清单

### 6.1 ADR-测试映射表

| ADR 约束 | 测试方法 | 测试内容 |
|---------|---------|---------|
| ADR-0003.1 | `All_Types_Should_Start_With_Base_Namespace` | 所有类型应以 BaseNamespace 开头 |
| ADR-0003.2 | `Platform_Types_Should_Have_Platform_Namespace` | Platform 类型应在 Zss.BilliardHall.Platform 命名空间 |
| ADR-0003.3 | `Application_Types_Should_Have_Application_Namespace` | Application 类型应在 Zss.BilliardHall.Application 命名空间 |
| ADR-0003.4 | `Module_Types_Should_Have_Module_Namespace` | Module 类型应在 Zss.BilliardHall.Modules.{ModuleName} 命名空间 |
| ADR-0003.5 | `Host_Types_Should_Have_Host_Namespace` | Host 类型应在 Zss.BilliardHall.Host.{HostName} 命名空间 |
| ADR-0003.6 | `Directory_Build_Props_Should_Exist_At_Repository_Root` | Directory.Build.props 应存在于仓库根目录 |
| ADR-0003.7 | `Directory_Build_Props_Should_Define_Base_Namespace` | Directory.Build.props 应定义 BaseNamespace |
| ADR-0003.8 | `All_Projects_Should_Follow_Namespace_Convention` | 所有项目应遵循命名空间约定 |
| ADR-0003.9 | `Modules_Should_Not_Contain_Irregular_Namespace_Patterns` | 模块不应包含不规范的命名空间模式 |

### 6.2 自检问题

在提交代码前，请确认：

**项目结构**：
- [ ] 项目名是否等于目录最后一级名称？
- [ ] 是否遵循标准目录结构（Platform/Application/Modules/Host/Tests）？
- [ ] 是否没有使用 Common、Shared、Utils 等不规范命名？

**命名空间规则**：
- [ ] 命名空间是否与目录结构完全一致？
- [ ] 所有类型的命名空间是否都以 BaseNamespace 开头？
- [ ] 是否没有手动设置 BaseNamespace 或 RootNamespace？

**MSBuild 配置**：
- [ ] Directory.Build.props 是否存在于仓库根目录？
- [ ] Directory.Build.props 是否定义了 CompanyNamespace 和 ProductNamespace？
- [ ] 项目文件是否没有手动覆盖命名空间设置？

### 6.3 如何编写符合映射要求的测试

#### 示例 1：验证命名空间与目录结构一致

```csharp
[Theory(DisplayName = "ADR-0003.4: Module 类型应在 Zss.BilliardHall.Modules.{ModuleName} 命名空间")]
[ClassData(typeof(ModuleAssemblyData))]
public void Module_Types_Should_Have_Module_Namespace(Assembly moduleAssembly)
{
    var moduleName = moduleAssembly.GetName().Name!.Split('.').Last();
    var types = Types.InAssembly(moduleAssembly)
        .GetTypes()
        .Where(t => !t.Name.StartsWith("<"))
        .ToList();

    foreach (var type in types)
    {
        Assert.True(type.Namespace?.StartsWith($"{BaseNamespace}.Modules.{moduleName}") == true,
            $"❌ ADR-0003.4 违规: Module 程序集中的类型应在 {BaseNamespace}.Modules.{{ModuleName}} 命名空间下\n\n" +
            $"模块名: {moduleName}\n" +
            $"违规类型: {type.FullName}\n" +
            $"当前命名空间: {type.Namespace}\n" +
            $"期望命名空间前缀: {BaseNamespace}.Modules.{moduleName}\n\n" +
            $"修复建议:\n" +
            $"1. 确保类型定义在正确的命名空间中\n" +
            $"2. 模块 {moduleName} 的所有代码都应该在 {BaseNamespace}.Modules.{moduleName} 命名空间下\n" +
            $"3. 如果是子命名空间，应该是 {BaseNamespace}.Modules.{moduleName}.* 格式（如 .Domain, .UseCases）\n\n" +
            $"参考: docs/copilot/adr-0003.prompts.md (场景 2)");
    }
}
```

**关键点**：
- 使用 Theory 测试所有模块
- 失败消息包含清晰的 ADR 编号（ADR-0003.4）
- 显示当前值和期望值
- 提供具体的修复建议（编号列表）
- 引用相关文档

#### 示例 2：验证禁止的命名空间模式

```csharp
[Theory(DisplayName = "ADR-0003.9: 模块不应包含不规范的命名空间模式")]
[ClassData(typeof(ModuleAssemblyData))]
public void Modules_Should_Not_Contain_Irregular_Namespace_Patterns(Assembly moduleAssembly)
{
    // 禁止的命名空间模式
    var forbiddenPatterns = new[] { ".Util", ".Utils", ".Helper", ".Helpers", ".Common", ".Shared" };

    foreach (var pattern in forbiddenPatterns)
    {
        var result = Types.InAssembly(moduleAssembly)
            .That().ResideInNamespaceStartingWith($"{BaseNamespace}.Modules")
            .ShouldNot().ResideInNamespaceContaining(pattern)
            .GetResult();

        Assert.True(result.IsSuccessful,
            $"❌ ADR-0003.9 违规: 模块不应包含不规范的命名空间模式\n\n" +
            $"模块: {moduleAssembly.GetName().Name}\n" +
            $"禁止的模式: {pattern}\n" +
            $"违规类型:\n{string.Join("\n", result.FailingTypes?.Select(t => $"  - {t.FullName}") ?? Array.Empty<string>())}\n\n" +
            $"修复建议:\n" +
            $"1. 避免使用 Util/Helper/Common/Shared 等不规范的命名空间\n" +
            $"2. 采用垂直切片组织代码（按用例组织，而非按技术层次）\n" +
            $"3. 技术性抽象移到 Platform 或 BuildingBlocks\n\n" +
            $"参考: docs/copilot/adr-0003.prompts.md (反模式 3, FAQ Q4)");
    }
}
```

**关键点**：
- 测试名称包含 ADR 编号（ADR-0003.9）
- 明确列出违规类型
- 提供清晰的问题诊断和修复路径

### 6.4 验证脚本

运行以下命令验证所有 ADR-0003 测试：

```bash
# 运行所有 ADR-0003 测试
dotnet test --filter "FullyQualifiedName~ADR_0003"

# 运行特定约束测试
dotnet test --filter "DisplayName~ADR-0003.1"
dotnet test --filter "DisplayName~ADR-0003.4"

# 查看详细输出
dotnet test --filter "FullyQualifiedName~ADR_0003" --logger "console;verbosity=detailed"
```

### 6.5 更新提示

**何时需要更新测试**：

1. **新增项目**
   - 确保项目名与目录名一致
   - 不设置手动命名空间
   - 依赖 Directory.Build.props 自动推导

2. **修改目录结构**
   - 确保命名空间与新结构匹配
   - 重新运行所有 ADR-0003 测试
   - 更新所有 using 语句

3. **重构命名空间**
   - 确保不引入 Common/Shared/Utils 等模式
   - 确保所有类型仍以 BaseNamespace 开头
   - 确保命名空间与物理目录一致

4. **修改 BaseNamespace**
   - 重新运行所有架构测试
   - 更新所有项目引用
   - 确保 CI 通过

**测试失败时的处理流程**：
```
1. 查看失败消息中的 ADR 编号
2. 参考 docs/copilot/adr-0003.prompts.md 对应场景
3. 按照修复建议逐步修复
4. 重新运行测试验证
5. 如有疑问，参考 ADR-0003 完整文档
```

---

## 七、相关资源

- [ADR-0003 完整文档](../adr/constitutional/ADR-0003-namespace-rules.md)
- [架构测试类](../../src/tests/ArchitectureTests/ADR/ADR_0003_Architecture_Tests.cs)
- [Directory.Build.props](../../Directory.Build.props)

---

## 版本历史

| 版本 | 日期       | 变更说明 |
|------|------------|----------|
| 1.1  | 2026-01-21 | 添加测试覆盖自检清单（六、测试覆盖自检清单） |
| 1.0  | 2026-01-21 | 初始版本 |
