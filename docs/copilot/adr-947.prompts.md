# ADR-947 Copilot 提示词：关系声明区的结构与解析安全规则

**适用场景**：编写 ADR 关系声明、开发关系验证脚本、循环依赖排查、ADR 重构

**权威依据**：[ADR-947 关系声明区的结构与解析安全规则](../adr/governance/ADR-947-relationship-section-structure-parsing-safety.md)

---

## ⚖️ 核心提醒

**ADR-947 的地位**：

- 📌 关系声明区的结构安全规则
- 📌 防止解析歧义、自指、模板污染、循环链放大
- 📌 机器解析的精确边界定义
- 📌 关系验证脚本的基础约束

**一句话定位**：

> **关系声明区是 ADR 间依赖的唯一可解析语义边界，必须绝对清晰、无歧义、无污染。**

---

## 场景 1：编写 ADR 的关系声明

### 用户意图

"我想在 ADR 中声明与其他 ADR 的关系，应该如何写？"

### Copilot 必须做的

1. **确认关系声明区的唯一性**（ADR-947 条款 1）：
   ```
   每个 ADR 必须且只能包含一个顶级关系声明区：
   
   ✅ 正确：
   ## 关系声明（Relationships）
   
   **依赖（Depends On）**：
   - [ADR-XXXX](路径)
   
   ❌ 错误：
   - 出现第二个 ## 关系声明
   - 模板中使用 ## 关系声明
   - 关系声明章节重复
   ```

2. **确认关系声明区的边界清晰**（ADR-947 条款 2）：
   ```
   关系声明区的有效内容仅存在于：
   从 "## 关系声明（Relationships）" 到下一个 "##" 或 "#" 标题之间
   
   ✅ 正确：
   ## 关系声明（Relationships）
   
   **依赖（Depends On）**：
   - [ADR-001](../constitutional/ADR-001-xxx.md)
   
   **被依赖（Depended By）**：
   - [ADR-0100](../structure/ADR-0100-xxx.md)
   
   ## 版本历史
   
   ❌ 错误：
   ## 关系声明（Relationships）
   
   **依赖（Depends On）**：
   - [ADR-001](../constitutional/ADR-001-xxx.md)
   
   ### 说明
   
   这里解释为什么依赖 ADR-001...  ← 不允许子章节
   
   **被依赖（Depended By）**：
   - [ADR-0100](../structure/ADR-0100-xxx.md)
   ```

3. **确认只使用允许的五类关系**：
   ```
   标准关系类型（仅这五类）：
   
   1. **依赖（Depends On）**：本 ADR 依赖的其他 ADR
   2. **被依赖（Depended By）**：依赖本 ADR 的其他 ADR
   3. **替代（Supersedes）**：本 ADR 替代的旧 ADR
   4. **被替代（Superseded By）**：替代本 ADR 的新 ADR
   5. **相关（Related）**：与本 ADR 相关但无依赖关系的 ADR
   
   ❌ 禁止：
   - 自定义关系类型（如 "参考"、"扩展"、"实现"）
   - 嵌套关系（在关系声明中再细分子类别）
   ```

4. **禁止在非关系声明区使用 ADR 编号**（ADR-947 条款 3）：
   ```
   ❌ 错误：在决策章节中
   ## 决策（Decision）
   
   本规则基于 ADR-001 的模块隔离约束...  ← 不应出现具体编号
   
   ✅ 正确：
   ## 决策（Decision）
   
   本规则基于模块隔离约束（参见相关 ADR）...
   
   或使用占位符：
   本规则基于 ADR-#### 的模块隔离约束...
   ```

### 示例对话

**开发者**："我想声明 ADR-905 依赖 ADR-005，应该如何写？"

**Copilot**：
```
根据 ADR-947 关系声明区的结构规则：

正确写法：

```markdown
## 关系声明（Relationships）

**依赖（Depends On）**：
- [ADR-005：应用内交互模型与执行边界](../constitutional/ADR-005-Application-Interaction-Model-Final.md) - 本文档是 ADR-005 的执行级别补充
- [ADR-900：架构测试与 CI 治理元规则](./ADR-900-architecture-tests.md) - 执行级别基于测试和 CI 治理机制

**被依赖（Depended By）**：
- 无

**替代（Supersedes）**：
- 无

**被替代（Superseded By）**：
- 无

**相关（Related）**：
- [ADR-002：Platform / Application / Host 三层启动体系](../constitutional/ADR-002-platform-application-host-bootstrap.md)
- [ADR-001：模块化单体与垂直切片架构](../constitutional/ADR-001-modular-monolith-vertical-slice-architecture.md)

---
```

注意事项：
1. ✅ 有且仅有一个 ## 关系声明
2. ✅ 关系声明区仅包含五类关系列表
3. ✅ 每个关系项包含：[ADR编号：标题](相对路径) - 说明（可选）
4. ✅ 关系声明区后紧跟 `---` 分隔符和下一个 ## 章节
5. ❌ 不在关系声明区内添加子章节
6. ❌ 不在关系声明区内添加解释性段落

参考：ADR-947 条款 1 和 条款 2
```

---

## 场景 2：避免同编号多文档导致的自引用

### 用户意图

"我想将 ADR-005 拆分为多个文件，应该如何组织？"

### Copilot 必须做的

1. **警告：同编号多文档会导致自引用**（ADR-947 条款 4）：
   ```
   ❌ 禁止模式：
   
   docs/adr/constitutional/
     ├─ ADR-005-Part1-Handler-Rules.md
     └─ ADR-005-Part2-Endpoint-Rules.md
   
   问题：
   - 两个文件都声明自己是 ADR-005
   - 验证脚本会检测到 ADR-005 → ADR-005（自引用）
   - 关系溯源混乱
   ```

2. **提供正确的组织方式**：

**方式一：使用不同编号**（推荐）
```markdown
docs/adr/constitutional/
  ├─ ADR-005-Application-Interaction-Model.md  ← 主 ADR
  └─ ADR-0905-Enforcement-Level-Classification.md  ← 补充 ADR，新编号

# ADR-0905 中声明：
## 关系声明（Relationships）

**依赖（Depends On）**：
- [ADR-005：应用内交互模型](../constitutional/ADR-005-xxx.md) - 本文档是 ADR-005 的补充
```

**方式二：使用内嵌章节**
```markdown
docs/adr/constitutional/
  └─ ADR-005-Application-Interaction-Model-Final.md  ← 单一文件

# 在文件内部组织：
## 决策（Decision）

### Handler 规则
...

### Endpoint 规则
...
```

**方式三：使用子文档（不推荐）**
```markdown
仅用于极大型 ADR（如 ADR-900）：

docs/adr/governance/
  ├─ ADR-900-architecture-tests.md  ← 主文件
  └─ ADR-900/
      ├─ enforcement-details.md  ← 子文档，无独立编号
      └─ ci-integration.md
```

### 示例对话

**开发者**："ADR-005 太长了，我想拆成两个文件，可以吗？"

**Copilot**：
```
根据 ADR-947 禁止同编号多文档（条款 4）：

❌ 不推荐的拆分方式：
- ADR-005-Handler-Rules.md
- ADR-005-Endpoint-Rules.md

问题：
1. 两个文件都是 ADR-005，会被检测为自引用
2. 其他 ADR 声明依赖 ADR-005 时，不清楚依赖哪个文件
3. 验证脚本无法正确解析关系

✅ 推荐的组织方式：

**方案一：创建新的补充 ADR**（推荐）
```
ADR-005：应用内交互模型（主规则）
ADR-0905：执行级别分类（补充说明）

# ADR-0905 中声明：
## 关系声明（Relationships）

**依赖（Depends On）**：
- [ADR-005](../constitutional/ADR-005-xxx.md) - 本文档是 ADR-005 的补充
```

**方案二：使用内嵌章节**
```markdown
# ADR-005-Application-Interaction-Model-Final.md

## 决策（Decision）

### 第一部分：Handler 规则

...（20 页）

### 第二部分：Endpoint 规则

...（20 页）
```

**方案三：使用目录（仅用于特大型 ADR）**
```
docs/adr/governance/
  └─ ADR-900-architecture-tests.md  ← 主文件
      ADR-900/
        ├─ enforcement-details.md  ← 子文档
        └─ ci-integration.md

# 主文件中引用子文档：
详细的执行细节见 [执行详情](./ADR-900/enforcement-details.md)
```

选择建议：
- 如果是补充说明：使用方案一（新编号）
- 如果是主体内容：使用方案二（内嵌章节）
- 如果是特大型 ADR：使用方案三（目录，需架构委员会批准）

参考：ADR-947 条款 4 禁止同编号多文档
```

---

## 场景 3：避免循环依赖

### 用户意图

"ADR-A 依赖 ADR-B，ADR-B 也需要依赖 ADR-A，应该如何处理？"

### Copilot 必须做的

1. **警告：禁止显式循环声明**（ADR-947 条款 5）：
   ```
   ❌ 禁止模式：
   
   # ADR-A
   ## 关系声明（Relationships）
   **依赖（Depends On）**：
   - [ADR-B](路径)
   
   # ADR-B
   ## 关系声明（Relationships）
   **依赖（Depends On）**：
   - [ADR-A](路径)  ← 循环依赖
   
   问题：
   - 验证脚本会检测到 A ↔ B 循环
   - 不清楚哪个 ADR 是基础，哪个是扩展
   - 治理流程混乱
   ```

2. **提供正确的处理方式**：

**方式一：单向依赖 + 相关关系**（推荐）
```markdown
# ADR-A（基础 ADR）
## 关系声明（Relationships）

**依赖（Depends On）**：
- 无

**被依赖（Depended By）**：
- [ADR-B](路径) - ADR-B 扩展了 ADR-A 的规则

**相关（Related）**：
- 无

---

# ADR-B（扩展 ADR）
## 关系声明（Relationships）

**依赖（Depends On）**：
- [ADR-A](路径) - ADR-B 基于 ADR-A 的规则

**相关（Related）**：
- 无  ← 不再反向声明依赖
```

**方式二：重新设计 ADR 边界**
```
如果 A 和 B 真的互相依赖，说明：
1. 它们应该是同一个 ADR
2. 或者需要提取公共部分到新的 ADR-C

# 重构为：
ADR-C：公共基础
ADR-A：基于 C 的规则 A
ADR-B：基于 C 的规则 B

# 关系链：
ADR-A → ADR-C
ADR-B → ADR-C
（无循环）
```

3. **处理历史遗留的循环依赖**：
   ```
   如果已经存在循环依赖：
   
   1. 识别哪个是"基础"，哪个是"扩展"
   2. 保留基础 → 扩展的依赖声明
   3. 将扩展 → 基础改为"相关关系"
   4. 在相关关系中说明原因
   
   示例：
   # ADR-B（扩展）
   ## 关系声明（Relationships）
   
   **依赖（Depends On）**：
   - [ADR-A](路径) - ADR-B 基于 ADR-A
   
   **相关（Related）**：
   - 无（ADR-A 被依赖章节已声明，此处不重复）
   ```

### 示例对话

**开发者**："ADR-001 定义模块隔离，ADR-005 定义 Handler 模式，它们互相引用，应该如何声明关系？"

**Copilot**：
```
根据 ADR-947 禁止显式循环声明（条款 5）：

分析关系：
- ADR-001：模块化单体与垂直切片架构（系统根基）
- ADR-005：应用内交互模型（在模块内的执行规则）

依赖方向判断：
- ADR-005 的 Handler 规则基于 ADR-001 的模块边界
- ADR-001 不依赖 ADR-005 的具体实现

正确的关系声明：

```markdown
# ADR-001-modular-monolith-vertical-slice-architecture.md
## 关系声明（Relationships）

**依赖（Depends On）**：
- 无（系统根基 ADR）

**被依赖（Depended By）**：
- [ADR-005：应用内交互模型](../constitutional/ADR-005-xxx.md)
- [ADR-002：Platform / Application / Host](../constitutional/ADR-002-xxx.md)
- ...

**相关（Related）**：
- 无

---

# ADR-005-Application-Interaction-Model-Final.md
## 关系声明（Relationships）

**依赖（Depends On）**：
- [ADR-001：模块化单体与垂直切片架构](../constitutional/ADR-001-xxx.md) - Handler 模式基于模块隔离约束
- [ADR-900：架构测试与 CI 治理](../governance/ADR-900-xxx.md)

**被依赖（Depended By）**：
- [ADR-0905：执行级别分类](../governance/ADR-0905-xxx.md)
- ...

**相关（Related）**：
- [ADR-002：Platform / Application / Host](../constitutional/ADR-002-xxx.md)
  ← ADR-001 已在被依赖中声明，此处不重复
```

关键原则：
1. ✅ 单向依赖链：ADR-005 → ADR-001
2. ✅ ADR-001 在"被依赖"中声明 ADR-005
3. ❌ ADR-005 不在"相关"中反向声明 ADR-001
4. ❌ 不出现双向依赖：ADR-001 → ADR-005 且 ADR-005 → ADR-001

参考：ADR-947 条款 5 禁止显式循环声明
```

---

## 场景 4：开发关系验证脚本

### 用户意图

"我想开发一个脚本检测 ADR 关系的一致性，应该如何实现？"

### Copilot 必须做的

1. **遵守解析边界规则**（ADR-947 条款 2）：
   ```
   关系声明区的有效内容：
   从 "## 关系声明（Relationships）" 到下一个 "##" 或 "#"
   
   解析约束：
   - 仅提取此范围内的内容
   - 忽略子章节（### / ####）
   - 忽略解释性段落
   - 仅解析列表项
   ```

2. **过滤代码块和模板污染**（结合 ADR-946）：
   ```bash
   # 解析前过滤代码块
   filter_code_blocks() {
       awk '
       /^```/ { in_code = !in_code; next }
       !in_code { print }
       '
   }
   
   # 提取关系声明区
   extract_relationships() {
       filter_code_blocks < "$file" | sed -n '
           /^## 关系声明（Relationships）$/, /^##/ {
               /^## 关系声明（Relationships）$/d
               /^##/q
               p
           }
       '
   }
   ```

3. **实现双向一致性检查**：
   ```bash
   # 检查：如果 A 依赖 B，B 必须在"被依赖"中声明 A
   check_bidirectional_consistency() {
       local adr_a="$1"
       local adr_b="$2"
       
       # 提取 A 的依赖关系
       local a_depends=$(extract_dependencies "$adr_a")
       
       # 提取 B 的被依赖关系
       local b_depended=$(extract_depended_by "$adr_b")
       
       # 检查一致性
       if echo "$a_depends" | grep -q "$adr_b"; then
           if ! echo "$b_depended" | grep -q "$adr_a"; then
               echo "错误：$adr_a 依赖 $adr_b，但 $adr_b 未在'被依赖'中声明 $adr_a"
               return 1
           fi
       fi
   }
   ```

4. **实现循环依赖检测**：
   ```bash
   # 检查：A 依赖 B 且 B 依赖 A
   detect_circular_dependencies() {
       local adr_a="$1"
       local adr_b="$2"
       
       local a_depends=$(extract_dependencies "$adr_a")
       local b_depends=$(extract_dependencies "$adr_b")
       
       if echo "$a_depends" | grep -q "$adr_b" && \
          echo "$b_depends" | grep -q "$adr_a"; then
           echo "循环依赖：$adr_a ↔ $adr_b"
           return 1
       fi
   }
   ```

### 示例对话

**开发者**："我的验证脚本总是报告虚假的循环依赖，应该如何修复？"

**Copilot**：
```
根据 ADR-947 关系声明区的解析边界（条款 2）：

常见问题：

**问题 1：未过滤代码块**
```bash
# ❌ 错误：会提取示例中的关系声明
sed -n '/^## 关系声明/,/^##/p' "$file"

# ✅ 正确：先过滤代码块
awk '
/^```/ { in_code = !in_code; next }
!in_code && /^## 关系声明（Relationships）/ { in_section = 1; next }
!in_code && in_section && /^##/ { exit }
!in_code && in_section { print }
' "$file"
```

**问题 2：未精确匹配标题**
```bash
# ❌ 错误：会匹配 ### 子章节
sed -n '/## 关系声明/,/^##/p'

# ✅ 正确：锚定行首，精确匹配
sed -n '/^## 关系声明（Relationships）$/,/^##/p'
```

**问题 3：提取了子章节内容**
```markdown
## 关系声明（Relationships）

**依赖（Depends On）**：
- [ADR-001](路径)

### 说明  ← 子章节，不应被解析

这里解释为什么依赖...
```

修复：确保只提取列表项
```bash
extract_dependencies() {
    extract_relationships "$file" | \
        sed -n '/\*\*依赖（Depends On）\*\*/,/^\*\*/p' | \
        grep '^\- \[ADR-' | \
        sed 's/.*\[ADR-\([0-9]*\).*/\1/'
}
```

完整的验证脚本示例：

```bash
#!/bin/bash
# validate-adr-relationships.sh

set -euo pipefail

# 过滤代码块
filter_code_blocks() {
    awk '
    /^```/ { in_code = !in_code; next }
    !in_code { print }
    '
}

# 提取关系声明区
extract_relationships() {
    local file="$1"
    filter_code_blocks < "$file" | sed -n '
        /^## 关系声明（Relationships）$/, /^##/ {
            /^## 关系声明（Relationships）$/d
            /^##/q
            p
        }
    '
}

# 提取依赖关系
extract_dependencies() {
    local file="$1"
    extract_relationships "$file" | \
        sed -n '/\*\*依赖（Depends On）\*\*/,/^\*\*/p' | \
        grep '^\- \[ADR-' | \
        sed 's/.*\[ADR-\([0-9]*\).*/\1/'
}

# 检查双向一致性
check_consistency() {
    local all_adrs=$(find docs/adr -name "ADR-*.md")
    
    for adr_file in $all_adrs; do
        local adr_num=$(basename "$adr_file" | sed 's/ADR-\([0-9]*\).*/\1/')
        local depends=$(extract_dependencies "$adr_file")
        
        for dep_num in $depends; do
            local dep_file=$(find docs/adr -name "ADR-${dep_num}-*.md")
            if [[ -z "$dep_file" ]]; then
                echo "错误：ADR-${adr_num} 依赖不存在的 ADR-${dep_num}"
                continue
            fi
            
            # 检查反向关系
            local dep_depended_by=$(extract_depended_by "$dep_file")
            if ! echo "$dep_depended_by" | grep -q "$adr_num"; then
                echo "警告：ADR-${adr_num} 依赖 ADR-${dep_num}，但 ADR-${dep_num} 未声明被依赖"
            fi
        done
    done
}

# 主逻辑
check_consistency
```

参考：
- ADR-947 条款 2 关系区边界
- ADR-946 条款 4 解析工具的语义边界
```

---

## 常见误区

### 误区 1："关系声明可以包含解释性段落"

❌ **错误理解**：
```markdown
## 关系声明（Relationships）

本 ADR 依赖以下 ADR：  ← 解释性段落

**依赖（Depends On）**：
- [ADR-001](路径)
```

✅ **正确理解**：
根据 ADR-947 条款 2：
- 关系声明区仅包含五类关系列表
- 不允许解释性段落
- 不允许子章节

**正确写法**：
```markdown
## 关系声明（Relationships）

**依赖（Depends On）**：
- [ADR-001：模块化单体架构](路径) - 说明可以放在这里
```

---

### 误区 2："双向依赖可以同时声明"

❌ **错误理解**：
"A 依赖 B，B 也依赖 A，我在两边都声明'依赖'就行。"

✅ **正确理解**：
根据 ADR-947 条款 5：
- 禁止双向依赖声明
- 必须单向声明依赖
- 另一侧使用"被依赖"或"相关"

**结论**：双向依赖是治理失败，必须重构 ADR 边界。

---

### 误区 3："模板中的关系声明不影响解析"

❌ **错误理解**：
"我在文档中展示关系声明的格式，解析工具应该能识别这是示例。"

✅ **正确理解**：
根据 ADR-947 条款 1 和 ADR-946 条款 3：
- 简单的解析工具无法区分示例和实际内容
- 代码块中的 ## 关系声明会被误读
- 必须使用英文标题或降级标题

**结论**：模板必须避免使用与正文相同的 ## 标题。

---

## 快速参考

### 关系声明区结构模板

```markdown
## 关系声明（Relationships）

**依赖（Depends On）**：
- [ADR-XXXX：标题](相对路径) - 说明（可选）
- 无

**被依赖（Depended By）**：
- [ADR-YYYY：标题](相对路径)
- 无

**替代（Supersedes）**：
- [ADR-ZZZZ：标题](相对路径)
- 无

**被替代（Superseded By）**：
- 无

**相关（Related）**：
- [ADR-WWWW：标题](相对路径)
- 无

---
```

### 关系声明区约束检查清单

- [ ] 有且仅有一个 `## 关系声明（Relationships）`
- [ ] 关系声明区仅包含五类关系列表
- [ ] 无子章节（`###` / `####`）
- [ ] 无解释性段落
- [ ] 无 ADR 编号出现在其他章节（除非使用占位符）
- [ ] 无同编号多文档
- [ ] 无双向依赖声明

### 循环依赖处理决策树

```
检测到 A ↔ B 循环 → 判断哪个是基础？
                  ├─ A 是基础 → A 不依赖 B，B 依赖 A
                  └─ 无法判断 → 重构：提取公共 ADR-C
                                  A → C
                                  B → C
```

---

## 相关资源

- [ADR-947 关系声明区的结构与解析安全规则](../adr/governance/ADR-947-relationship-section-structure-parsing-safety.md)
- [ADR-946 ADR 标题级别即语义级别约束](../adr/governance/ADR-946-adr-heading-level-semantic-constraint.md)
- [ADR-940 ADR 关系与溯源管理治理规范](../adr/governance/ADR-940-adr-relationship-traceability-management.md)
- [ADR-008 文档编写与维护宪法](../adr/constitutional/ADR-008-documentation-governance-constitution.md)

---

**版本**：1.0  
**最后更新**：2026-01-27  
**维护**：GitHub Copilot Team
