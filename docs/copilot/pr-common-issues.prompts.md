# 最近 PR 常见问题总结 - Copilot 提示词库

**版本**：1.0  
**最后更新**：2026-01-24  
**分析范围**：PR #142 ~ #147  
**状态**：Active

---

## 概述

本文档总结了最近 5 个 PR（#142、#143、#145、#147）中出现的共性问题和改进建议，旨在帮助 Copilot 和开发者避免重复相同的错误。

---

## 一、ADR 文档质量问题

### 问题 1：ADR 文档过于冗长，违反"裁决性"原则

**出现在**：PR #145（ADR-240）、PR #142（ADR-121）

**问题描述**：

ADR 文档包含大量解释性、指导性内容，变成了"说明书"而非"裁决书"。

**典型违规示例**：

```markdown
❌ 错误做法（说明书风格）：

## 异常处理最佳实践

异常处理是确保系统稳定性的关键。当发生异常时，我们需要：
1. 记录完整的堆栈跟踪信息
2. 提供有意义的错误消息
3. 考虑是否需要重试
4. 通知相关人员

例如，当订单创建失败时，我们应该：
- 记录订单ID、用户ID、失败原因
- 回滚已执行的操作
- 发送通知给运维团队
- 建议 3-5 次重试，使用指数退避策略

### 为什么这样做？
这样可以提高系统的可观测性和稳定性...
```

```markdown
✅ 正确做法（裁决型 ADR）：

## 决策

### ADR-240.1：Handler 禁止抛出通用异常

**约束**：Handler 不得抛出 `System.Exception`、`System.ApplicationException`

**执行级别**：L2（Roslyn Analyzer）

**架构测试**：`HandlersShouldNotThrowGenericExceptions`

---

### ADR-240.2：可重试标记仅限基础设施异常

**约束**：只有 `InfrastructureException` 可标记为可重试

**执行级别**：L1（NetArchTest）

**架构测试**：`OnlyInfrastructureExceptionsCanBeRetryable`
```

**修复措施**：

1. **将 ADR 拆分为两部分**：
   - **裁决型 ADR**：只包含 3-5 条可自动判定的规则（~1 页）
   - **工程标准**：详细实践指导（放在 `docs/guides/` 目录）

2. **ADR 中明确引用工程标准，但不赋予裁决权**：
   ```markdown
   ## Non-Goals（不在本 ADR 范围内）
   
   异常处理的详细工程实践参见《Handler Exception & Retry Standard》，
   该文档不具裁决力，仅作为工程参考。
   ```

3. **精简示例代码**：
   - 每条规则最多 1 个正面示例 + 1 个反面示例
   - 示例代码不超过 10 行

**Copilot 应该做什么**：

当开发者让你创建或审查 ADR 时：

```
⚠️ ADR 裁决性检查清单：

[ ] 是否包含"背景"、"阐述原因"等解释性章节？
[ ] 是否有"建议"、"推荐"、"最好"等柔性词汇？
[ ] 是否包含大段示例和使用场景说明？
[ ] 是否包含实现细节（如"使用指数退避"）？
[ ] 规则数量是否超过 10 条？

如有任何一项为"是"，建议重构为：
1. 裁决型 ADR（仅保留核心规则）
2. 工程标准文档（移至 docs/guides/）
```

---

### 问题 2：ADR 包含不可自动判定的规则

**出现在**：PR #145（ADR-240）

**问题描述**：

ADR 中包含无法通过 CI、架构测试或 Analyzer 自动验证的规则。

**典型违规示例**：

```markdown
❌ 无法自动判定的规则：

- "必须记录完整堆栈跟踪"
- "必须记录关键上下文"
- "可以实现补偿逻辑"
- "必须记录每次重试尝试和最终结果"
- "必须将异常转换为合适的 HTTP 状态码"
```

**问题分析**：

- "完整"、"关键"、"合适"等词汇没有明确判定标准
- CI 无法阻断
- Analyzer 无法裁决
- 人工 Code Review 也难以统一标准

**正确做法**：

```markdown
✅ 可自动判定的规则：

规则 ADR-240.1：Handler 禁止抛出 System.Exception
- 执行级别：L2
- 验证方式：Roslyn Analyzer
- 判定标准：代码中是否存在 `throw new Exception(...)`
- CI 阻断：是（编译期）

规则 ADR-240.2：可重试标记仅限 InfrastructureException
- 执行级别：L1
- 验证方式：NetArchTest
- 判定标准：是否存在非 InfrastructureException 实现 IRetryable
- CI 阻断：是（测试期）
```

**Copilot 应该做什么**：

当审查 ADR 规则时，对每条规则询问：

```
⚠️ 可判定性检查：

规则："[规则内容]"

1. 这条规则有明确的判定标准吗？
   [ ] 是（例如：存在/不存在某类型、某命名模式）
   [ ] 否（例如："合理"、"适当"、"完整"）

2. 可以用什么方式自动验证？
   [ ] L1 - NetArchTest（类型、依赖、命名空间）
   [ ] L2 - Roslyn Analyzer（语法、模式）
   [ ] L3 - 启发式规则（复杂逻辑，需人工）
   [ ] 无法自动验证

如选择"无法自动验证"，该规则应：
1. 移除或重新定义为可判定规则
2. 移至工程标准文档（非裁决性）
```

---

### 问题 3：ADR 跨层越权

**出现在**：PR #145（ADR-240）

**问题描述**：

运行层 ADR（ADR-0200~0299）定义了技术实现细节，违反了层级边界。

**典型违规示例**：

```markdown
❌ 运行层 ADR 越权内容：

- 指定"指数退避 + 抖动"算法
- 指定"最大重试次数 3-5 次"
- 指定"日志字段结构"（如：ErrorCode、StackTrace、RequestId）
- 指定"使用 Serilog 记录异常"
```

**问题分析**：

这些属于**技术层（ADR-0300~0399）**的职责，不应出现在运行层 ADR 中。

**层级边界**：

| ADR 层级       | 编号范围        | 职责                      | 示例                    |
| -------------- | --------------- | ------------------------- | ----------------------- |
| 宪法层         | ADR-001~0099   | 架构根基、不可动摇        | 模块隔离、CQRS          |
| 结构层         | ADR-0100~0199   | 结构与组织规范            | 命名规范、DTO 组织      |
| 运行层         | ADR-0200~0299   | 运行时行为边界            | 异常传播、事务边界      |
| 技术层         | ADR-0300~0399   | 技术选型与实现细节        | 日志框架、数据库选型    |
| 治理层         | ADR-900~0999   | ADR 自身治理与元规范      | ADR 模板、执行级别定义  |

**Copilot 应该做什么**：

```
⚠️ 跨层越权检查：

当前 ADR 编号：ADR-[XXXX]
当前层级：[宪法层/结构层/运行层/技术层/治理层]

该层级应该定义：
- ✅ [对应职责]
- ❌ 不应包含 [其他层级职责]

发现以下潜在越权内容：
- "指数退避" → 应移至 ADR-0300~0399（技术层）
- "日志字段结构" → 应移至 ADR-0300~0399（技术层）
- "重试次数范围" → 应移至 ADR-0300~0399（技术层）

建议：
1. 从当前 ADR 移除这些内容
2. 创建对应的技术层 ADR（或放入工程标准）
3. 当前 ADR 仅保留"运行时边界"裁决
```

---

## 二、Copilot 提示词缺失问题

### 问题 4：新增 ADR 缺少配套 Copilot 提示词

**出现在**：PR #143（ADR-120）

**问题描述**：

ADR 正文和架构测试已完成，但缺少 `docs/copilot/adr-XXXX.prompts.md` 文件，导致 Copilot 无法有效辅助开发者。

**标准工作流**（三位一体）：

```
ADR 正文
   ↓
架构测试
   ↓
Copilot 提示词
```

缺少任何一环，治理体系都不完整。

**Copilot 应该做什么**：

当创建新 ADR 时，自动提醒：

```
⚠️ ADR 三位一体检查清单：

已完成：
- [x] ADR 正文：docs/adr/.../ADR-[XXXX]-[name].md
- [x] 架构测试：src/tests/ArchitectureTests/ADR/ADR_[XXXX]_Architecture_Tests.cs

待完成：
- [ ] Copilot 提示词：docs/copilot/adr-[XXXX].prompts.md
- [ ] 更新索引：docs/copilot/README.md

Copilot 提示词文件应包含：
1. 何时触发（4-5 个开发场景）
2. 必须阻止的反模式（3-5 个）
3. CI 失败诊断（每个架构测试对应一条）
4. 快速参考卡片
```

---

## 三、版本管理与演进问题

### 问题 5：契约版本管理策略不明确

**出现在**：PR #142（ADR-121）

**问题描述**：

契约（DTO/Contract）的版本演进策略不够清晰，缺少废弃标记和迁移路径。

**评审反馈**：

1. 需要补充"废弃标记策略"（`[Obsolete]` 特性）
2. 嵌套 DTO 的版本管理规则不明确
3. 缺少自动化文档生成建议

**改进措施**（已在 PR #142 中实施）：

1. **废弃标记策略**：
   ```csharp
   // 阶段 1：警告
   [Obsolete("Use MemberInfoDtoV2 instead", false)]
   public record MemberInfoDto(Guid MemberId, string UserName);
   
   // 阶段 2：错误
   [Obsolete("Use MemberInfoDtoV2 instead", true)]
   public record MemberInfoDto(Guid MemberId, string UserName);
   
   // 阶段 3：移除（在 V3 版本中完全删除）
   ```

2. **嵌套 DTO 版本管理**：
   ```csharp
   // V1
   public record OrderDetailDto(
       Guid OrderId,
       IReadOnlyList<OrderItemDto> Items
   );
   
   // V2 - 父契约升级，子 DTO 同步演进
   public record OrderDetailDtoV2(
       Guid OrderId,
       IReadOnlyList<OrderItemDtoV2> Items,  // 同步升级
       decimal TotalAmount  // 新增字段
   );
   ```

3. **标记接口增强**：
   ```csharp
   public interface IContract
   {
       string Version { get; }  // 运行时版本检查
   }
   ```

**Copilot 应该做什么**：

当开发者修改契约时：

```
⚠️ 契约版本管理检查：

检测到契约修改：[ContractName]

1. 这是破坏性变更吗？
   - 删除字段：是
   - 修改字段类型：是
   - 重命名字段：是
   - 添加非可选字段：是
   - 添加可选字段：否

2. 如果是破坏性变更，应该：
   [ ] 创建新版本（ContractNameV2）
   [ ] 标记旧版本为 [Obsolete]
   [ ] 更新相关 Handler 和 Endpoint
   [ ] 保持旧版本可用（至少 2 个版本周期）

3. 如果包含嵌套 DTO，检查：
   [ ] 嵌套 DTO 是否也需要升级版本？
   [ ] 是否影响其他契约？
```

---

### 问题 6：文档格式不统一

**出现在**：PR #142、#143

**问题描述**：

多个 ADR 初版过于冗长，不符合 ADR 模板格式。

**评审反馈**：

> "重构 ADR，让格式严格遵循模板，不要写成说明书"

**改进措施**：

| 维度       | 重构前                     | 重构后                 | 减少比例 |
| ---------- | -------------------------- | ---------------------- | -------- |
| ADR-121    | 955 行                     | 381 行                 | 60%      |
| ADR-120    | 646 行                     | 232 行                 | 64%      |
| ADR-120 提示词 | 1007 行（初稿）       | 476 行                 | 53%      |

**重构原则**：

1. **删除背景论证、示例冗余、教学内容**
2. **保留规则本体、执法模型、快速参考表、检查清单**
3. **示例代码精简至关键部分（10 行以内）**
4. **决策章节简洁明确（每条规则 3-5 行）**

**Copilot 应该做什么**：

当审查 ADR 文档时：

```
⚠️ ADR 格式检查：

文档长度：[X] 行

参考基准：
- 裁决型 ADR：150-300 行
- 结构层 ADR：200-400 行
- 技术层 ADR：250-500 行

如超出基准 50% 以上，检查：
[ ] 是否包含过多背景解释？
[ ] 是否包含过多示例场景？
[ ] 是否包含实施指导内容？
[ ] 示例代码是否过长？

建议：
1. 移除所有"为什么"解释
2. 每条规则最多 1 正 + 1 反示例
3. 详细内容移至附录或工程标准
```

---

## 四、ADR 与工程标准的边界问题

### 问题 7：ADR 与工程标准混淆

**出现在**：PR #145（ADR-240）

**核心问题**：

很多开发者（包括 Copilot）容易将"最佳实践"写入 ADR，导致 ADR 过度膨胀。

**关键区别**：

| 维度           | ADR（裁决型）                | 工程标准（指导性）                |
| -------------- | ---------------------------- | --------------------------------- |
| 性质           | 法律条文                     | 工程手册                          |
| 内容           | 允许/禁止的明确边界          | 推荐做法、最佳实践                |
| 强制性         | 必须遵守，CI 阻断            | 建议遵守，不强制                  |
| 变更频率       | 低（需架构委员会审批）       | 中（随技术演进调整）              |
| 可判定性       | 100% 可自动判定              | 部分可判定，部分需人工            |
| 示例           | "Handler 禁止抛出 Exception" | "建议 3-5 次重试，使用指数退避"   |
| 文档位置       | docs/adr/                    | docs/guides/                      |
| 裁决权         | 有                           | 无                                |

**正确的拆分方式**（PR #145 实施方案）：

```
原 ADR-240（950 行，包含大量实践指导）
    ↓
拆分为：

1. ADR-240（裁决型，~200 行）
   - 5 条可自动判定规则
   - L1/L2/L3 执行级别明确
   - 架构测试完整覆盖

2. Handler Exception & Retry Standard（非裁决性，~750 行）
   - 异常分类详解
   - 重试策略推荐
   - 幂等性保障模式
   - 可观测性建议
   - 标注"本文档不具裁决力"
```

**Copilot 应该做什么**：

当开发者询问"应该如何处理异常"时：

```
区分裁决规则与工程实践：

【必须遵守】ADR-240 裁决规则：
1. Handler 禁止抛出 System.Exception（L2）
2. 可重试标记仅限 InfrastructureException（L1）
3. Handler 禁止吞噬异常（L2）

【建议参考】工程标准：
1. 推荐重试 3-5 次（非强制）
2. 推荐使用指数退避 + 抖动（非强制）
3. 推荐记录详细日志（非强制）

如违反裁决规则：CI 会阻断
如不遵循工程标准：不影响 CI，但可能影响 Code Review
```

---

## 五、索引和交叉引用问题

### 问题 8：文档创建后未更新索引

**常见疏漏**：

1. 创建 `docs/copilot/adr-XXXX.prompts.md` 后，未更新 `docs/copilot/README.md`
2. 创建新 ADR 后，未更新 `docs/adr/README.md`
3. 创建工程标准后，未在对应 ADR 中引用

**标准工作流**：

```
创建文档
   ↓
更新主索引（README.md）
   ↓
在相关文档中添加交叉引用
   ↓
验证所有链接有效
```

**Copilot 应该做什么**：

```
⚠️ 文档索引更新检查：

新增文档：[文档路径]

需要更新的索引文件：
[ ] docs/copilot/README.md（如为 Copilot 提示词）
[ ] docs/adr/README.md（如为 ADR）
[ ] docs/adr/[layer]/README.md（如为特定层级 ADR）
[ ] docs/guides/README.md（如为工程标准）

需要添加交叉引用：
[ ] 在 ADR 中引用对应的 Copilot 提示词
[ ] 在 Copilot 提示词中引用对应的 ADR
[ ] 在相关 ADR 中相互引用
[ ] 在工程标准中引用对应的 ADR

验证：
[ ] 所有链接可访问
[ ] 版本号对齐
[ ] 文档间引用一致
```

---

## 六、Copilot 行为准则（基于最近 PR 反思）

### 你应该做什么 ✅

1. **预防 ADR 膨胀**：
   - 创建 ADR 时，主动询问："这些内容是裁决规则还是工程实践？"
   - 建议拆分为 ADR + 工程标准

2. **强制三位一体**：
   - 提醒"ADR 正文 + 架构测试 + Copilot 提示词"缺一不可
   - 创建 ADR 时自动生成提示词模板

3. **严格层级边界**：
   - 检查 ADR 内容是否越权
   - 建议移至正确层级

4. **自动更新索引**：
   - 创建文档后，提示更新所有相关索引

5. **验证可判定性**：
   - 每条规则询问："这条规则可以自动判定吗？"
   - 不可判定的规则移至工程标准

### 你不应该做什么 ❌

1. **不要建议"详细说明背景"**：
   - ADR 不是教科书
   - 背景应该精简或移至附录

2. **不要建议"添加更多示例"**：
   - 每条规则 1 正 + 1 反即可
   - 过多示例移至工程标准

3. **不要建议"解释为什么"**：
   - ADR 是"是什么"和"怎么判定"
   - "为什么"属于架构决策记录（另一文档类型）

4. **不要建议"柔性词汇"**：
   - ❌ "建议"、"推荐"、"最好"、"可以考虑"
   - ✅ "必须"、"禁止"、"仅限"、"不得"

5. **不要建议"实现细节"**：
   - 技术选型、算法、参数等应在技术层 ADR 或工程标准

---

## 七、快速参考卡片

### ADR 质量检查清单（1 分钟自检）

```
[ ] 文档长度 < 400 行（裁决型 ADR）
[ ] 规则数量 3-10 条
[ ] 每条规则有明确执行级别（L1/L2/L3）
[ ] 每条规则有对应架构测试
[ ] 无"建议"、"推荐"等柔性词汇
[ ] 无"为什么"、"背景"等解释章节
[ ] 无技术实现细节（除非是技术层 ADR）
[ ] 有配套 Copilot 提示词
[ ] 已更新所有相关索引
```

### 工程标准 vs ADR 决策树

```
这个内容应该放在哪里？

问题 1：这是"允许/禁止"的边界吗？
  ├─ 是 → 可能是 ADR
  └─ 否 → 工程标准

问题 2：可以自动判定吗？
  ├─ 是 → 裁决型 ADR
  └─ 否 → 工程标准

问题 3：违反后 CI 应该阻断吗？
  ├─ 是 → 裁决型 ADR
  └─ 否 → 工程标准

问题 4：这个规则会频繁变化吗？
  ├─ 是 → 工程标准
  └─ 否 → 可能是 ADR
```

---

## 八、改进建议（持续演进）

### 短期改进（1-2 周）

1. **为所有现有 ADR 补全 Copilot 提示词**
2. **审查所有 ADR，识别需要拆分的"说明书型 ADR"**
3. **创建"ADR 自检清单"工具（脚本或 CLI）**

### 中期改进（1-2 月）

1. **建立 ADR 模板自动生成工具**
2. **集成 Roslyn Analyzer，自动检测 L2 规则违规**
3. **建立 ADR 变更流程（RFC → Review → Approve → Implement）**

### 长期改进（3-6 月）

1. **建立 ADR 度量体系**（通过率、违规率、修复时间）
2. **AI 辅助 ADR 审查**（自动识别非裁决性内容）
3. **ADR 知识图谱**（可视化 ADR 间依赖关系）

---

## 九、参考案例（成功重构）

### 案例 1：PR #145（ADR-240 拆分）

**重构前**：
- 文档：950 行
- 规则：15+ 条（部分不可判定）
- 包含大量重试策略、日志字段等实现细节

**重构后**：
- ADR-240（裁决型）：~200 行，5 条规则，100% 可判定
- 工程标准：~750 行，详细实践指导
- 架构测试：5 个，全部通过

**评审结论**：✅ 合格

---

### 案例 2：PR #142（ADR-121 格式重构）

**重构前**：
- 文档：955 行
- 风格：说明书风格，大量示例和解释

**重构后**：
- 文档：381 行（精简 60%）
- 风格：严格遵循 ADR 模板
- 保留：核心决策、约束检查点、快速参考表

**评审结论**：✅ 合格（v1.2）

---

## 十、常见问题（FAQ）

### Q1：如何判断一个规则应该在 ADR 还是工程标准？

**A：** 使用"CI 阻断测试"：

如果违反这个规则，CI 应该立即失败吗？
- 是 → ADR
- 否 → 工程标准

### Q2：ADR 可以有多少条规则？

**A：** 推荐 3-10 条：

- < 3 条：可能过于宏观，考虑合并到其他 ADR
- 3-10 条：理想范围
- > 10 条：可能过于详细，考虑拆分或移至工程标准

### Q3：工程标准会被 Code Review 检查吗？

**A：** 视情况而定：

- 不会阻止 PR 合并（非强制）
- 可能在 Code Review 中被提及（建议性）
- 严重偏离工程标准可能要求解释

### Q4：如果 Copilot 的建议与 ADR 冲突怎么办？

**A：** ADR 优先级最高：

1. 以 ADR 文档为准
2. 记录冲突案例到对应的提示词文件
3. 提交 Issue 报告 Copilot 行为异常

---

## 版本历史

| 版本 | 日期       | 变更说明                     |
| ---- | ---------- | ---------------------------- |
| 1.0  | 2026-01-24 | 初始版本，总结 PR #142~#147 常见问题 |

---

## 参考资源

- [PR #147 - ADR-340 日志与监控](https://github.com/douhuaa/Zss.BilliardHall/pull/147)
- [PR #145 - ADR-240 重构](https://github.com/douhuaa/Zss.BilliardHall/pull/145)
- [PR #143 - ADR-120 提示词补全](https://github.com/douhuaa/Zss.BilliardHall/pull/143)
- [PR #142 - ADR-121 契约规范](https://github.com/douhuaa/Zss.BilliardHall/pull/142)
- [Copilot README](./README.md)
- [ADR-900 治理规范](../adr/governance/ADR-900-adr-governance.md)
