# ADR-240：Handler 异常约束 - Copilot 提示词库

**关联 ADR**：[ADR-240](../adr/runtime/ADR-240-handler-exception-constraints.md)（裁决性规则）  
**工程指南**：[Handler 异常处理与重试工程标准](../guides/handler-exception-retry-standard.md)（非裁决性）  
**测试类**：`ADR_240_Architecture_Tests.cs`  
**版本**：2.0  
**最后更新**：2026-01-24

---

## 重要说明

> **ADR-240 现在是精简的裁决型规则（仅5条可自动判定的规则）。**
>
> 详细的异常处理指导、重试策略、幂等性模式等内容已移至《Handler 异常处理与重试工程标准》。

---

## 一、当我在写什么时，你应该提醒我哪些 ADR-240 约束？

### 场景 1：在领域模型中抛出异常

**触发条件**：

- 在聚合根或实体中添加业务逻辑验证
- 检测到业务规则违反
- 需要抛出异常阻止不合法操作

**你应该提醒的约束**：

```
✅ 使用 DomainException：
1. 继承 DomainException 基类
2. 提供明确的 ErrorCode
3. 提供清晰的业务错误消息
4. 不标记为可重试

示例：
public class OrderAlreadyCancelledException : DomainException
{
    public OrderAlreadyCancelledException(Guid orderId)
        : base("ORDER_ALREADY_CANCELLED", 
               $"订单 {orderId} 已被取消，无法执行此操作")
    {
    }
}

// 在领域模型中使用
public class Order
{
    public void Confirm()
    {
        if (_status == OrderStatus.Cancelled)
        {
            throw new OrderAlreadyCancelledException(Id);
        }
        
        _status = OrderStatus.Confirmed;
        AddDomainEvent(new OrderConfirmed(Id));
    }
}

❌ 禁止：
- throw new Exception("订单已取消")  // 使用通用异常
- throw new InfrastructureException(...)  // 错误的异常分类
- public class OrderException : Exception  // 未继承 DomainException
```

---

### 场景 2：在 Handler 入口处验证输入

**触发条件**：

- 实现 Command Handler 或 Query Handler
- 需要验证输入数据的格式和约束
- 检查必填字段、范围限制等

**你应该提醒的约束**：

```
✅ 使用 ValidationException：
1. 在 Handler 入口处验证
2. 收集所有验证错误
3. 一次性抛出所有错误
4. 不标记为可重试

示例：
public class CreateOrderHandler
{
    public async Task<Guid> Handle(CreateOrder command)
    {
        // 1. 验证输入
        var errors = new Dictionary<string, string[]>();
        
        if (command.MemberId == Guid.Empty)
        {
            errors["MemberId"] = new[] { "会员 ID 不能为空" };
        }
        
        if (command.Items == null || command.Items.Count == 0)
        {
            errors["Items"] = new[] { "订单至少需要一个商品" };
        }
        
        if (errors.Any())
        {
            throw new ValidationException("输入验证失败", errors);
        }
        
        // 2. 执行业务逻辑
        var order = new Order(command.MemberId, command.Items);
        await _repository.SaveAsync(order);
        
        return order.Id;
    }
}

❌ 禁止：
- 在领域模型中抛出 ValidationException（应使用 DomainException）
- 捕获并返回错误结果而不是抛出异常
- 验证失败后继续执行业务逻辑
```

---

### 场景 3：处理基础设施故障

**触发条件**：

- 实现仓储、数据访问层
- 调用外部服务、数据库
- 处理网络、IO 操作

**你应该提醒的约束**：

```
✅ 使用 InfrastructureException：
1. 封装底层技术异常
2. 标识组件类型
3. 根据故障类型决定是否可重试
4. 提供重试延迟建议（如果可重试）

示例：
public class OrderRepository
{
    public async Task<Order> GetByIdAsync(Guid id)
    {
        try
        {
            return await _dbContext.Orders.FindAsync(id);
        }
        catch (SqlException ex) when (IsTransientError(ex))
        {
            // 可重试的数据库错误
            throw new InfrastructureException(
                componentType: "Database",
                message: $"获取订单 {id} 时发生暂时性数据库错误",
                innerException: ex,
                isRetryable: true,
                suggestedRetryDelayMs: 1000);
        }
        catch (SqlException ex)
        {
            // 不可重试的数据库错误
            throw new InfrastructureException(
                componentType: "Database",
                message: $"获取订单 {id} 时发生数据库错误",
                innerException: ex,
                isRetryable: false);
        }
    }
    
    private bool IsTransientError(SqlException ex)
    {
        // 常见的 SQL Server 暂时性错误代码（具体可重试性需根据实际情况评估）
        // -2: 超时
        // 1205: 死锁
        // 49918, 49919, 49920: Azure SQL 资源限制
        // 40197, 40501, 40613: Azure SQL 连接问题
        return ex.Number is -2 or 1205 or 49918 or 49919 or 49920 or 40197 or 40501 or 40613;
    }
}

✅ 可重试场景：
- 网络超时、连接失败
- 数据库死锁、连接池耗尽
- 外部服务暂时不可用（HTTP 503、429）
- 乐观锁冲突

❌ 不可重试场景：
- 认证失败、权限拒绝
- 资源不存在（HTTP 404）
- 数据格式错误（HTTP 400）
- 约束违反（唯一键冲突）
```

---

### 场景 4：在 Handler 中处理异常

**触发条件**：

- 实现 Command/Query/Event Handler
- 需要处理可能的异常
- 考虑是否需要捕获异常

**你应该提醒的约束**：

```
✅ Handler 异常处理原则：
1. 允许异常向上传播（不要吞噬）
2. 可以在抛出前记录日志
3. 可以添加上下文信息
4. 确保事务在异常时回滚

标准模式：
public class CreateOrderHandler
{
    private readonly ILogger<CreateOrderHandler> _logger;
    
    public async Task<Guid> Handle(CreateOrder command)
    {
        try
        {
            _logger.LogInformation("开始创建订单 MemberId={MemberId}", command.MemberId);
            
            var order = new Order(command.MemberId, command.Items);
            await _repository.SaveAsync(order);
            
            _logger.LogInformation("订单创建成功 OrderId={OrderId}", order.Id);
            return order.Id;
        }
        catch (DomainException ex)
        {
            // 记录业务异常但允许传播
            _logger.LogWarning(ex, "创建订单时业务规则违反 ErrorCode={ErrorCode}", ex.ErrorCode);
            throw;  // 重新抛出
        }
        catch (InfrastructureException ex)
        {
            // 记录基础设施异常
            _logger.LogError(ex, "创建订单时基础设施故障 Component={Component}", ex.ComponentType);
            throw;  // 重新抛出
        }
    }
}

❌ 禁止的模式：
// ❌ 吞噬异常
public async Task Handle(CreateOrder command)
{
    try
    {
        // ...
    }
    catch (Exception)
    {
        return Guid.Empty;  // 错误：掩盖了问题
    }
}

// ❌ 将领域异常转为基础设施异常
catch (DomainException ex)
{
    throw new InfrastructureException(...);  // 错误：破坏异常语义
}

// ❌ 返回错误对象而不是抛出异常
public async Task<Result<Guid>> Handle(CreateOrder command)
{
    if (invalid)
    {
        return Result.Failure("错误");  // Command Handler 应抛出异常
    }
}
```

---

### 场景 5：实现事件处理器与重试

**触发条件**：

- 实现 Event Handler
- 处理领域事件或集成事件
- 需要考虑失败和重试

**你应该提醒的约束**：

```
✅ Event Handler 异常处理：
1. 必须实现幂等性
2. 允许异常向上传播到事件总线
3. 对可重试异常依赖基础设施重试
4. 记录所有异常以支持回溯

示例：
public class OrderCreatedEventHandler : IEventHandler<OrderCreatedEvent>
{
    private readonly ILogger<OrderCreatedEventHandler> _logger;
    private readonly IMemberRepository _memberRepository;
    private readonly IProcessedEventStore _processedEvents;
    
    public async Task Handle(OrderCreatedEvent @event)
    {
        // 1. 幂等性检查
        if (await _processedEvents.HasBeenProcessedAsync(@event.EventId))
        {
            _logger.LogInformation("事件已处理，跳过 EventId={EventId}", @event.EventId);
            return;
        }
        
        try
        {
            // 2. 业务逻辑
            var member = await _memberRepository.GetByIdAsync(@event.MemberId);
            member.IncrementOrderCount();
            await _memberRepository.SaveAsync(member);
            
            // 3. 标记为已处理
            await _processedEvents.MarkAsProcessedAsync(@event.EventId);
            
            _logger.LogInformation("订单事件处理成功 EventId={EventId}", @event.EventId);
        }
        catch (InfrastructureException ex) when (ex.IsRetryable)
        {
            // 可重试异常：记录后向上传播，让事件总线重试
            _logger.LogWarning(ex, 
                "订单事件处理遇到可重试错误 EventId={EventId} RetryDelay={Delay}ms", 
                @event.EventId, ex.SuggestedRetryDelayMs);
            throw;
        }
        catch (Exception ex)
        {
            // 不可重试异常：记录详情
            _logger.LogError(ex, "订单事件处理失败 EventId={EventId}", @event.EventId);
            throw;
        }
    }
}

✅ 幂等性保障方式：
1. 记录已处理事件 ID
2. 使用自然键唯一约束
3. 状态机防护（检查当前状态）
4. 乐观锁版本控制

❌ 禁止：
- 不实现幂等性（重复事件会导致错误）
- 吞噬异常（会丢失事件）
- 事件处理器中抛出不可序列化的异常
```

---

### 场景 6：在 Endpoint/API 中处理异常

**触发条件**：

- 实现 Web API Endpoint
- 需要将 Handler 异常转换为 HTTP 响应
- 处理用户请求错误

**你应该提醒的约束**：

```
✅ Endpoint 异常处理：
1. 捕获所有 Handler 异常
2. 转换为适当的 HTTP 状态码
3. 不暴露内部异常详情
4. 记录完整异常日志

示例：
public class CreateOrderEndpoint : IEndpoint
{
    public void MapEndpoint(IEndpointRouteBuilder builder)
    {
        builder.MapPost("/orders", async (
            CreateOrderRequest request,
            IMessageBus bus,
            ILogger<CreateOrderEndpoint> logger) =>
        {
            try
            {
                var command = new CreateOrder(request.MemberId, request.Items);
                var orderId = await bus.InvokeAsync(command);
                
                return Results.Created($"/orders/{orderId}", new { orderId });
            }
            catch (ValidationException ex)
            {
                // 400 Bad Request - 输入验证失败
                logger.LogWarning(ex, "订单创建验证失败");
                return Results.BadRequest(new
                {
                    error = "VALIDATION_FAILED",
                    message = ex.Message,
                    errors = ex.Errors
                });
            }
            catch (DomainException ex)
            {
                // 422 Unprocessable Entity - 业务规则违反
                logger.LogWarning(ex, "订单创建业务规则违反 ErrorCode={ErrorCode}", ex.ErrorCode);
                return Results.UnprocessableEntity(new
                {
                    error = ex.ErrorCode,
                    message = ex.Message
                });
            }
            catch (InfrastructureException ex)
            {
                // 503 Service Unavailable - 基础设施故障
                logger.LogError(ex, "订单创建基础设施故障 Component={Component}", ex.ComponentType);
                return Results.Problem(
                    statusCode: 503,
                    title: "服务暂时不可用",
                    detail: "系统正在处理您的请求，请稍后重试");
            }
            catch (Exception ex)
            {
                // 500 Internal Server Error - 未预期错误
                logger.LogError(ex, "订单创建发生未预期错误");
                return Results.Problem(
                    statusCode: 500,
                    title: "服务器内部错误",
                    detail: "处理您的请求时发生错误");
            }
        });
    }
}

HTTP 状态码映射：
- ValidationException → 400 Bad Request
- DomainException → 422 Unprocessable Entity
- InfrastructureException (Retryable) → 503 Service Unavailable
- InfrastructureException (Not Retryable) → 502 Bad Gateway
- Other Exception → 500 Internal Server Error

❌ 禁止：
- 暴露内部异常堆栈跟踪
- 返回敏感的系统信息
- 不记录异常日志
- 使用错误的 HTTP 状态码
```

---

## 二、我看到架构测试失败时，如何诊断和修复？

### 测试失败：ADR-240.1 - 自定义异常未继承结构化基类

**错误示例**：

```csharp
// ❌ 错误：直接继承 Exception
public class OrderNotFoundException : Exception
{
    public OrderNotFoundException(Guid orderId)
        : base($"Order {orderId} not found")
    {
    }
}
```

**诊断步骤**：

1. 确定异常的语义分类：
   - 业务规则违反？ → DomainException
   - 输入验证失败？ → ValidationException
   - 技术故障？ → InfrastructureException

2. 在此例中，"订单未找到"可能是业务异常或技术异常：
   - 如果是用户查询不存在的订单 → DomainException
   - 如果是系统内部期望订单存在 → DomainException
   - 如果是数据库连接失败导致 → InfrastructureException

**修复方案**：

```csharp
// ✅ 正确：继承 DomainException
public class OrderNotFoundException : DomainException
{
    public OrderNotFoundException(Guid orderId)
        : base("ORDER_NOT_FOUND", $"订单 {orderId} 不存在")
    {
    }
}
```

---

### 测试失败：ADR-240.2 - 可重试异常不是基础设施异常

**错误示例**：

```csharp
// ❌ 错误：领域异常实现了 IRetryable
public class InsufficientBalanceException : DomainException, IRetryable
{
    public int? SuggestedRetryDelayMs => 5000;
    
    public InsufficientBalanceException(decimal balance, decimal required)
        : base("INSUFFICIENT_BALANCE", $"余额不足：当前 {balance}，需要 {required}")
    {
    }
}
```

**诊断步骤**：

1. 业务规则违反（余额不足）不会因为重试而改变
2. 重试会浪费资源且无意义
3. 应该移除 IRetryable 接口

**修复方案**：

```csharp
// ✅ 正确：移除 IRetryable
public class InsufficientBalanceException : DomainException
{
    public InsufficientBalanceException(decimal balance, decimal required)
        : base("INSUFFICIENT_BALANCE", $"余额不足：当前 {balance}，需要 {required}")
    {
    }
}
```

---

### 测试失败：ADR-240.5 - 异常不在正确的命名空间

**错误示例**：

```csharp
// ❌ 错误：异常在 Domain 命名空间
namespace Zss.BilliardHall.Modules.Orders.Domain;

public class OrderCancelledException : DomainException
{
    // ...
}
```

**修复方案**：

```csharp
// ✅ 正确：移到 Exceptions 命名空间
namespace Zss.BilliardHall.Modules.Orders.Exceptions;

public class OrderCancelledException : DomainException
{
    // ...
}
```

---

## 三、常见问题与最佳实践

### Q1: 什么时候应该抛出异常，什么时候返回错误结果？

**A1**: 在此架构中：

- **Command Handler**: 始终抛出异常，不返回错误结果
- **Query Handler**: 通常抛出异常，但可以返回 null（如查询不存在的实体）
- **领域模型**: 始终抛出异常阻止不合法状态

```csharp
// ✅ Command Handler 抛出异常
public async Task Handle(CancelOrder command)
{
    var order = await _repository.GetByIdAsync(command.OrderId)
        ?? throw new OrderNotFoundException(command.OrderId);
    
    order.Cancel();  // 可能抛出 DomainException
    await _repository.SaveAsync(order);
}

// ✅ Query Handler 可以返回 null
public async Task<OrderDto?> Handle(GetOrderById query)
{
    return await _queryService.GetOrderByIdAsync(query.OrderId);
    // 返回 null 表示不存在，不抛出异常
}
```

### Q2: 如何实现重试策略？

**A2**: 使用 Polly 或类似库实现重试，配置在基础设施层：

```csharp
// 在 Program.cs 或 Bootstrapper 中配置
services.AddResiliencePipeline("retry-policy", builder =>
{
    builder.AddRetry(new RetryStrategyOptions
    {
        MaxRetryAttempts = 3,
        BackoffType = DelayBackoffType.Exponential,
        UseJitter = true,
        OnRetry = args =>
        {
            logger.LogWarning("Retry attempt {Attempt}", args.AttemptNumber);
            return ValueTask.CompletedTask;
        },
        ShouldHandle = new PredicateBuilder()
            .Handle<InfrastructureException>(ex => ex.IsRetryable)
    });
});

// 在仓储或服务中使用
public class OrderRepository
{
    private readonly ResiliencePipeline _retryPipeline;
    
    public async Task SaveAsync(Order order)
    {
        await _retryPipeline.ExecuteAsync(async ct =>
        {
            await _dbContext.SaveChangesAsync(ct);
        });
    }
}
```

### Q3: 如何在分布式场景中保证幂等性？

**A3**: 使用幂等键机制：

```csharp
public class CreateOrderHandler
{
    private readonly IIdempotencyStore _idempotencyStore;
    
    public async Task<Guid> Handle(CreateOrder command, string idempotencyKey)
    {
        // 1. 检查是否已处理
        if (await _idempotencyStore.TryGetResultAsync<Guid>(idempotencyKey, out var existingOrderId))
        {
            return existingOrderId;
        }
        
        // 2. 执行业务逻辑
        var order = new Order(command.MemberId, command.Items);
        await _repository.SaveAsync(order);
        
        // 3. 存储幂等键和结果
        await _idempotencyStore.StoreResultAsync(idempotencyKey, order.Id);
        
        return order.Id;
    }
}
```

---

## 四、快速检查清单

创建或修改异常相关代码时，使用此清单自检：

### 定义异常类

- [ ] 异常类继承自三大基类之一（DomainException/ValidationException/InfrastructureException）
- [ ] 异常类在 `*.Exceptions` 命名空间
- [ ] DomainException 提供了 ErrorCode
- [ ] ValidationException 提供了 Errors 字典（如果适用）
- [ ] InfrastructureException 标识了 ComponentType
- [ ] 可重试异常是 InfrastructureException 且 IsRetryable = true
- [ ] 提供了清晰的异常消息
- [ ] 添加了 XML 文档注释说明异常含义

### Handler 异常处理

- [ ] Handler 不吞噬异常
- [ ] 异常抛出前记录了日志和上下文
- [ ] Command Handler 不返回错误结果
- [ ] Event Handler 实现了幂等性
- [ ] 事务在异常时正确回滚

### 基础设施层

- [ ] 封装了底层技术异常
- [ ] 正确标识了可重试和不可重试场景
- [ ] 提供了合理的重试延迟建议
- [ ] 配置了重试策略（指数退避 + 抖动）
- [ ] 设置了最大重试次数和总时间上限

### Endpoint/API

- [ ] 捕获了所有 Handler 异常
- [ ] 正确映射到 HTTP 状态码
- [ ] 不暴露内部异常详情
- [ ] 记录了完整异常日志
- [ ] 提供了对用户友好的错误消息

---

## 参考资料

- [ADR-240 正文](../adr/runtime/ADR-240-handler-exception-handling-retry-standards.md)
- [ADR-005 应用内交互模型](../adr/constitutional/ADR-005-Application-Interaction-Model-Final.md)
- [架构测试失败诊断指南](./architecture-test-failures.md)
