# ADR-0120：功能切片命名规范 - Copilot 提示词库

本文档为 GitHub Copilot 提供 **ADR-0120（功能切片命名规范）** 的执行指南。

---

## 一、当我在写什么时，你应该提醒我哪些约束？

### 场景 1：创建新的功能切片（Use Case）

**触发条件**：
- 在 `Features/` 目录下创建新目录
- 创建新的 Command、Query、Handler 或 Endpoint

**检查清单**：
- ✅ 目录名是否使用业务动词 + 实体名（PascalCase）？
- ✅ 是否避免了技术术语（CRUD、Save、Load）？
- ✅ Command/Query 是否包含 Command/Query 后缀？
- ✅ Handler 是否包含 Handler 后缀？
- ✅ Endpoint 是否包含 Endpoint 后缀？

**示例对话**：
```
用户："帮我创建一个保存会员信息的功能"
Copilot：
"根据 ADR-0120，应该使用业务动词而非技术术语。

❌ 不建议：SaveMember（技术术语）
✅ 建议使用以下业务术语之一：
- CreateMember（如果是创建新会员）
- UpdateMemberProfile（如果是更新会员档案）
- UpdateMemberContact（如果是更新联系方式）

请明确业务意图，我将为您创建相应的功能切片：
Features/{动词实体}/
├── {动词实体}Command.cs
├── {动词实体}CommandHandler.cs
└── {动词实体}Endpoint.cs"
```

### 场景 2：创建 Command 或 Query

**触发条件**：
- 创建 `*Command.cs` 或 `*Query.cs` 文件

**检查清单**：
- ✅ Command 命名：`{动词}{实体}Command`
- ✅ Query 命名：`{动词}{实体}{限定条件}Query`
- ✅ 使用业务动词（Create, Update, Get, List 等）
- ✅ 避免技术动词（Save, Insert, Select 等）

**示例对话**：
```
用户："帮我创建一个获取会员的 Query"
Copilot：
"根据 ADR-0120，Query 命名应该包含限定条件以明确查询意图。

请选择具体的查询方式：
1. GetMemberByIdQuery - 按 ID 查询单个会员
2. GetMemberByEmailQuery - 按邮箱查询会员
3. ListActiveMembersQuery - 列出所有活跃会员
4. SearchMembersByNameQuery - 按名称搜索会员

您希望创建哪种查询？"
```

### 场景 3：命名 DTO

**触发条件**：
- 创建 `*Dto.cs` 文件

**检查清单**：
- ✅ DTO 命名：`{实体名}{限定词}Dto`
- ✅ 限定词使用：Summary, Details, Brief（可选）
- ✅ 文件位置：与使用它的用例在同一目录

**示例对话**：
```
用户："创建一个会员数据传输对象"
Copilot：
"根据 ADR-0120，DTO 应该根据使用场景选择合适的限定词：

1. MemberDto - 完整会员信息（标准查询）
2. MemberSummaryDto - 会员摘要（列表显示）
3. MemberDetailsDto - 会员详情（详情页面）
4. MemberBriefDto - 简要信息（引用显示）

您的使用场景是？我将创建相应的 DTO。"
```

---

## 二、哪些写法必须阻止？

### ❌ 反模式 1：使用技术术语而非业务术语

```csharp
// ❌ 错误：使用技术动词
public record SaveMemberCommand;        // 应该用 CreateMember 或 UpdateMember
public record InsertOrderCommand;       // 应该用 CreateOrder
public record SelectMemberQuery;        // 应该用 GetMemberById
public record LoadMemberDataQuery;      // 应该用 GetMemberById

// ✅ 正确：使用业务动词
public record CreateMemberCommand;
public record UpdateMemberProfileCommand;
public record GetMemberByIdQuery;
public record ListActiveMembersQuery;
```

**建议**：
"您使用了技术术语 '{技术术语}'，根据 ADR-0120，应该使用业务动词。
建议改为：{业务术语}
这样能更好地表达业务意图。"

### ❌ 反模式 2：命名缺少必要组成部分

```csharp
// ❌ 错误：缺少动词
Features/Member/                    // 应该是 CreateMember、GetMemberById 等
public record MemberCommand;        // 应该是 CreateMemberCommand

// ❌ 错误：缺少实体名
public record CreateCommand;        // 应该是 CreateMemberCommand
public record GetQuery;             // 应该是 GetMemberByIdQuery

// ❌ 错误：缺少 Command/Query 后缀
public record CreateMember;         // 应该是 CreateMemberCommand
public record GetMemberById;        // 应该是 GetMemberByIdQuery

// ✅ 正确：完整的命名
Features/CreateMember/
public record CreateMemberCommand;
public record GetMemberByIdQuery;
```

**建议**：
"命名不完整。根据 ADR-0120：
- Command 格式：{动词}{实体}Command
- Query 格式：{动词}{实体}{限定条件}Query
- Handler 格式：{Command/Query名}Handler

请补充完整的命名。"

### ❌ 反模式 3：Service 后缀

```csharp
// ❌ 错误：使用 Service 后缀
public class MemberService { }              // 违反垂直切片架构
public class CreateMemberService { }        // 应该是 Handler
public class MemberCommandService { }

// ✅ 正确：使用 Handler 后缀
public class CreateMemberCommandHandler { }
public class GetMemberByIdQueryHandler { }
```

**建议**：
"根据 ADR-0120 和垂直切片架构（ADR-0001），不应该使用 Service 后缀。
- 用途：处理单个用例的业务逻辑
- 正确命名：{Command/Query名}Handler
- 示例：CreateMemberCommandHandler

请改用 Handler 模式。"

### ❌ 反模式 4：顺序错误

```csharp
// ❌ 错误：实体名在动词之前
public record MemberCreateCommand;      // 应该是 CreateMemberCommand
public record OrderCancelCommand;       // 应该是 CancelOrderCommand

// ❌ 错误：后缀位置错误
public record CommandCreateMember;      // 应该是 CreateMemberCommand
public record QueryGetMember;           // 应该是 GetMemberByIdQuery

// ✅ 正确：动词 + 实体 + 后缀
public record CreateMemberCommand;
public record CancelOrderCommand;
```

**建议**：
"命名顺序错误。根据 ADR-0120，应该遵循：
- Command：{动词}{实体}Command
- Query：{动词}{实体}{限定条件}Query

当前：{错误命名}
应该：{正确命名}"

### ❌ 反模式 5：Request/Response 混淆

```csharp
// ❌ 错误：API 层和应用层概念混淆
public record CreateMemberCommand     // 应用层
{
    public string ApiVersion { get; init; }  // API 层概念
    public string TraceId { get; init; }     // API 层概念
}

// ✅ 正确：分离 API 层和应用层
public record CreateMemberRequest     // API 层
{
    public string ApiVersion { get; init; }
    public string TraceId { get; init; }
    public string Name { get; init; }
    public string Email { get; init; }
}

public record CreateMemberCommand     // 应用层
{
    public string Name { get; init; }
    public string Email { get; init; }
}
```

**建议**：
"Command 不应包含 API 特定字段。
- Command/Query：应用层意图，纯业务数据
- Request/Response：API 层数据，可包含 API 元数据

如果需要 API 元数据，请创建单独的 Request/Response 类。"

---

## 三、CI 失败时，你应该如何解释？

### 失败场景 1：命名不符合规范

**CI 错误信息**：
```
ADR-0120.1: Command/Query 命名应符合规范
Failed: 'SaveMemberCommand' does not follow naming convention
Expected pattern: {Verb}{Entity}Command
Issue: 'Save' is a technical term, use business term instead
Suggestions: CreateMemberCommand, UpdateMemberProfileCommand
```

**人话翻译**：
"您的 Command 命名使用了技术术语 'Save'。

根据 ADR-0120，应该使用业务动词：
- 如果是创建新会员 → CreateMemberCommand
- 如果是更新会员信息 → UpdateMemberProfileCommand
- 如果是更新特定字段 → Update{具体内容}Command

修复方法：
1. 明确业务意图（创建 or 更新？）
2. 使用对应的业务动词重命名
3. 更新所有引用此 Command 的代码"

### 失败场景 2：Handler 命名不一致

**CI 错误信息**：
```
ADR-0120.2: Handler 命名应与 Command/Query 对应
Failed: Handler 'CreateMemberService' does not match Command 'CreateMemberCommand'
Expected: CreateMemberCommandHandler
```

**人话翻译**：
"Handler 命名不符合规范。

当前：CreateMemberService
Command：CreateMemberCommand
应该命名为：CreateMemberCommandHandler

修复方法：
1. 重命名类为 CreateMemberCommandHandler
2. 重命名文件为 CreateMemberCommandHandler.cs
3. 更新命名空间和所有引用"

### 失败场景 3：目录名不符合规范

**CI 错误信息**：
```
ADR-0120.3: 功能切片目录应使用业务动词
Failed: Directory 'CRUD' does not follow naming convention
Expected pattern: {Verb}{Entity}
Examples: CreateMember, GetMemberById, UpdateMemberProfile
```

**人话翻译**：
"功能切片目录名称不符合规范。

当前：CRUD（技术术语）
应该：使用明确的业务动词 + 实体名

修复方法：
1. 识别目录中的具体功能
2. 为每个功能创建独立目录：
   - CreateMember/
   - GetMemberById/
   - UpdateMemberProfile/
   - DeleteMember/
3. 将代码拆分到对应目录
4. 删除 CRUD 目录"

---

## 四、典型问答（FAQ）

### Q1: 为什么要使用业务动词而非技术动词？

**A:** 根据 ADR-0120，业务动词能更好地表达意图：

**业务价值**：
- Save → CreateMember / UpdateMember（明确是创建还是更新）
- Insert → CreateOrder（表达业务操作）
- Delete → CancelOrder / DeactivateMember（表达业务含义）

技术术语（Save、Insert、Select）关注实现细节，业务术语关注业务意图。

### Q2: Command 和 Request 有什么区别？

**A:**
- **Command**：应用层意图，纯业务数据
- **Request**：API 层数据结构，可包含 API 元数据

示例：
```csharp
// API 层
public record CreateMemberRequest
{
    public string ApiVersion { get; init; }  // API 元数据
    public string Name { get; init; }
    public string Email { get; init; }
}

// 应用层
public record CreateMemberCommand
{
    public string Name { get; init; }        // 只有业务数据
    public string Email { get; init; }
}
```

在简单场景下可以直接使用 Command 作为 Request。

### Q3: Query 的限定条件如何命名？

**A:** 限定条件用于区分同类查询：

**推荐模式**：
- 按唯一标识：`GetMemberByIdQuery`, `GetOrderByNumberQuery`
- 按业务属性：`GetMemberByEmailQuery`, `FindOrdersByStatusQuery`
- 列表查询：`ListActiveMembersQuery`, `ListRecentOrdersQuery`
- 搜索查询：`SearchMembersByNameQuery`, `SearchOrdersByDateQuery`

### Q4: DTO 的限定词如何选择？

**A:** 根据使用场景选择限定词：

| 场景 | 限定词 | 示例 | 说明 |
|------|--------|------|------|
| 标准查询 | 无 | `MemberDto` | 完整信息 |
| 列表显示 | Summary | `MemberSummaryDto` | 摘要信息 |
| 详情页面 | Details | `MemberDetailsDto` | 详细信息 |
| 引用显示 | Brief | `MemberBriefDto` | 简要信息 |

---

## 五、快速检查清单

### PR 前自检（命名规范）

**功能切片目录**：
- [ ] 使用业务动词 + 实体名（PascalCase）
- [ ] 避免技术术语（CRUD、Save、Load）
- [ ] 名称清晰表达业务意图

**Command 命名**：
- [ ] 格式：{动词}{实体}Command
- [ ] 使用业务动词（Create, Update, Cancel 等）
- [ ] 动词在前，实体在后

**Query 命名**：
- [ ] 格式：{动词}{实体}{限定条件}Query
- [ ] 包含限定条件（ById, ByEmail 等）
- [ ] 使用查询动词（Get, List, Find, Search）

**Handler 命名**：
- [ ] 格式：{Command/Query名}Handler
- [ ] 与 Command/Query 一一对应
- [ ] 不使用 Service 后缀

**DTO 命名**：
- [ ] 格式：{实体}{限定词}Dto
- [ ] 限定词根据使用场景选择
- [ ] 放在使用它的用例目录中

---

## 六、推荐的业务动词

### Command 常用动词

| 动词 | 含义 | 示例 |
|------|------|------|
| Create | 创建 | CreateMemberCommand |
| Update | 更新 | UpdateMemberProfileCommand |
| Delete | 删除 | DeleteMemberCommand |
| Activate | 激活 | ActivateMemberCommand |
| Deactivate | 停用 | DeactivateMemberCommand |
| Cancel | 取消 | CancelOrderCommand |
| Approve | 批准 | ApproveRefundCommand |
| Reject | 拒绝 | RejectOrderCommand |
| Submit | 提交 | SubmitApplicationCommand |
| Process | 处理 | ProcessPaymentCommand |

### Query 常用动词

| 动词 | 含义 | 返回 | 示例 |
|------|------|------|------|
| Get | 获取单个 | 单个实体（可为 null） | GetMemberByIdQuery |
| Find | 查找单个 | 单个实体（可为 null） | FindMemberByEmailQuery |
| List | 列举多个 | 列表（可为空） | ListActiveMembersQuery |
| Search | 搜索 | 分页结果 | SearchOrdersQuery |
| Calculate | 计算 | 计算结果 | CalculateMemberStatisticsQuery |
| Generate | 生成 | 生成的数据 | GenerateReportQuery |

---

## 六、编写架构测试的经验教训

### 关键原则：必须写可执行的架构测试

结构层 ADR（如 ADR-0120 命名规范）**不是** Level 3（人工 Gate），而是 Level 1 或 Level 2：
- ✅ **可以**通过反射检查命名后缀（Command、Query、Handler）
- ✅ **可以**通过 NetArchTest 禁止反模式（Service 后缀）
- ❌ **不应该**只写"文档化约束"测试

### 正确的测试示例

```csharp
// ✅ 正确：验证实际约束
[Theory(DisplayName = "ADR-0120.1: Command 类必须以 Command 结尾")]
[ClassData(typeof(ModuleAssemblyData))]
public void Commands_Must_End_With_Command(Assembly moduleAssembly)
{
    var types = moduleAssembly.GetTypes()
        .Where(t => t.Namespace?.Contains(".Features.") == true)
        .Where(t => t.Name.Contains("Command") && !t.Name.Contains("Handler"))
        .ToList();

    var violations = types.Where(t => !t.Name.EndsWith("Command")).ToList();

    Assert.True(violations.Count == 0,
        $"❌ ADR-0120 违规：{string.Join("\n", violations.Select(v => v.FullName))}\n" +
        $"修复建议：确保 Command 类名以 'Command' 结尾。");
}
```

详细经验总结见：[ADR-0110 Copilot Prompts - 第六章](/docs/copilot/adr-0110.prompts.md#六编写架构测试的常见错误和正确做法)

---

## 七、相关 ADR 和文档

- [ADR-0120：功能切片命名规范](/docs/adr/structure/ADR-0120-feature-naming-conventions.md)
- [ADR-0001：模块化单体与垂直切片架构](/docs/adr/constitutional/ADR-0001-modular-monolith-vertical-slice-architecture.md)
- [ADR-0005：应用内交互模型](/docs/adr/constitutional/ADR-0005-Application-Interaction-Model-Final.md)

---

## 版本历史

| 版本 | 日期 | 变更说明 |
|------|------|---------|
| 1.1 | 2026-01-22 | 新增"编写架构测试的经验教训"章节 |
| 1.0 | 2026-01-22 | 初始版本，配合 ADR-0120 创建 |
