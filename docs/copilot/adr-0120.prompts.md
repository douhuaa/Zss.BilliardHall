# ADR-120：领域事件命名规范 - Copilot 提示词库

**关联 ADR**：[ADR-120](../adr/structure/ADR-120-domain-event-naming-convention.md)  
**测试类**：`ADR_0120_Architecture_Tests.cs`  
**版本**：1.0  
**最后更新**：2026-01-24  
**对应 ADR 版本**：v1.2  
**对齐状态**：✅ 100% 完成

---

## 一、当我在写什么时，你应该提醒我哪些 ADR-120 约束？

### 场景 1：创建新的领域事件

**触发条件**：

- 在模块的 `Events` 命名空间下创建新类型
- 定义事件类来描述业务事实
- 需要跨模块传递业务状态变化

**你应该提醒的约束**：

```
✅ 检查清单：
1. 事件名称是否遵循 {AggregateRoot}{Action}Event 模式？
2. 动词是否使用过去式（如 Created、Paid、Cancelled）？
3. 是否包含 'Event' 后缀？
4. 是否在正确的命名空间（Zss.BilliardHall.Modules.{ModuleName}.Events）？
5. 是否使用 record 定义（不可变）？
6. 属性是否只包含原始类型和 DTO，不包含领域实体？
7. 是否避免包含业务方法？

标准模板：
namespace Zss.BilliardHall.Modules.Orders.Events;

public record OrderCreatedEvent(
    Guid OrderId,
    Guid MemberId,
    DateTime CreatedAt
);

❌ 禁止：
- 缺少 Event 后缀（如 OrderCreated）
- 使用现在时（如 OrderCreate、OrderCreating）
- 包含领域实体（如 Order、Member 对象）
- 包含业务方法（如 CanBeCancelled()）
- 嵌入跨模块业务语义（如 OrderCreatedAndPointsAddedEvent）
```

---

### 场景 2：实现事件处理器（EventHandler）

**触发条件**：

- 创建订阅和处理领域事件的类
- 在模块内或跨模块响应事件
- 实现 IEventHandler<TEvent> 接口

**你应该提醒的约束**：

```
✅ 检查清单：
1. 处理器类名是否以 'Handler' 后缀结尾？
2. 是否实现 IEventHandler<TEvent> 接口？
3. 是否在正确的命名空间（Zss.BilliardHall.Modules.{ModuleName}.EventHandlers）？
4. 对于多订阅场景，是否使用扩展命名模式？

基础命名模式：
namespace Zss.BilliardHall.Modules.Orders.EventHandlers;

public class OrderCreatedEventHandler : IEventHandler<OrderCreatedEvent>
{
    public async Task Handle(OrderCreatedEvent @event)
    {
        // 处理逻辑
    }
}

扩展命名模式（多订阅场景）：
// Members 模块订阅 OrderPaidEvent
public class OrderPaidEventAddPointsHandler : IEventHandler<OrderPaidEvent>
{
    public async Task Handle(OrderPaidEvent @event)
    {
        // 为会员增加积分
    }
}

// Accounting 模块订阅 OrderPaidEvent
public class OrderPaidEventGenerateInvoiceHandler : IEventHandler<OrderPaidEvent>
{
    public async Task Handle(OrderPaidEvent @event)
    {
        // 生成财务发票
    }
}

❌ 禁止：
- 缺少 Handler 后缀（如 OrderCreatedProcessor、OrderCreatedService）
- 使用模糊的 Purpose（如 OrderPaidEventHandler1、OrderPaidEventHandler2）
- 命名与事件名不对应（如 OrderEventHandler 处理 OrderCreatedEvent）
```

---

### 场景 3：发布领域事件

**触发条件**：

- 在 Handler 中发布事件通知其他模块
- 在领域模型中记录领域事件
- 需要异步通知其他模块业务变化

**你应该提醒的约束**：

```
✅ 检查清单：
1. 事件是否只包含必要的业务数据？
2. 是否只传递原始类型和 DTO？
3. 是否避免传递领域实体？
4. 事件发布者是否不关心订阅者？

正确示例：
// 在 Handler 中发布事件
public class CreateOrderHandler : ICommandHandler<CreateOrder>
{
    public async Task Handle(CreateOrder command)
    {
        var order = new Order(command.MemberId, command.Items);
        await _repository.SaveAsync(order);
        
        // ✅ 发布事件，不关心谁订阅
        await _eventBus.PublishAsync(new OrderCreatedEvent(
            OrderId: order.Id,
            MemberId: order.MemberId,
            CreatedAt: DateTime.UtcNow
        ));
    }
}

// 在其他模块订阅事件
public class OrderCreatedEventHandler : IEventHandler<OrderCreatedEvent>
{
    public async Task Handle(OrderCreatedEvent @event)
    {
        // ✅ 通过 MemberId（原始类型）更新会员统计
        await _memberRepository.UpdateStatisticsAsync(@event.MemberId);
    }
}

❌ 禁止：
- 事件包含领域实体
- 事件包含业务判断方法
- 发布者等待订阅者响应
- 基于事件发布结果做业务决策
```

---

### 场景 4：跨模块使用事件数据

**触发条件**：

- 订阅其他模块发布的事件
- 需要使用事件中的数据
- 在事件处理器中执行业务逻辑

**你应该提醒的约束**：

```
✅ 检查清单：
1. 事件数据是否只用于读取，不用于业务决策？
2. 是否避免依赖事件数据结构执行复杂业务逻辑？
3. 如需验证，是否加载本模块的领域模型？

正确示例：
// ✅ 使用事件数据更新状态
public class OrderPaidEventHandler : IEventHandler<OrderPaidEvent>
{
    public async Task Handle(OrderPaidEvent @event)
    {
        // ✅ 使用事件中的 MemberId 和 Amount
        await _memberRepository.AddPointsAsync(
            @event.MemberId, 
            CalculatePoints(@event.Amount)
        );
    }
}

// ✅ 如需业务验证，加载本模块领域模型
public class OrderCreatedEventHandler : IEventHandler<OrderCreatedEvent>
{
    public async Task Handle(OrderCreatedEvent @event)
    {
        // 加载本模块的 Member 实体进行验证
        var member = await _memberRepository.GetByIdAsync(@event.MemberId);
        if (member.CanReceivePoints)
        {
            member.AddInitialPoints();
            await _memberRepository.SaveAsync(member);
        }
    }
}

❌ 禁止：
- Command Handler 中通过查询 Contracts 做业务决策
  （例如：查询 MemberDto.Balance 来决定是否创建订单）
- 事件处理器中包含复杂的业务规则
  （应该委托给领域模型）
```

---

### 场景 5：事件版本演进

**触发条件**：

- 需要修改现有事件结构
- 添加新字段到事件
- 保持向后兼容性

**你应该提醒的约束**：

```
✅ 检查清单：
1. 是否使用 V{N} 后缀标识新版本（N 从 2 开始）？
2. 新版本是否能从旧版本转换？
3. 是否提供转换适配器？
4. 是否明确废弃策略和时间？

正确示例：
// V1（初始版本，不带版本后缀）
public record OrderCreatedEvent(
    Guid OrderId,
    Guid MemberId,
    DateTime CreatedAt
);

// V2（新版本，添加字段）
public record OrderCreatedEventV2(
    Guid OrderId,
    Guid MemberId,
    DateTime CreatedAt,
    string Source,      // 新增：订单来源
    string Channel      // 新增：订单渠道
);

// 提供转换适配器
public class OrderCreatedEventAdapter
{
    public static OrderCreatedEventV2 ToV2(OrderCreatedEvent v1Event)
    {
        return new OrderCreatedEventV2(
            v1Event.OrderId,
            v1Event.MemberId,
            v1Event.CreatedAt,
            Source: "Unknown",    // 默认值
            Channel: "Web"        // 默认值
        );
    }
}

⚠️ 重要说明：
类型版本命名（V2）≠ 序列化兼容性策略
本 ADR 只定义代码层面的类型标识。
实际的跨系统兼容性将在 ADR-300 系列定义。

❌ 禁止：
- 直接修改现有事件结构（破坏兼容性）
- 不提供转换适配器
- 版本号不一致（如 V2、Version2 混用）
```

---

### 场景 6：组织事件文件结构

**触发条件**：

- 创建新的事件文件
- 重构模块结构
- 组织事件和处理器

**你应该提醒的约束**：

```
✅ 检查清单：
1. 事件是否在 Events 文件夹下？
2. 事件处理器是否在 EventHandlers 文件夹下？
3. 文件名是否与类型名一致？
4. 每个事件是否独立文件？

标准文件组织：
src/Modules/Orders/
  ├── Events/
  │    ├── OrderCreatedEvent.cs
  │    ├── OrderPaidEvent.cs
  │    ├── OrderCancelledEvent.cs
  │    └── OrderShippedEvent.cs
  └── EventHandlers/
       ├── OrderCreatedEventHandler.cs
       └── MemberUpgradedEventHandler.cs  (订阅其他模块事件)

对于复杂模块，可使用子命名空间：
src/Modules/Orders/
  ├── Events/
  │    ├── OrderLifecycle/
  │    │    ├── OrderCreatedEvent.cs
  │    │    └── OrderCompletedEvent.cs
  │    └── Payment/
  │         ├── OrderPaidEvent.cs
  │         └── OrderRefundedEvent.cs

❌ 禁止：
- 事件放在 Domain 或其他非标准命名空间
- 多个事件定义在一个文件中
- 事件放在 Shared/Common 等共享目录
```

---

## 二、哪些写法必须阻止？

### 反模式 1：事件命名违规

**❌ 错误示例**：

```csharp
// ❌ 缺少 Event 后缀
namespace Zss.BilliardHall.Modules.Orders.Events;
public record OrderCreated(Guid OrderId);

// ❌ 使用现在时或进行时
public record OrderCreating(Guid OrderId);
public record OrderCreate(Guid OrderId);

// ❌ 使用动词原形
public record OrderCreateEvent(Guid OrderId);

// ❌ 嵌入跨模块业务语义
public record OrderCreatedAndMemberPointsAddedEvent(
    Guid OrderId, 
    Guid MemberId, 
    int Points
);

// ❌ 使用模糊的名称
public record OrderEvent(Guid OrderId, string Action);
public record OrderDataChangedEvent(Guid OrderId);
```

**✅ 正确做法**：

```csharp
// ✅ 遵循命名规范
namespace Zss.BilliardHall.Modules.Orders.Events;

public record OrderCreatedEvent(Guid OrderId, Guid MemberId, DateTime CreatedAt);
public record OrderPaidEvent(Guid OrderId, decimal Amount, DateTime PaidAt);
public record OrderCancelledEvent(Guid OrderId, string Reason);
public record OrderShippedEvent(Guid OrderId, string TrackingNumber);
```

**为什么必须阻止**：

- 违反 ADR-120.1：事件类型必须以 Event 后缀结尾
- 违反 ADR-120.2：事件名称必须使用动词过去式
- 违反模块隔离原则：事件不应包含跨模块业务语义

---

### 反模式 2：事件包含领域实体

**❌ 错误示例**：

```csharp
// ❌ 事件包含领域实体
namespace Zss.BilliardHall.Modules.Orders.Events;

public record OrderCreatedEvent(
    Order Order,          // ❌ 领域实体
    Member Member         // ❌ 领域实体
);

// ❌ 事件属性引用其他模块的领域对象
public record OrderPaidEvent(
    Guid OrderId,
    Payment Payment       // ❌ 领域对象
);
```

**✅ 正确做法**：

```csharp
// ✅ 只包含原始类型和 DTO
namespace Zss.BilliardHall.Modules.Orders.Events;

public record OrderCreatedEvent(
    Guid OrderId,           // ✅ 原始类型
    Guid MemberId,          // ✅ 原始类型
    DateTime CreatedAt,     // ✅ 原始类型
    List<OrderItemDto> Items  // ✅ DTO
);

public record OrderItemDto(
    string ProductId, 
    int Quantity, 
    decimal Price
);
```

**为什么必须阻止**：

- 违反 ADR-120.5：事件不得包含领域实体类型
- 违反 ADR-0001：模块间不能共享领域模型
- 导致模块间强耦合，破坏模块边界

---

### 反模式 3：事件包含业务方法

**❌ 错误示例**：

```csharp
// ❌ 事件包含业务方法
namespace Zss.BilliardHall.Modules.Orders.Events;

public record OrderCreatedEvent(Guid OrderId, DateTime CreatedAt)
{
    // ❌ 业务判断方法
    public bool CanBeCancelled() => 
        DateTime.UtcNow - CreatedAt < TimeSpan.FromHours(24);
    
    // ❌ 业务计算方法
    public decimal CalculateDiscount() => 
        /* 复杂计算逻辑 */;
}
```

**✅ 正确做法**：

```csharp
// ✅ 事件只包含数据
namespace Zss.BilliardHall.Modules.Orders.Events;

public record OrderCreatedEvent(
    Guid OrderId, 
    Guid MemberId, 
    DateTime CreatedAt
);

// ✅ 业务逻辑在领域模型中
namespace Zss.BilliardHall.Modules.Orders.Domain;

public class Order
{
    public bool CanBeCancelled()
    {
        return DateTime.UtcNow - CreatedAt < TimeSpan.FromHours(24);
    }
}
```

**为什么必须阻止**：

- 违反 ADR-120.6：事件不得包含业务方法
- 事件应该是纯数据对象（Data Object）
- 业务逻辑应该在领域模型或处理器中

---

### 反模式 4：事件处理器命名不规范

**❌ 错误示例**：

```csharp
// ❌ 缺少 Handler 后缀
namespace Zss.BilliardHall.Modules.Orders.EventHandlers;

public class OrderCreatedProcessor : IEventHandler<OrderCreatedEvent> { }

// ❌ 使用 Service 后缀
public class OrderCreatedService : IEventHandler<OrderCreatedEvent> { }

// ❌ 命名不对应事件名称
public class OrderEventHandler : IEventHandler<OrderCreatedEvent> { }

// ❌ Purpose 部分含糊不清
public class OrderPaidEventHandler1 : IEventHandler<OrderPaidEvent> { }
public class OrderPaidEventHandler2 : IEventHandler<OrderPaidEvent> { }
```

**✅ 正确做法**：

```csharp
// ✅ 基础命名模式
namespace Zss.BilliardHall.Modules.Orders.EventHandlers;

public class OrderCreatedEventHandler : IEventHandler<OrderCreatedEvent>
{
    public async Task Handle(OrderCreatedEvent @event)
    {
        // 处理逻辑
    }
}

// ✅ 扩展命名模式（多订阅场景）
namespace Zss.BilliardHall.Modules.Members.EventHandlers;

public class OrderPaidEventAddPointsHandler : IEventHandler<OrderPaidEvent>
{
    public async Task Handle(OrderPaidEvent @event)
    {
        // 为会员增加积分
    }
}

namespace Zss.BilliardHall.Modules.Accounting.EventHandlers;

public class OrderPaidEventGenerateInvoiceHandler : IEventHandler<OrderPaidEvent>
{
    public async Task Handle(OrderPaidEvent @event)
    {
        // 生成财务发票
    }
}
```

**为什么必须阻止**：

- 违反 ADR-120.4：事件处理器必须以 Handler 后缀结尾
- 影响代码可读性和可维护性
- 导致监控和追踪困难

---

### 反模式 5：错误的命名空间组织

**❌ 错误示例**：

```csharp
// ❌ 不在模块内
namespace Zss.BilliardHall.Events;
public record OrderCreatedEvent(Guid OrderId);

// ❌ 使用 Domain 或其他非标准命名空间
namespace Zss.BilliardHall.Modules.Orders.Domain.Events;
public record OrderCreatedEvent(Guid OrderId);

// ❌ 使用 Shared/Common 等命名空间
namespace Zss.BilliardHall.Shared.Events;
public record OrderCreatedEvent(Guid OrderId);
```

**✅ 正确做法**：

```csharp
// ✅ 标准命名空间
namespace Zss.BilliardHall.Modules.Orders.Events;
public record OrderCreatedEvent(Guid OrderId, Guid MemberId, DateTime CreatedAt);

// ✅ 使用子命名空间分组（可选）
namespace Zss.BilliardHall.Modules.Orders.Events.OrderLifecycle;
public record OrderCreatedEvent(...);
public record OrderCompletedEvent(...);

namespace Zss.BilliardHall.Modules.Orders.Events.Payment;
public record OrderPaidEvent(...);
public record OrderRefundedEvent(...);
```

**为什么必须阻止**：

- 违反 ADR-120.3：事件必须在模块的 Events 命名空间下
- 违反 ADR-0003：命名空间规范
- 破坏模块边界和代码组织

---

### 反模式 6：事件属性命名不明确

**❌ 错误示例**：

```csharp
// ❌ 使用通用属性名
namespace Zss.BilliardHall.Modules.Orders.Events;

public record OrderCreatedEvent(
    Guid Id,                // ❌ 不明确（OrderId? MemberId?）
    DateTime Time,          // ❌ 语义模糊
    object Data             // ❌ 类型不明确
);
```

**✅ 正确做法**：

```csharp
// ✅ 明确的属性命名
namespace Zss.BilliardHall.Modules.Orders.Events;

public record OrderCreatedEvent(
    Guid OrderId,           // ✅ 明确的聚合根 ID
    Guid MemberId,          // ✅ 关联实体 ID
    DateTime CreatedAt,     // ✅ 明确的时间语义
    int ItemCount           // ✅ 明确的业务数据
);
```

**为什么必须阻止**：

- 导致代码可读性差
- 增加理解和维护成本
- 容易产生歧义和错误

---

## 三、CI 失败时，你应该如何解释？

### 测试失败 1：Event_Types_Should_End_With_Event_Suffix

**失败消息示例**：

```
❌ ADR-120.1 违规: 事件类型缺少 'Event' 后缀

违规类型: Zss.BilliardHall.Modules.Orders.Events.OrderCreated

问题分析:
所有领域事件类型必须以 'Event' 后缀结尾，以明确标识其为事件

修复建议:
1. 将类型重命名为 OrderCreatedEvent
2. 确保命名遵循模式: {AggregateRoot}{Action}Event
3. 示例：OrderCreatedEvent, MemberUpgradedEvent
```

**Copilot 解释**：

```
这个测试失败是因为您的事件类型名称缺少 'Event' 后缀。

根据 ADR-120.1，所有领域事件必须以 'Event' 结尾。这是为了：
1. 清晰标识类型是事件
2. 区分事件和命令（Command）
3. 保持代码库的一致性

修复步骤：
1. 打开文件：src/Modules/Orders/Events/OrderCreated.cs
2. 将类名从 OrderCreated 改为 OrderCreatedEvent
3. 更新文件名为 OrderCreatedEvent.cs
4. 更新所有引用此事件的代码

示例：
// ❌ 错误
public record OrderCreated(Guid OrderId);

// ✅ 正确
public record OrderCreatedEvent(Guid OrderId, Guid MemberId, DateTime CreatedAt);
```

---

### 测试失败 2：Event_Names_Should_Use_Past_Tense_Verbs

**失败消息示例**：

```
❌ ADR-120.2 违规: 事件名称未使用动词过去式（本体语义约束，L1）

违规类型: Zss.BilliardHall.Modules.Orders.Events.OrderCreatingEvent
命名模式: OrderCreatingEvent

问题分析:
事件名称必须使用动词过去式，因为事件描述的是已发生的业务事实。
使用现在时或进行时会导致事件与命令混淆，造成概念污染。

修复建议:
1. 将动词改为过去式形式：
   - Creating → Created
   - Updating → Updated
   - Processing → Processed
2. 或使用明确的过去式动词：
   - Cancelled, Shipped, Paid, Upgraded, Suspended
```

**Copilot 解释**：

```
这个测试失败是因为您的事件名称使用了进行时（-ing）而不是过去式。

根据 ADR-120.2，事件必须使用过去式动词。这是因为：
1. 事件描述的是已经发生的业务事实
2. 这是领域驱动设计（DDD）的核心概念
3. 区分命令（未来要做）和事件（已经发生）

修复步骤：
1. 将 OrderCreatingEvent 改为 OrderCreatedEvent
2. 将 OrderUpdatingEvent 改为 OrderUpdatedEvent
3. 将 OrderProcessingEvent 改为 OrderProcessedEvent

记住：
- 命令（Command）= 动词原形（CreateOrder, UpdateOrder）
- 事件（Event）= 动词过去式（OrderCreatedEvent, OrderUpdatedEvent）
```

---

### 测试失败 3：Events_Should_Be_In_Events_Namespace

**失败消息示例**：

```
❌ ADR-120.3 违规: 事件未在正确的命名空间下

违规类型: Zss.BilliardHall.Modules.Orders.Domain.OrderCreatedEvent
当前命名空间: Zss.BilliardHall.Modules.Orders.Domain
期望命名空间: Zss.BilliardHall.Modules.{ModuleName}.Events[.{SubNamespace}]

问题分析:
领域事件必须组织在模块的 Events 命名空间下，以保持清晰的结构

修复建议:
1. 将事件移动到正确的命名空间：
   namespace Zss.BilliardHall.Modules.Orders.Events;
2. 或使用子命名空间分组：
   namespace Zss.BilliardHall.Modules.Orders.Events.OrderLifecycle;
3. 禁止的命名空间模式：
   - Zss.BilliardHall.Events (不在模块内)
   - Zss.BilliardHall.Modules.Orders.Domain.Events (非标准)
```

**Copilot 解释**：

```
这个测试失败是因为您的事件放在了错误的命名空间。

根据 ADR-120.3，事件必须在 Events 命名空间下。这是为了：
1. 清晰的文件组织
2. 易于查找和维护
3. 支持工具自动发现

修复步骤：
1. 打开文件：src/Modules/Orders/Domain/OrderCreatedEvent.cs
2. 修改命名空间：
   // ❌ 错误
   namespace Zss.BilliardHall.Modules.Orders.Domain;
   
   // ✅ 正确
   namespace Zss.BilliardHall.Modules.Orders.Events;
3. 将文件移动到正确的位置：
   从：src/Modules/Orders/Domain/OrderCreatedEvent.cs
   到：src/Modules/Orders/Events/OrderCreatedEvent.cs
```

---

### 测试失败 4：Event_Handlers_Should_End_With_Handler_Suffix

**失败消息示例**：

```
❌ ADR-120.4 违规: 事件处理器缺少 'Handler' 后缀

违规类型: Zss.BilliardHall.Modules.Orders.EventHandlers.OrderCreatedProcessor

问题分析:
所有事件处理器必须以 'Handler' 后缀结尾

修复建议:
1. 基础模式：{EventName}Handler
   - OrderCreatedEventHandler
2. 扩展模式（多订阅场景）：{EventName}{Purpose}Handler
   - OrderPaidEventAddPointsHandler
   - OrderPaidEventGenerateInvoiceHandler
3. 禁止使用 Processor、Service 等后缀
```

**Copilot 解释**：

```
这个测试失败是因为您的事件处理器类名没有以 'Handler' 结尾。

根据 ADR-120.4，处理器必须使用 Handler 后缀。这是为了：
1. 保持命名一致性
2. 提高代码可读性
3. 便于监控和追踪

修复步骤：
1. 将 OrderCreatedProcessor 改为 OrderCreatedEventHandler
2. 将 OrderCreatedService 改为 OrderCreatedEventHandler
3. 对于多订阅场景，使用扩展模式：
   - OrderPaidEventAddPointsHandler
   - OrderPaidEventGenerateInvoiceHandler

记住：
- 基础模式：{EventName}Handler
- 扩展模式：{EventName}{Purpose}Handler
- Purpose 应该清晰描述处理器的业务意图
```

---

### 测试失败 5：Events_Should_Not_Contain_Domain_Entities

**失败消息示例**：

```
❌ ADR-120.5 违规: 事件包含领域实体类型

违规事件: Zss.BilliardHall.Modules.Orders.Events.OrderCreatedEvent
领域实体类型: Zss.BilliardHall.Modules.Orders.Domain.Order

问题分析:
事件不得包含领域实体（Entity/Aggregate/ValueObject），只能包含原始类型和 DTO

修复建议:
1. 将领域实体转换为简单 DTO：
   - public record OrderItemDto(string ProductId, int Quantity, decimal Price);
2. 或使用原始类型：
   - Guid OrderId（而非 Order 对象）
   - string MemberId（而非 Member 对象）
3. 事件应该是不可变的数据快照，不包含行为
```

**Copilot 解释**：

```
这个测试失败是因为您的事件包含了领域实体对象。

根据 ADR-120.5，事件只能包含原始类型和 DTO。这是为了：
1. 保持模块隔离
2. 避免跨模块共享领域模型
3. 确保事件是纯数据对象

修复步骤：
1. 识别事件中的领域实体属性
2. 将实体替换为：
   a) 实体 ID（原始类型）
   b) 简单 DTO（只包含数据）

示例：
// ❌ 错误
public record OrderCreatedEvent(
    Order Order,          // ❌ 领域实体
    Member Member         // ❌ 领域实体
);

// ✅ 正确
public record OrderCreatedEvent(
    Guid OrderId,           // ✅ 原始类型
    Guid MemberId,          // ✅ 原始类型
    List<OrderItemDto> Items  // ✅ DTO
);

public record OrderItemDto(string ProductId, int Quantity, decimal Price);
```

---

### 测试失败 6：Events_Should_Not_Contain_Business_Methods

**失败消息示例**：

```
❌ ADR-120.6 违规: 事件包含业务方法

违规事件: Zss.BilliardHall.Modules.Orders.Events.OrderCreatedEvent
业务方法: CanBeCancelled, CalculateDiscount

问题分析:
事件应该是纯数据对象（Data Object），不应包含业务逻辑或判断方法

修复建议:
1. 移除事件中的所有方法，只保留属性
2. 使用 record 类型定义事件（自动不可变）：
   - public record OrderCreatedEvent(Guid OrderId, DateTime CreatedAt);
3. 业务逻辑应该在领域模型或处理器中实现：
   - 判断逻辑 → 领域模型方法
   - 协调逻辑 → Handler
```

**Copilot 解释**：

```
这个测试失败是因为您的事件类型包含了业务方法。

根据 ADR-120.6，事件不应包含任何业务逻辑。这是为了：
1. 保持事件的纯数据特性
2. 避免业务逻辑散落各处
3. 确保事件是不可变的

修复步骤：
1. 识别事件中的所有业务方法
2. 将判断逻辑移到领域模型：
   // 在 Order 类中
   public bool CanBeCancelled() { ... }
3. 将协调逻辑移到 Handler

示例：
// ❌ 错误
public record OrderCreatedEvent(Guid OrderId, DateTime CreatedAt)
{
    public bool CanBeCancelled() => 
        DateTime.UtcNow - CreatedAt < TimeSpan.FromHours(24); // ❌
}

// ✅ 正确
public record OrderCreatedEvent(Guid OrderId, DateTime CreatedAt);

public class Order
{
    public bool CanBeCancelled()
    {
        return DateTime.UtcNow - CreatedAt < TimeSpan.FromHours(24);
    }
}
```

---

## 四、快速参考卡片

### 事件命名检查清单

创建或修改领域事件时，快速检查：

```
□ 事件名称遵循 {AggregateRoot}{Action}Event 模式
□ 动词使用过去式（Created、Paid、Cancelled）
□ 包含 Event 后缀
□ 在 Zss.BilliardHall.Modules.{ModuleName}.Events 命名空间
□ 文件路径与命名空间严格对应
□ 使用 record 定义（不可变）
□ 属性只包含原始类型、DTO，不包含领域实体
□ 不包含业务方法或判断逻辑
□ 事件处理器命名为 {EventName}Handler
□ 跨模块订阅仅通过事件，不直接依赖其他模块
```

### 常见错误速查表

| 错误模式 | 违反约束 | 正确做法 |
|---------|---------|---------|
| `OrderCreated` | ADR-120.1 | `OrderCreatedEvent` |
| `OrderCreating` | ADR-120.2 | `OrderCreatedEvent` |
| `OrderCreateEvent` | ADR-120.2 | `OrderCreatedEvent` |
| `Zss.BilliardHall.Modules.Orders.Domain` | ADR-120.3 | `Zss.BilliardHall.Modules.Orders.Events` |
| `OrderCreatedProcessor` | ADR-120.4 | `OrderCreatedEventHandler` |
| `Order Order` 属性 | ADR-120.5 | `Guid OrderId` |
| `CanBeCancelled()` 方法 | ADR-120.6 | 移到领域模型 |

### 命名模板

```csharp
// 事件定义模板
namespace Zss.BilliardHall.Modules.{ModuleName}.Events;

public record {AggregateRoot}{Action}Event(
    Guid {AggregateRoot}Id,
    // 其他原始类型属性
    DateTime {Action}At
);

// 事件处理器模板（基础模式）
namespace Zss.BilliardHall.Modules.{ModuleName}.EventHandlers;

public class {EventName}Handler : IEventHandler<{EventName}>
{
    public async Task Handle({EventName} @event)
    {
        // 处理逻辑
    }
}

// 事件处理器模板（扩展模式）
public class {EventName}{Purpose}Handler : IEventHandler<{EventName}>
{
    public async Task Handle({EventName} @event)
    {
        // 处理逻辑
    }
}
```

---

## 五、相关文档

- **ADR 正文**：[ADR-120](../adr/structure/ADR-120-domain-event-naming-convention.md)
- **架构测试**：`src/tests/ArchitectureTests/ADR/ADR_0120_Architecture_Tests.cs`
- **相关 ADR**：
  - [ADR-0001](../adr/constitutional/ADR-0001-modular-monolith-vertical-slice-architecture.md) - 模块隔离和通信
  - [ADR-0003](../adr/constitutional/ADR-0003-namespace-rules.md) - 命名空间规范
  - [ADR-0005](../adr/constitutional/ADR-0005-Application-Interaction-Model-Final.md) - 事件通信机制
- **其他 Prompts**：
  - [ADR-0001 提示词](adr-0001.prompts.md) - 模块间通信
  - [ADR-0005 提示词](adr-0005.prompts.md) - Handler 规则

---

## 版本历史

| 版本 | 日期 | 变更说明 |
|-----|------|----------|
| 1.0 | 2026-01-24 | 初始版本，基于 ADR-120 v1.2 创建 |
