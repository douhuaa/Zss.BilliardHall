# ADR-0002：Platform / Application / Host 三层启动体系 - Copilot 提示词库

**关联 ADR**：[ADR-0002](../adr/ADR-0002-platform-application-host-bootstrap.md)  
**测试类**：`ADR_0002_Architecture_Tests.cs`  
**版本**：1.0  
**最后更新**：2026-01-21

---

## 一、当我在写什么时，你应该提醒我哪些 ADR-0002 约束？

### 场景 1：创建新的 Host 项目

**触发条件**：
- 在 `src/Host/` 下创建新的 Host 项目
- 添加新的运行形态（Web / Worker / CLI 等）

**你应该提醒的约束**：
```
✅ 检查清单：
1. Host 项目是否只负责进程外壳？
2. Program.cs 是否不超过 30 行？
3. Host 是否只引用 Application 和 Platform？
4. Host 是否不包含业务逻辑？

❌ 禁止：
- 在 Host 中编写业务逻辑
- Host 直接引用 Modules
- Program.cs 超过 30 行
- Host 依赖具体的 DbContext 或 Repository
```

**标准 Program.cs 模板**：
```csharp
using Zss.BilliardHall.Platform;
using Zss.BilliardHall.Application;

var builder = WebApplication.CreateBuilder(args);

// 1. 初始化 Platform（技术基座）
builder.AddPlatform();

// 2. 装配 Application（业务系统）
builder.AddApplication();

var app = builder.Build();

// 3. 启动
app.Run();
```

---

### 场景 2：在 Platform 层添加功能

**触发条件**：
- 修改 Platform 项目
- 添加新的技术能力

**你应该提醒的约束**：
```
✅ Platform 层职责：
- Logging / Tracing / Metrics
- Health Checks
- Exception Handling
- 技术性中间件

❌ Platform 层禁止：
- 依赖 Application 或 Modules
- 包含业务逻辑
- 感知业务概念（如 Order、Member）
- 引用业务领域类型
```

---

### 场景 3：在 Application 层添加功能

**触发条件**：
- 修改 Application 项目
- 注册新模块或配置业务能力

**你应该提醒的约束**：
```
✅ Application 层职责：
- 模块扫描与注册
- Wolverine / Marten 配置
- 业务能力装配

❌ Application 层禁止：
- 依赖 Host
- 包含具体业务逻辑
- 直接引用 HttpContext
- 决定运行形态（Web/Worker）
```

---

### 场景 4：修改 Program.cs

**触发条件**：
- 需要在 Program.cs 中添加代码
- Program.cs 超过 30 行

**你应该提醒的约束**：
```
⚠️ 警告：Program.cs 超过 30 行 = 设计失败

正确做法：
1. 将配置逻辑提取到 Platform 或 Application 的 Bootstrapper
2. 使用扩展方法封装配置逻辑
3. Program.cs 只保留三行调用：
   - builder.AddPlatform()
   - builder.AddApplication()
   - app.Run()

示例重构：
// ❌ 不要在 Program.cs 中直接配置
builder.Services.AddSerilog(...);
builder.Services.AddOpenTelemetry(...);

// ✅ 封装到 Platform
builder.AddPlatform(); // 内部包含 Serilog、OpenTelemetry 等
```

---

## 二、哪些写法必须阻止？

### 反模式 1：Host 包含业务逻辑

**❌ 错误示例**：
```csharp
// 在 Host/Program.cs 中
app.MapPost("/orders", async (CreateOrderRequest request) =>
{
    // ❌ 业务逻辑不应该在 Host 中
    if (request.Amount > 10000)
    {
        return Results.BadRequest("金额超限");
    }
    
    var order = new Order(request.MemberId, request.Items);
    await dbContext.Orders.AddAsync(order);
    await dbContext.SaveChangesAsync();
    return Results.Ok(order);
});
```

**✅ 正确做法**：
```csharp
// Host/Program.cs 只负责装配
builder.AddPlatform();
builder.AddApplication(); // 内部会扫描并注册所有 Endpoints

// 业务逻辑在模块中
// Orders/Endpoints/CreateOrderEndpoint.cs
public class CreateOrderEndpoint : IEndpoint
{
    public void MapEndpoint(IEndpointRouteBuilder builder)
    {
        builder.MapPost("/orders", async (CreateOrder command, IMessageBus bus) =>
        {
            var result = await bus.InvokeAsync(command);
            return Results.Ok(result);
        });
    }
}
```

---

### 反模式 2：Platform 依赖 Application

**❌ 错误示例**：
```csharp
// 在 Platform 项目中
using Zss.BilliardHall.Application;
using Zss.BilliardHall.Modules.Orders;

// ❌ Platform 不应该依赖 Application 或 Modules
public static class PlatformBootstrapper
{
    public static void AddPlatform(this IHostApplicationBuilder builder)
    {
        // ❌ 不应该在 Platform 中注册模块
        builder.Services.AddScoped<IOrderRepository, OrderRepository>();
    }
}
```

**✅ 正确做法**：
```csharp
// Platform 只关注技术基座
public static class PlatformBootstrapper
{
    public static void AddPlatform(this IHostApplicationBuilder builder)
    {
        // ✅ 只注册技术服务
        builder.AddLogging();
        builder.AddTracing();
        builder.AddHealthChecks();
    }
}
```

---

### 反模式 3：Application 依赖 Host

**❌ 错误示例**：
```csharp
// 在 Application 项目中
using Microsoft.AspNetCore.Http;

// ❌ Application 不应该依赖 Host 类型
public static class ApplicationBootstrapper
{
    public static void AddApplication(this IHostApplicationBuilder builder)
    {
        // ❌ 不应该依赖 HttpContext
        builder.Services.AddScoped(sp => 
            sp.GetRequiredService<IHttpContextAccessor>().HttpContext?.User);
    }
}
```

**✅ 正确做法**：
```csharp
// Application 不感知运行形态
public static class ApplicationBootstrapper
{
    public static void AddApplication(this IHostApplicationBuilder builder)
    {
        // ✅ 使用抽象，不依赖具体的 Host 类型
        builder.Services.AddScoped<ICurrentUserProvider, CurrentUserProvider>();
    }
}
```

---

### 反模式 4：Host 直接引用 Modules

**❌ 错误示例**：
```csharp
// Host.csproj
<ItemGroup>
  <ProjectReference Include="..\..\Modules\Orders\Orders.csproj" />
  <ProjectReference Include="..\..\Modules\Members\Members.csproj" />
  <!-- ❌ Host 不应该直接引用 Modules -->
</ItemGroup>
```

**✅ 正确做法**：
```csharp
// Host.csproj
<ItemGroup>
  <ProjectReference Include="..\..\Application\Application.csproj" />
  <!-- ✅ Host 只引用 Application -->
</ItemGroup>

// Application 负责扫描和注册 Modules
public static class ApplicationBootstrapper
{
    public static void AddApplication(this IHostApplicationBuilder builder)
    {
        // 自动扫描并注册所有模块
        builder.Services.ScanModules();
    }
}
```

---

## 三、CI 失败时，你应该如何解释？

### 失败消息：Platform 依赖 Application

**CI 输出示例**：
```
❌ Test Failed: Platform_Should_Not_Depend_On_Application
   Expected: No dependency from Platform to Application
   Actual: Found reference to 'Zss.BilliardHall.Application'
```

**你应该这样解释**：
```
根据 ADR-0002，依赖方向必须是：Host → Application → Platform

问题分析：
- Platform 层引用了 Application 层
- 这违反了单向依赖原则

修复建议：
1. 移除 Platform 对 Application 的引用
2. 将共享的技术抽象提取到 Platform
3. 如果需要扩展点，使用依赖注入和接口

依赖方向：
✅ Host → Application → Platform
❌ Platform → Application (错误)
❌ Application → Host (错误)
```

---

### 失败消息：Host 包含业务类型

**CI 输出示例**：
```
❌ Test Failed: Host_Should_Not_Contain_Business_Types
   Expected: No business-related types in Host
   Actual: Found 'OrderService' in Host project
```

**你应该这样解释**：
```
根据 ADR-0002，Host 层不应该包含业务逻辑或业务类型。

问题分析：
- Host 层发现业务类型 'OrderService'
- Host 只负责进程外壳，不应包含业务逻辑

修复建议：
1. 将 OrderService 移到 Orders 模块
2. Host 只负责调用 Application 的装配方法
3. 业务逻辑通过 Application 层间接引入

正确的职责划分：
- Host：进程模型、协议、端口
- Application：模块扫描、业务能力装配
- Modules：具体业务逻辑
```

---

### 失败消息：Program.cs 超过 30 行

**CI 输出示例**：
```
❌ Test Failed: Program_Should_Be_Minimal
   Expected: Program.cs <= 30 lines
   Actual: Program.cs has 67 lines
```

**你应该这样解释**：
```
根据 ADR-0002，Program.cs 不应超过 30 行。
超过 30 行 = 设计失败，说明配置逻辑应该被封装。

问题分析：
- Program.cs 过长，包含了太多配置细节
- 应该将配置逻辑提取到 Bootstrapper

修复建议：
1. 将 Platform 相关配置提取到 PlatformBootstrapper
2. 将 Application 相关配置提取到 ApplicationBootstrapper
3. Program.cs 只保留三行核心调用

示例重构：
// ❌ 当前：67 行配置
builder.Services.AddSerilog(...);
builder.Services.AddOpenTelemetry(...);
builder.Services.AddMarten(...);
// ... 更多配置

// ✅ 重构后：< 30 行
builder.AddPlatform();    // 封装所有技术配置
builder.AddApplication(); // 封装所有业务配置
app.Run();
```

---

## 四、典型问答（FAQ）

### Q1: 我想在 Program.cs 中添加一个中间件，应该怎么做？

**A:**
取决于中间件的性质：

1. **技术性中间件** → 放在 Platform
   ```csharp
   // Platform/PlatformBootstrapper.cs
   public static void AddPlatform(this IHostApplicationBuilder builder)
   {
       builder.UseExceptionHandler();
       builder.UseLogging();
   }
   ```

2. **业务性中间件** → 放在 Application
   ```csharp
   // Application/ApplicationBootstrapper.cs
   public static void AddApplication(this IHostApplicationBuilder builder)
   {
       builder.UseWolverine();
       builder.UseMarten();
   }
   ```

❌ **不允许**：
```csharp
// ❌ 直接在 Program.cs 中配置
app.UseExceptionHandler();
app.UseLogging();
```

---

### Q2: 我需要在多个 Host 中共享配置，应该怎么做？

**A:**
将共享配置提取到 Platform 或 Application 的 Bootstrapper：

```csharp
// Platform/PlatformBootstrapper.cs
public static void AddPlatform(this IHostApplicationBuilder builder)
{
    // 所有 Host 共享的技术配置
    builder.AddLogging();
    builder.AddTracing();
}

// 然后在各个 Host 中使用
// Host.Web/Program.cs
builder.AddPlatform();
builder.AddApplication();

// Host.Worker/Program.cs
builder.AddPlatform();
builder.AddApplication();
```

---

### Q3: 我应该在哪一层注册 DbContext？

**A:**
取决于 DbContext 的性质：

1. **共享的技术 DbContext** → Application 层
   ```csharp
   // Application/ApplicationBootstrapper.cs
   builder.AddMarten(options => {
       // 配置 Marten
   });
   ```

2. **模块特定的 DbContext** → 模块内部
   ```csharp
   // Modules/Orders/OrdersModule.cs
   public static void AddOrdersModule(this IServiceCollection services)
   {
       services.AddDbContext<OrdersDbContext>();
   }
   ```

❌ **不允许**：
```csharp
// ❌ 不要在 Platform 中注册业务相关的 DbContext
// ❌ 不要在 Host 中直接注册 DbContext
```

---

## 五、快速检查清单

在提交 PR 前，请对照以下清单：

- [ ] Host 项目是否只引用 Application 和 Platform？
- [ ] Program.cs 是否不超过 30 行？
- [ ] Host 是否不包含业务逻辑？
- [ ] Platform 是否不依赖 Application 或 Modules？
- [ ] Application 是否不依赖 Host？
- [ ] 配置逻辑是否都封装在 Bootstrapper 中？
- [ ] 依赖方向是否正确（Host → Application → Platform）？
- [ ] 架构测试是否全部通过？

---

## 六、三层职责快速参考

| 层级 | 职责 | 允许依赖 | 禁止 |
|------|------|---------|------|
| **Host** | 进程外壳、协议、端口 | Application, Platform | 业务逻辑、直接引用 Modules |
| **Application** | 模块扫描、业务装配 | Platform | Host 类型、具体业务逻辑 |
| **Platform** | 日志、追踪、异常处理 | 无 | Application、Modules、业务概念 |

---

## 七、相关资源

- [ADR-0002 完整文档](../adr/ADR-0002-platform-application-host-bootstrap.md)
- [架构测试类](../../src/tests/ArchitectureTests/ADR/ADR_0002_Architecture_Tests.cs)
- [ADR-0001 模块化单体](../adr/ADR-0001-modular-monolith-vertical-slice-architecture.md)

---

## 版本历史

| 版本 | 日期       | 变更说明 |
|------|------------|----------|
| 1.0  | 2026-01-21 | 初始版本 |
