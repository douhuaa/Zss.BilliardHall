# ADR-0002：Platform / Application / Host 三层启动体系 - Copilot 提示词库

**关联 ADR**：[ADR-0002](../adr/constitutional/ADR-0002-platform-application-host-bootstrap.md)  
**测试类**：`ADR_0002_Architecture_Tests.cs`  
**版本**：1.0  
**最后更新**：2026-01-21

---

## 一、当我在写什么时，你应该提醒我哪些 ADR-0002 约束？

### 场景 1：创建新的 Host 项目

**触发条件**：

- 在 `src/Host/` 下创建新的 Host 项目
- 添加新的运行形态（Web / Worker / CLI 等）

**你应该提醒的约束**：

```
✅ 检查清单：
1. Host 项目是否只负责进程外壳？
2. Program.cs 是否不超过 30 行？
3. Host 是否只引用 Application 和 Platform？
4. Host 是否不包含业务逻辑？

❌ 禁止：
- 在 Host 中编写业务逻辑
- Host 直接引用 Modules
- Program.cs 超过 30 行
- Host 依赖具体的 DbContext 或 Repository
```

**标准 Program.cs 模板**：

```csharp
using Zss.BilliardHall.Platform;
using Zss.BilliardHall.Application;

var builder = WebApplication.CreateBuilder(args);

// 1. 初始化 Platform（技术基座）
builder.AddPlatform();

// 2. 装配 Application（业务系统）
builder.AddApplication();

var app = builder.Build();

// 3. 启动
app.Run();
```

---

### 场景 2：在 Platform 层添加功能

**触发条件**：

- 修改 Platform 项目
- 添加新的技术能力

**你应该提醒的约束**：

```
✅ Platform 层职责：
- Logging / Tracing / Metrics
- Health Checks
- Exception Handling
- 技术性中间件

❌ Platform 层禁止：
- 依赖 Application 或 Modules
- 包含业务逻辑
- 感知业务概念（如 Order、Member）
- 引用业务领域类型
```

---

### 场景 3：在 Application 层添加功能

**触发条件**：

- 修改 Application 项目
- 注册新模块或配置业务能力

**你应该提醒的约束**：

```
✅ Application 层职责：
- 模块扫描与注册
- Wolverine / Marten 配置
- 业务能力装配

❌ Application 层禁止：
- 依赖 Host
- 包含具体业务逻辑
- 直接引用 HttpContext
- 决定运行形态（Web/Worker）
```

---

### 场景 4：修改 Program.cs

**触发条件**：

- 需要在 Program.cs 中添加代码
- Program.cs 超过 30 行

**你应该提醒的约束**：

```
⚠️ 警告：Program.cs 超过 30 行 = 设计失败

正确做法：
1. 将配置逻辑提取到 Platform 或 Application 的 Bootstrapper
2. 使用扩展方法封装配置逻辑
3. Program.cs 只保留三行调用：
   - builder.AddPlatform()
   - builder.AddApplication()
   - app.Run()

示例重构：
// ❌ 不要在 Program.cs 中直接配置
builder.Services.AddSerilog(...);
builder.Services.AddOpenTelemetry(...);

// ✅ 封装到 Platform
builder.AddPlatform(); // 内部包含 Serilog、OpenTelemetry 等
```

---

## 二、哪些写法必须阻止？

### 反模式 1：Host 包含业务逻辑

**❌ 错误示例**：

```csharp
// 在 Host/Program.cs 中
app.MapPost("/orders", async (CreateOrderRequest request) =>
{
    // ❌ 业务逻辑不应该在 Host 中
    if (request.Amount > 10000)
    {
        return Results.BadRequest("金额超限");
    }
    
    var order = new Order(request.MemberId, request.Items);
    await dbContext.Orders.AddAsync(order);
    await dbContext.SaveChangesAsync();
    return Results.Ok(order);
});
```

**✅ 正确做法**：

```csharp
// Host/Program.cs 只负责装配
builder.AddPlatform();
builder.AddApplication(); // 内部会扫描并注册所有 Endpoints

// 业务逻辑在模块中
// Orders/Endpoints/CreateOrderEndpoint.cs
public class CreateOrderEndpoint : IEndpoint
{
    public void MapEndpoint(IEndpointRouteBuilder builder)
    {
        builder.MapPost("/orders", async (CreateOrder command, IMessageBus bus) =>
        {
            var result = await bus.InvokeAsync(command);
            return Results.Ok(result);
        });
    }
}
```

---

### 反模式 2：Platform 依赖 Application

**❌ 错误示例**：

```csharp
// 在 Platform 项目中
using Zss.BilliardHall.Application;
using Zss.BilliardHall.Modules.Orders;

// ❌ Platform 不应该依赖 Application 或 Modules
public static class PlatformBootstrapper
{
    public static void AddPlatform(this IHostApplicationBuilder builder)
    {
        // ❌ 不应该在 Platform 中注册模块
        builder.Services.AddScoped<IOrderRepository, OrderRepository>();
    }
}
```

**✅ 正确做法**：

```csharp
// Platform 只关注技术基座
public static class PlatformBootstrapper
{
    public static void AddPlatform(this IHostApplicationBuilder builder)
    {
        // ✅ 只注册技术服务
        builder.AddLogging();
        builder.AddTracing();
        builder.AddHealthChecks();
    }
}
```

---

### 反模式 3：Application 依赖 Host

**❌ 错误示例**：

```csharp
// 在 Application 项目中
using Microsoft.AspNetCore.Http;

// ❌ Application 不应该依赖 Host 类型
public static class ApplicationBootstrapper
{
    public static void AddApplication(this IHostApplicationBuilder builder)
    {
        // ❌ 不应该依赖 HttpContext
        builder.Services.AddScoped(sp => 
            sp.GetRequiredService<IHttpContextAccessor>().HttpContext?.User);
    }
}
```

**✅ 正确做法**：

```csharp
// Application 不感知运行形态
public static class ApplicationBootstrapper
{
    public static void AddApplication(this IHostApplicationBuilder builder)
    {
        // ✅ 使用抽象，不依赖具体的 Host 类型
        builder.Services.AddScoped<ICurrentUserProvider, CurrentUserProvider>();
    }
}
```

---

### 反模式 4：Host 直接引用 Modules

**❌ 错误示例**：

```csharp
// Host.csproj
<ItemGroup>
  <ProjectReference Include="..\..\Modules\Orders\Orders.csproj" />
  <ProjectReference Include="..\..\Modules\Members\Members.csproj" />
  <!-- ❌ Host 不应该直接引用 Modules -->
</ItemGroup>
```

**✅ 正确做法**：

```csharp
// Host.csproj
<ItemGroup>
  <ProjectReference Include="..\..\Application\Application.csproj" />
  <!-- ✅ Host 只引用 Application -->
</ItemGroup>

// Application 负责扫描和注册 Modules
public static class ApplicationBootstrapper
{
    public static void AddApplication(this IHostApplicationBuilder builder)
    {
        // 自动扫描并注册所有模块
        builder.Services.ScanModules();
    }
}
```

---

## 三、CI 失败时，你应该如何解释？

### 失败消息：Platform 依赖 Application

**CI 输出示例**：

```
❌ Test Failed: Platform_Should_Not_Depend_On_Application
   Expected: No dependency from Platform to Application
   Actual: Found reference to 'Zss.BilliardHall.Application'
```

**你应该这样解释**：

```
根据 ADR-0002，依赖方向必须是：Host → Application → Platform

问题分析：
- Platform 层引用了 Application 层
- 这违反了单向依赖原则

修复建议：
1. 移除 Platform 对 Application 的引用
2. 将共享的技术抽象提取到 Platform
3. 如果需要扩展点，使用依赖注入和接口

依赖方向：
✅ Host → Application → Platform
❌ Platform → Application (错误)
❌ Application → Host (错误)
```

---

### 失败消息：Host 包含业务类型

**CI 输出示例**：

```
❌ Test Failed: Host_Should_Not_Contain_Business_Types
   Expected: No business-related types in Host
   Actual: Found 'OrderService' in Host project
```

**你应该这样解释**：

```
根据 ADR-0002，Host 层不应该包含业务逻辑或业务类型。

问题分析：
- Host 层发现业务类型 'OrderService'
- Host 只负责进程外壳，不应包含业务逻辑

修复建议：
1. 将 OrderService 移到 Orders 模块
2. Host 只负责调用 Application 的装配方法
3. 业务逻辑通过 Application 层间接引入

正确的职责划分：
- Host：进程模型、协议、端口
- Application：模块扫描、业务能力装配
- Modules：具体业务逻辑
```

---

### 失败消息：Program.cs 超过 30 行

**CI 输出示例**：

```
❌ Test Failed: Program_Should_Be_Minimal
   Expected: Program.cs <= 30 lines
   Actual: Program.cs has 67 lines
```

**你应该这样解释**：

```
根据 ADR-0002，Program.cs 不应超过 30 行。
超过 30 行 = 设计失败，说明配置逻辑应该被封装。

问题分析：
- Program.cs 过长，包含了太多配置细节
- 应该将配置逻辑提取到 Bootstrapper

修复建议：
1. 将 Platform 相关配置提取到 PlatformBootstrapper
2. 将 Application 相关配置提取到 ApplicationBootstrapper
3. Program.cs 只保留三行核心调用

示例重构：
// ❌ 当前：67 行配置
builder.Services.AddSerilog(...);
builder.Services.AddOpenTelemetry(...);
builder.Services.AddMarten(...);
// ... 更多配置

// ✅ 重构后：< 30 行
builder.AddPlatform();    // 封装所有技术配置
builder.AddApplication(); // 封装所有业务配置
app.Run();
```

---

## 四、典型问答（FAQ）

### Q1: 我想在 Program.cs 中添加一个中间件，应该怎么做？

**A:**
取决于中间件的性质：

1. **技术性中间件** → 放在 Platform
   ```csharp
   // Platform/PlatformBootstrapper.cs
   public static void AddPlatform(this IHostApplicationBuilder builder)
   {
       builder.UseExceptionHandler();
       builder.UseLogging();
   }
   ```

2. **业务性中间件** → 放在 Application
   ```csharp
   // Application/ApplicationBootstrapper.cs
   public static void AddApplication(this IHostApplicationBuilder builder)
   {
       builder.UseWolverine();
       builder.UseMarten();
   }
   ```

❌ **不允许**：

```csharp
// ❌ 直接在 Program.cs 中配置
app.UseExceptionHandler();
app.UseLogging();
```

---

### Q2: 我需要在多个 Host 中共享配置，应该怎么做？

**A:**
将共享配置提取到 Platform 或 Application 的 Bootstrapper：

```csharp
// Platform/PlatformBootstrapper.cs
public static void AddPlatform(this IHostApplicationBuilder builder)
{
    // 所有 Host 共享的技术配置
    builder.AddLogging();
    builder.AddTracing();
}

// 然后在各个 Host 中使用
// Host.Web/Program.cs
builder.AddPlatform();
builder.AddApplication();

// Host.Worker/Program.cs
builder.AddPlatform();
builder.AddApplication();
```

---

### Q3: 我应该在哪一层注册 DbContext？

**A:**
取决于 DbContext 的性质：

1. **共享的技术 DbContext** → Application 层
   ```csharp
   // Application/ApplicationBootstrapper.cs
   builder.AddMarten(options => {
       // 配置 Marten
   });
   ```

2. **模块特定的 DbContext** → 模块内部
   ```csharp
   // Modules/Orders/OrdersModule.cs
   public static void AddOrdersModule(this IServiceCollection services)
   {
       services.AddDbContext<OrdersDbContext>();
   }
   ```

❌ **不允许**：

```csharp
// ❌ 不要在 Platform 中注册业务相关的 DbContext
// ❌ 不要在 Host 中直接注册 DbContext
```

---

## 五、快速检查清单

在提交 PR 前，请对照以下清单：

- [ ] Host 项目是否只引用 Application 和 Platform？
- [ ] Program.cs 是否不超过 30 行？
- [ ] Host 是否不包含业务逻辑？
- [ ] Platform 是否不依赖 Application 或 Modules？
- [ ] Application 是否不依赖 Host？
- [ ] 配置逻辑是否都封装在 Bootstrapper 中？
- [ ] 依赖方向是否正确（Host → Application → Platform）？
- [ ] 架构测试是否全部通过？

---

## 六、三层职责快速参考

| 层级              | 职责         | 允许依赖                  | 禁止                       |
|-----------------|------------|-----------------------|--------------------------|
| **Host**        | 进程外壳、协议、端口 | Application, Platform | 业务逻辑、直接引用 Modules        |
| **Application** | 模块扫描、业务装配  | Platform              | Host 类型、具体业务逻辑           |
| **Platform**    | 日志、追踪、异常处理 | 无                     | Application、Modules、业务概念 |

---

## 六、测试覆盖自检清单

### 6.1 ADR-测试映射表

| ADR 约束      | 测试方法                                                      | 测试内容                                         |
|-------------|-----------------------------------------------------------|----------------------------------------------|
| ADR-0002.1  | `Platform_Should_Not_Depend_On_Application`               | Platform 不应依赖 Application                    |
| ADR-0002.2  | `Platform_Should_Not_Depend_On_Host`                      | Platform 不应依赖 Host                           |
| ADR-0002.3  | `Platform_Should_Not_Depend_On_Modules`                   | Platform 不应依赖任何 Modules                      |
| ADR-0002.4  | `Platform_Should_Have_Single_Bootstrapper_Entry_Point`    | Platform 应有唯一的 PlatformBootstrapper 入口       |
| ADR-0002.5  | `Application_Should_Not_Depend_On_Host`                   | Application 不应依赖 Host                        |
| ADR-0002.6  | `Application_Should_Not_Depend_On_Modules`                | Application 不应依赖任何 Modules                   |
| ADR-0002.7  | `Application_Should_Have_Single_Bootstrapper_Entry_Point` | Application 应有唯一的 ApplicationBootstrapper 入口 |
| ADR-0002.8  | `Application_Should_Not_Use_HttpContext`                  | Application 不应包含 HttpContext 等 Host 专属类型     |
| ADR-0002.9  | `Host_Should_Not_Depend_On_Modules`                       | Host 不应依赖任何 Modules                          |
| ADR-0002.10 | `Host_Should_Not_Contain_Business_Types`                  | Host 不应包含业务类型                                |
| ADR-0002.11 | `Host_Csproj_Should_Not_Reference_Modules`                | Host 项目文件不应引用 Modules                        |
| ADR-0002.12 | `Program_Cs_Should_Be_Concise`                            | Program.cs 应保持简洁（≤ 50 行）                     |
| ADR-0002.13 | `Program_Cs_Should_Only_Call_Bootstrapper`                | Program.cs 只应调用 Bootstrapper                 |
| ADR-0002.14 | `Verify_Complete_Three_Layer_Dependency_Direction`        | 验证完整的三层依赖方向                                  |

### 6.2 自检问题

在提交代码前，请确认：

**Platform 层**：

- [ ] 是否只引用了技术框架包（如 Serilog、OpenTelemetry）？
- [ ] 是否没有引用 Application 或 Host？
- [ ] 是否没有引用任何业务模块？
- [ ] 是否提供了 PlatformBootstrapper.Configure() 入口？

**Application 层**：

- [ ] 是否只引用了 Platform 和业务框架包（如 Wolverine、Marten）？
- [ ] 是否没有引用 Host？
- [ ] 是否没有直接引用 Modules（通过扫描加载）？
- [ ] 是否提供了 ApplicationBootstrapper.Configure() 入口？
- [ ] 是否避免了使用 HttpContext 等 Host 类型？

**Host 层**：

- [ ] 是否只引用了 Application 和 Platform？
- [ ] 是否没有引用任何 Modules？
- [ ] Program.cs 是否少于 50 行？
- [ ] Program.cs 是否只调用 Bootstrapper？
- [ ] 是否没有包含业务逻辑？

### 6.3 如何编写符合映射要求的测试

#### 示例 1：验证 Platform 层依赖约束

```csharp
[Fact(DisplayName = "ADR-0002.1: Platform 不应依赖 Application")]
public void Platform_Should_Not_Depend_On_Application()
{
    var platformAssembly = typeof(Platform.PlatformBootstrapper).Assembly;
    var result = Types.InAssembly(platformAssembly)
        .ShouldNot().HaveDependencyOn("Zss.BilliardHall.Application")
        .GetResult();

    Assert.True(result.IsSuccessful,
        $"❌ ADR-0002.1 违规: Platform 层不应依赖 Application 层\n\n" +
        $"违规类型:\n{string.Join("\n", result.FailingTypes?.Select(t => $"  - {t.FullName}") ?? Array.Empty<string>())}\n\n" +
        $"修复建议:\n" +
        $"1. 移除 Platform 对 Application 的引用\n" +
        $"2. 将共享的技术抽象提取到 Platform 层\n" +
        $"3. 确保依赖方向正确: Host → Application → Platform\n\n" +
        $"参考: docs/copilot/adr-0002.prompts.md (场景 2)");
}
```

**关键点**：

- 测试名称包含 ADR 编号（ADR-0002.1）
- 失败消息包含清晰的 ADR 违规描述
- 提供具体的修复建议（编号列表）
- 引用相关文档

#### 示例 2：验证 Host 项目文件依赖

```csharp
[Theory(DisplayName = "ADR-0002.11: Host 项目文件不应引用 Modules")]
[MemberData(nameof(GetHostProjectFiles))]
public void Host_Csproj_Should_Not_Reference_Modules(string csprojPath)
{
    // 读取并解析 .csproj 文件
    var doc = new XmlDocument();
    doc.Load(csprojPath);
    
    // 检查项目引用
    var mgr = new XmlNamespaceManager(doc.NameTable);
    mgr.AddNamespace("msb", doc.DocumentElement!.NamespaceURI);
    var references = doc.SelectNodes("//msb:ProjectReference", mgr);
    
    // 验证不引用 Modules
    foreach (XmlNode reference in references)
    {
        var include = reference?.Attributes?["Include"]?.Value;
        if (include.Contains("Modules"))
        {
            Assert.Fail(
                $"❌ ADR-0002.11 违规: Host 项目不应直接引用 Modules\n\n" +
                $"Host 项目: {Path.GetFileName(csprojPath)}\n" +
                $"违规引用: {include}\n\n" +
                $"修复建议:\n" +
                $"1. 从 Host.csproj 中移除对 Module 项目的引用\n" +
                $"2. Host 只应引用 Application 和 Platform\n" +
                $"3. 将共享契约移到 Platform/BuildingBlocks\n\n" +
                $"参考: docs/copilot/adr-0002.prompts.md (场景 1, 反模式 4)");
        }
    }
}
```

**关键点**：

- 使用 Theory 测试多个 Host 项目
- 失败消息明确指出违规的项目和引用
- 提供逐步修复建议

### 6.4 验证脚本

运行以下命令验证所有 ADR-0002 测试：

```bash
# 运行所有 ADR-0002 测试
dotnet test --filter "FullyQualifiedName~ADR_0002"

# 运行特定约束测试
dotnet test --filter "DisplayName~ADR-0002.1"
dotnet test --filter "DisplayName~ADR-0002.5"

# 查看详细输出
dotnet test --filter "FullyQualifiedName~ADR_0002" --logger "console;verbosity=detailed"
```

### 6.5 更新提示

**何时需要更新测试**：

1. **新增 Platform 能力**
  - 确保新代码不依赖 Application/Host/Modules
  - 通过 PlatformBootstrapper 注册

2. **新增 Application 功能**
  - 确保新代码不依赖 Host
  - 不直接引用 Modules（通过扫描）
  - 通过 ApplicationBootstrapper 注册

3. **新增 Host 实例**
  - 确保只引用 Application 和 Platform
  - Program.cs 保持简洁（≤ 50 行）
  - 只调用 Bootstrapper

4. **修改依赖结构**
  - 重新运行所有 ADR-0002 测试
  - 确保三层依赖方向不变

**测试失败时的处理流程**：

```
1. 查看失败消息中的 ADR 编号
2. 参考 docs/copilot/adr-0002.prompts.md 对应场景
3. 按照修复建议逐步修复
4. 重新运行测试验证
5. 如有疑问，参考 ADR-0002 完整文档
```

---

## 七、相关资源

- [ADR-0002 完整文档](../adr/constitutional/ADR-0002-platform-application-host-bootstrap.md)
- [架构测试类](../../src/tests/ArchitectureTests/ADR/ADR_0002_Architecture_Tests.cs)
- [ADR-0001 模块化单体](../adr/constitutional/ADR-0001-modular-monolith-vertical-slice-architecture.md)

---

## 版本历史

| 版本  | 日期         | 变更说明                   |
|-----|------------|------------------------|
| 1.1 | 2026-01-21 | 添加测试覆盖自检清单（六、测试覆盖自检清单） |
| 1.0 | 2026-01-21 | 初始版本                   |
