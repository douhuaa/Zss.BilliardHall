---
title: "索引与优化"
description: "数据库性能优化策略和索引设计最佳实践"
section: "5.4"
version: "1.0.0"
author: "DBA团队"
maintainer: "性能工程师"
created: "2024-01-01"
updated: "2024-01-15"
category: "数据库设计"
level: "进阶"
audience: ["DBA", "性能工程师", "架构师"]
keywords: ["索引优化", "查询性能", "数据库调优", "执行计划", "分区策略"]
tags: ["database", "performance", "indexing", "optimization"]
status: "完成"
dependencies: ["05_数据库设计/表结构定义.md"]
related_docs: ["05_数据库设计/关键表说明.md", "05_数据库设计/数据迁移方案.md"]
reading_time: "30分钟"
difficulty: "进阶"
---

# 5.4 索引与优化

<!-- Breadcrumb Navigation -->
**导航路径**: [🏠 项目首页](../../README.md) > [📊 数据库设计](README.md) > ⚡ 索引与优化

<!-- Keywords for Search -->
**关键词**: `索引优化` `查询性能` `数据库调优` `执行计划` `分区策略`

## 概述

本文档提供了自助台球系统数据库的性能优化策略和索引设计最佳实践，基于 EF Core 和 SQL Server/MySQL 的特性进行优化。

> 💡 **相关章节**：表结构定义请参考 [5.2 表结构定义](表结构定义.md)，业务查询场景请参考 [5.3 关键表说明](关键表说明.md)。

## 索引设计策略

### 1. 主要实体索引规划

#### 球台表 (BilliardTables) 索引
```sql
-- 主键索引 (自动创建)
PK_BilliardTables (Id)

-- 业务唯一索引
CREATE UNIQUE INDEX IX_BilliardTables_Store_TableNumber 
    ON BilliardTables (StoreId, TableNumber);

-- 状态查询索引
CREATE INDEX IX_BilliardTables_Status 
    ON BilliardTables (Status) 
    INCLUDE (StoreId, TableNumber, HourlyRate);

-- 门店球台查询索引  
CREATE INDEX IX_BilliardTables_Store_Status_Type
    ON BilliardTables (StoreId, Status, Type)
    INCLUDE (TableNumber, HourlyRate, IsOnline);

-- 在线状态监控索引
CREATE INDEX IX_BilliardTables_IsOnline_LastHeartbeat
    ON BilliardTables (IsOnline, LastHeartbeatTime DESC)
    WHERE IsOnline = 0; -- 部分索引，只索引离线设备
```

#### 用户表 (Users) 索引
```sql
-- 手机号唯一索引
CREATE UNIQUE INDEX IX_Users_Phone 
    ON Users (Phone) 
    WHERE Phone IS NOT NULL;

-- 邮箱索引
CREATE INDEX IX_Users_Email
    ON Users (Email)
    WHERE Email IS NOT NULL;

-- 用户状态索引
CREATE INDEX IX_Users_Status_LastLogin
    ON Users (Status, LastLoginTime DESC)
    INCLUDE (NickName, Balance, PlayCount);

-- 活跃用户索引
CREATE INDEX IX_Users_PlayCount_TotalSpent
    ON Users (PlayCount DESC, TotalSpent DESC)
    WHERE Status = 1; -- 只索引活跃用户
```

#### 会话表 (TableSessions) 索引
```sql
-- 会话令牌唯一索引
CREATE UNIQUE INDEX IX_TableSessions_SessionToken
    ON TableSessions (SessionToken);

-- 球台会话查询索引
CREATE INDEX IX_TableSessions_Table_Status_StartTime
    ON TableSessions (TableId, Status, StartTime DESC)
    INCLUDE (UserId, PlayMinutes, FinalAmount);

-- 用户会话历史索引
CREATE INDEX IX_TableSessions_User_CreationTime
    ON TableSessions (UserId, CreationTime DESC)
    INCLUDE (TableId, PlayMinutes, FinalAmount, Status);

-- 时间范围查询索引
CREATE INDEX IX_TableSessions_StartTime_Status
    ON TableSessions (StartTime, Status)
    INCLUDE (TableId, UserId, PlayMinutes, FinalAmount);

-- 活跃会话索引
CREATE INDEX IX_TableSessions_Status_StartTime
    ON TableSessions (Status, StartTime DESC)
    WHERE Status = 1; -- 只索引进行中的会话
```

#### 支付订单表 (PaymentOrders) 索引  
```sql
-- 订单号唯一索引
CREATE UNIQUE INDEX IX_PaymentOrders_OrderNo
    ON PaymentOrders (OrderNo);

-- 第三方订单号索引
CREATE INDEX IX_PaymentOrders_ThirdPartyOrderNo
    ON PaymentOrders (ThirdPartyOrderNo)
    WHERE ThirdPartyOrderNo IS NOT NULL;

-- 用户支付历史索引
CREATE INDEX IX_PaymentOrders_User_Status_CreationTime
    ON PaymentOrders (UserId, Status, CreationTime DESC)
    INCLUDE (OrderNo, Amount, PaymentMethod);

-- 支付状态和方式索引
CREATE INDEX IX_PaymentOrders_Status_PaymentMethod_PaidTime
    ON PaymentOrders (Status, PaymentMethod, PaidTime DESC)
    INCLUDE (UserId, Amount);

-- 财务对账索引
CREATE INDEX IX_PaymentOrders_PaidTime_Status
    ON PaymentOrders (PaidTime DESC, Status)
    WHERE Status = 2; -- 只索引已支付订单
```

### 2. 设备监控表索引

#### 设备表 (Devices) 索引
```sql
-- 设备序列号唯一索引
CREATE UNIQUE INDEX IX_Devices_SerialNumber
    ON Devices (SerialNumber);

-- 门店设备查询索引
CREATE INDEX IX_Devices_Store_Type_Status
    ON Devices (StoreId, Type, Status)
    INCLUDE (SerialNumber, Name, IsOnline);

-- 设备状态监控索引
CREATE INDEX IX_Devices_Status_IsOnline_LastHeartbeat
    ON Devices (Status, IsOnline, LastHeartbeatTime DESC);

-- 球台设备关联索引
CREATE INDEX IX_Devices_Table_Type
    ON Devices (TableId, Type)
    WHERE TableId IS NOT NULL;
```

#### 设备心跳表 (DeviceHeartbeats) 索引
```sql
-- 设备心跳时序索引
CREATE INDEX IX_DeviceHeartbeats_Device_Timestamp
    ON DeviceHeartbeats (DeviceId, Timestamp DESC);

-- 时间范围查询索引
CREATE INDEX IX_DeviceHeartbeats_Timestamp
    ON DeviceHeartbeats (Timestamp DESC)
    INCLUDE (DeviceId, IsOnline);

-- 在线状态变化索引
CREATE INDEX IX_DeviceHeartbeats_IsOnline_Timestamp
    ON DeviceHeartbeats (IsOnline, Timestamp DESC);
```

## 查询优化策略

### 1. 常见查询模式优化

#### 获取门店可用球台
```sql
-- 优化前：全表扫描
SELECT * FROM BilliardTables 
WHERE StoreId = @storeId AND Status = 1;

-- 优化后：使用复合索引
-- IX_BilliardTables_Store_Status_Type 覆盖此查询
SELECT Id, TableNumber, HourlyRate, IsOnline
FROM BilliardTables WITH(INDEX(IX_BilliardTables_Store_Status_Type))
WHERE StoreId = @storeId AND Status = 1;
```

#### 用户会话历史查询
```sql
-- 优化前：排序成本高
SELECT * FROM TableSessions 
WHERE UserId = @userId 
ORDER BY StartTime DESC;

-- 优化后：利用索引排序
-- IX_TableSessions_User_CreationTime 提供排序优化
SELECT s.Id, s.TableId, s.StartTime, s.PlayMinutes, s.FinalAmount, s.Status,
       t.TableNumber
FROM TableSessions s WITH(INDEX(IX_TableSessions_User_CreationTime))
INNER JOIN BilliardTables t ON s.TableId = t.Id
WHERE s.UserId = @userId 
ORDER BY s.CreationTime DESC
OFFSET @skip ROWS FETCH NEXT @take ROWS ONLY;
```

#### 支付对账查询
```sql
-- 日支付统计查询
SELECT PaymentMethod, COUNT(*) as OrderCount, SUM(Amount) as TotalAmount
FROM PaymentOrders WITH(INDEX(IX_PaymentOrders_PaidTime_Status))
WHERE PaidTime >= @startDate 
  AND PaidTime < @endDate
  AND Status = 2  -- 已支付
GROUP BY PaymentMethod;
```

### 2. 分页查询优化

#### 基于偏移量的分页（性能较差）
```sql
-- 避免使用，特别是大偏移量
SELECT * FROM TableSessions 
ORDER BY StartTime DESC
OFFSET 10000 ROWS FETCH NEXT 20 ROWS ONLY;
```

#### 基于游标的分页（推荐）
```sql
-- 使用 Id 作为游标
SELECT TOP 20 * FROM TableSessions 
WHERE Id < @lastId
ORDER BY Id DESC;

-- 使用时间戳作为游标
SELECT TOP 20 * FROM TableSessions 
WHERE StartTime < @lastTimestamp
ORDER BY StartTime DESC;
```

### 3. EF Core 查询优化

#### 预编译查询
```csharp
private static readonly Func<BilliardHallDbContext, long, IAsyncEnumerable<BilliardTable>> 
    GetAvailableTablesQuery = EF.CompileAsyncQuery(
        (BilliardHallDbContext context, long storeId) =>
            context.BilliardTables
                .Where(t => t.StoreId == storeId && t.Status == TableStatus.Available)
                .OrderBy(t => t.TableNumber));

// 使用预编译查询
var tables = await GetAvailableTablesQuery(dbContext, storeId).ToListAsync();
```

#### 批量操作优化
```csharp
// 避免 N+1 查询问题
var sessions = await _context.TableSessions
    .Include(s => s.User)
    .Include(s => s.Table)
    .Where(s => s.Status == SessionStatus.Active)
    .ToListAsync();

// 使用 Split Query 避免笛卡尔积
var sessions = await _context.TableSessions
    .AsSplitQuery()
    .Include(s => s.PaymentOrders)
    .Include(s => s.BillingSnapshots)
    .Where(s => s.UserId == userId)
    .ToListAsync();
```

#### 原始 SQL 优化关键查询
```csharp
// 复杂统计查询使用原始 SQL
var stats = await _context.Database
    .SqlQueryRaw<DailyStatsDto>(@"
        SELECT 
            CAST(StartTime AS DATE) as Date,
            COUNT(*) as SessionCount,
            SUM(PlayMinutes) as TotalMinutes,
            SUM(FinalAmount) as TotalRevenue
        FROM TableSessions WITH(INDEX(IX_TableSessions_StartTime_Status))
        WHERE StartTime >= @startDate 
          AND StartTime < @endDate
          AND Status = 2
        GROUP BY CAST(StartTime AS DATE)
        ORDER BY Date DESC",
        new SqlParameter("@startDate", startDate),
        new SqlParameter("@endDate", endDate))
    .ToListAsync();
```

## 分区策略

### 1. 水平分区设计

#### 设备心跳表分区（按时间）
```sql
-- 创建分区函数
CREATE PARTITION FUNCTION pf_DeviceHeartbeats_Timestamp (datetime2)
AS RANGE RIGHT FOR VALUES 
    ('2024-01-01', '2024-02-01', '2024-03-01', '2024-04-01');

-- 创建分区方案
CREATE PARTITION SCHEME ps_DeviceHeartbeats_Timestamp
AS PARTITION pf_DeviceHeartbeats_Timestamp
TO (fg_2024_01, fg_2024_02, fg_2024_03, fg_current);

-- 在分区上创建表
CREATE TABLE DeviceHeartbeats (
    Id bigint IDENTITY(1,1),
    DeviceId bigint NOT NULL,
    Timestamp datetime2 NOT NULL,
    MetricsJson nvarchar(max),
    IsOnline bit NOT NULL,
    INDEX IX_DeviceHeartbeats_Device_Timestamp 
        (DeviceId, Timestamp DESC)
) ON ps_DeviceHeartbeats_Timestamp(Timestamp);
```

#### 会话历史分区
```sql
-- 按年分区存储历史会话
CREATE PARTITION FUNCTION pf_TableSessions_StartTime (datetime2)
AS RANGE RIGHT FOR VALUES 
    ('2023-01-01', '2024-01-01', '2025-01-01');

CREATE PARTITION SCHEME ps_TableSessions_StartTime
AS PARTITION pf_TableSessions_StartTime  
TO (fg_sessions_2022, fg_sessions_2023, fg_sessions_2024, fg_sessions_current);
```

### 2. 垂直分区优化

#### 用户表冷热数据分离
```sql
-- 热数据表（频繁访问）
CREATE TABLE Users_Hot (
    Id bigint PRIMARY KEY,
    Phone nvarchar(50),
    NickName nvarchar(50),
    Status int,
    Balance decimal(18,2),
    LastLoginTime datetime2
);

-- 冷数据表（归档数据）
CREATE TABLE Users_Cold (
    Id bigint PRIMARY KEY,
    Email nvarchar(100),
    Avatar nvarchar(500),
    Gender int,
    Birthday datetime2,
    TotalPlayMinutes int,
    TotalSpent decimal(18,2),
    CreationTime datetime2
);
```

## 性能监控

### 1. 关键性能指标

```sql
-- 查询执行统计
SELECT 
    qs.query_id,
    qs.plan_id,
    qs.execution_count,
    qs.avg_duration/1000.0 as avg_duration_ms,
    qs.avg_cpu_time/1000.0 as avg_cpu_time_ms,
    qs.avg_logical_io_reads,
    qt.query_sql_text
FROM sys.query_store_query_text qt
INNER JOIN sys.query_store_query q ON qt.query_text_id = q.query_text_id
INNER JOIN sys.query_store_plan p ON q.query_id = p.query_id
INNER JOIN sys.query_store_runtime_stats qs ON p.plan_id = qs.plan_id
WHERE qt.query_sql_text LIKE '%TableSessions%'
ORDER BY qs.avg_duration DESC;
```

### 2. 索引使用分析

```sql
-- 索引使用统计
SELECT 
    i.name as IndexName,
    s.user_seeks,
    s.user_scans,
    s.user_lookups,
    s.user_updates,
    s.user_seeks + s.user_scans + s.user_lookups as total_reads,
    s.user_updates as total_writes
FROM sys.dm_db_index_usage_stats s
INNER JOIN sys.indexes i ON s.object_id = i.object_id AND s.index_id = i.index_id
INNER JOIN sys.objects o ON i.object_id = o.object_id
WHERE o.name IN ('BilliardTables', 'TableSessions', 'PaymentOrders', 'Users')
  AND s.database_id = DB_ID()
ORDER BY total_reads DESC;
```

### 3. 缺失索引建议

```sql
-- 系统建议的缺失索引
SELECT 
    mid.statement,
    migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * 
        (migs.user_seeks + migs.user_scans) AS improvement_measure,
    'CREATE INDEX [missing_index_' + CONVERT(varchar, mig.index_group_handle) + 
    '_' + CONVERT(varchar, mid.index_handle) + ']' + 
    ' ON ' + mid.statement + ' (' + ISNULL(mid.equality_columns,'') + 
    CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL 
         THEN ',' ELSE '' END + ISNULL(mid.inequality_columns, '') + ')' + 
    ISNULL(' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement
FROM sys.dm_db_missing_index_groups mig
INNER JOIN sys.dm_db_missing_index_group_stats migs ON migs.group_handle = mig.index_group_handle
INNER JOIN sys.dm_db_missing_index_details mid ON mig.index_handle = mid.index_handle
WHERE mid.statement LIKE '%BilliardTables%' OR mid.statement LIKE '%TableSessions%'
ORDER BY migs.avg_total_user_cost * migs.avg_user_impact DESC;
```

## 维护最佳实践

### 1. 索引维护计划

```sql
-- 索引碎片化检查
SELECT 
    i.name as IndexName,
    ps.index_type_desc,
    ps.avg_fragmentation_in_percent,
    ps.page_count
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'DETAILED') ps
INNER JOIN sys.indexes i ON ps.object_id = i.object_id AND ps.index_id = i.index_id
WHERE ps.avg_fragmentation_in_percent > 10
  AND ps.page_count > 100
ORDER BY ps.avg_fragmentation_in_percent DESC;

-- 索引重建/重组脚本
IF @fragmentation >= 30
    ALTER INDEX @indexName ON @tableName REBUILD;
ELSE IF @fragmentation >= 10
    ALTER INDEX @indexName ON @tableName REORGANIZE;
```

### 2. 统计信息更新

```sql
-- 自动更新统计信息
ALTER DATABASE [BilliardHallDb] SET AUTO_UPDATE_STATISTICS ON;
ALTER DATABASE [BilliardHallDb] SET AUTO_UPDATE_STATISTICS_ASYNC ON;

-- 手动更新关键表统计信息
UPDATE STATISTICS BilliardTables WITH FULLSCAN;
UPDATE STATISTICS TableSessions WITH FULLSCAN;
UPDATE STATISTICS PaymentOrders WITH FULLSCAN;
```

### 3. 性能基线建立

```sql
-- 建立性能基线
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'Query Store', 1;
RECONFIGURE;

-- 启用查询存储
ALTER DATABASE [BilliardHallDb] SET QUERY_STORE = ON 
    (OPERATION_MODE = READ_WRITE, DATA_FLUSH_INTERVAL_SECONDS = 900);
```

---

## 📚 相关文档

### 同级文档
- [5.1 概念模型（ER 图）](概念模型_ER图.md)
- [5.2 表结构定义](表结构定义.md)
- [5.3 关键表说明](关键表说明.md)
- [5.5 数据迁移方案](数据迁移方案.md)
- [5.6 数据访问最佳实践](数据访问最佳实践.md)

### 返回上级
- [🔙 数据库设计总览](README.md)
- [🏠 项目首页](../../README.md)

### 相关章节
- [10. 部署与运维](../10_部署与运维/README.md)
- [9. 测试方案](../09_测试方案/README.md)
