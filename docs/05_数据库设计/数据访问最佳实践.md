# 数据访问最佳实践

## 概述

本文档整合了项目中两种主要持久化方案的开发工作流程和最佳实践：
- **Marten**：文档数据库（PostgreSQL JSON）、事件溯源
- **EF Core**：关系数据库、复杂关系查询

## 第一节：选择持久化方案

### 1.1 Marten vs EF Core 对比

| 特性 | Marten | EF Core |
|------|--------|---------|
| **数据模型** | 文档数据库（JSON） | 关系数据库 |
| **适用场景** | 聚合根、事件溯源、简单查询 | 复杂关系、报表查询、关联查询 |
| **实体定义** | POCO（无基类） | 实体基类（可选） |
| **Schema 管理** | 自动化（AutoCreate） | 迁移文件（Migrations） |
| **查询能力** | LINQ + JSON 查询 | LINQ + SQL 查询 |
| **事务支持** | 支持 | 支持 |
| **事件溯源** | ✅ 原生支持 | ❌ 需要手动实现 |
| **Wolverine 集成** | ✅ 原生集成 Outbox | ⚠️ 需要额外配置 |

### 1.2 选择建议

**使用 Marten 当**：
- ✅ 实体是独立的聚合根（如 Member、TableSession）
- ✅ 需要事件溯源能力
- ✅ 数据模型灵活，经常变化
- ✅ 需要简单的 CRUD 和查询
- ✅ 需要 Wolverine Outbox 支持

**使用 EF Core 当**：
- ✅ 需要复杂的多表关联查询
- ✅ 需要生成报表或统计
- ✅ 数据模型稳定，表关系复杂
- ✅ 需要利用关系数据库的约束能力
- ✅ 团队已有 EF Core 经验

**混合使用策略**：
```
项目可以同时使用两种方案：
- 业务核心模块：使用 Marten（Members、Sessions、Payments）
- 报表和统计：使用 EF Core 读取 Marten 生成的数据
- 配置管理：使用 EF Core（Store、PricingRule）
```

---

## 第二节：Marten 开发工作流

### 2.1 环境准备

#### 安装 PostgreSQL

```bash
# macOS
brew install postgresql@16

# Ubuntu
sudo apt-get install postgresql-16

# Docker
docker run --name postgres -e POSTGRES_PASSWORD=password -p 5432:5432 -d postgres:16
```

#### 安装 Marten NuGet 包

```bash
dotnet add package Marten
dotnet add package Marten.AspNetCore
```

#### 配置连接字符串

```json
// appsettings.json
{
  "ConnectionStrings": {
    "Postgres": "Host=localhost;Port=5432;Database=billiard_hall;Username=postgres;Password=password"
  }
}
```

### 2.2 实体定义

#### 基本实体

Marten 使用 POCO（Plain Old CLR Object），无需继承基类：

```csharp
public class Member
{
    // Marten 要求实体有 Id 属性（支持 Guid、int、long、string）
    public Guid Id { get; set; }
    
    public string Name { get; set; } = string.Empty;
    public string Phone { get; set; } = string.Empty;
    
    // 复杂类型（嵌套对象）
    public MemberProfile Profile { get; set; } = new();
    
    // 集合
    public List<string> Tags { get; set; } = new();
    
    // 枚举
    public MembershipLevel Level { get; set; }
    
    // 时间（建议使用 UTC）
    public DateTime CreatedAt { get; set; }
}

// 嵌套对象
public class MemberProfile
{
    public string Avatar { get; set; } = string.Empty;
    public Address Address { get; set; } = new();
}
```

#### 实体设计最佳实践

✅ **推荐**：
```csharp
// 使用值对象封装业务概念
public record Money(decimal Amount, string Currency = "CNY");

// 使用私有 setter 保护不变性
public class TableSession
{
    public Guid Id { get; private set; }
    public SessionStatus Status { get; private set; }
    
    public static TableSession Start(Guid tableId)
    {
        return new TableSession
        {
            Id = Guid.NewGuid(),
            TableId = tableId,
            Status = SessionStatus.Active,
            StartTime = DateTime.UtcNow
        };
    }
    
    public void End()
    {
        if (Status != SessionStatus.Active)
            throw new InvalidOperationException("只有活动会话可以结束");
        Status = SessionStatus.Ended;
    }
}
```

❌ **避免**：
```csharp
// 不要循环引用（会导致 JSON 序列化异常）
public class TableSession
{
    public Table Table { get; set; }  // ❌
}
// ✅ 使用 ID 引用
public class TableSession
{
    public Guid TableId { get; set; }  // ✅
}
```

### 2.3 Marten 配置

```csharp
// Program.cs
builder.Services.AddMarten(opts =>
{
    var connectionString = builder.Configuration.GetConnectionString("Postgres")!;
    opts.Connection(connectionString);
    
    // 配置数据库架构名称
    opts.DatabaseSchemaName = "billiard_hall";
    
    // 配置索引
    opts.Schema.For<Member>().Index(x => x.Phone);
    opts.Schema.For<TableSession>().Index(x => x.TableId);
    
    // 与 Wolverine 集成（启用 Outbox）
    opts.IntegrateWithWolverine();
    
    // 开发环境自动创建架构
    if (builder.Environment.IsDevelopment())
    {
        opts.AutoCreateSchemaObjects = AutoCreate.All;
    }
});
```

### 2.4 基本 CRUD 操作

```csharp
// Handler 注入 IDocumentSession
public class RegisterMemberHandler
{
    public async Task<Member> Handle(RegisterMember command, IDocumentSession session)
    {
        var member = new Member
        {
            Id = Guid.NewGuid(),
            Name = command.Name,
            Phone = command.Phone
        };
        
        // 插入
        session.Store(member);
        
        // ⚠️ 不需要手动 SaveChangesAsync，Wolverine [Transactional] 自动处理
        return member;
    }
}

// 查询
public async Task<Member?> GetMemberAsync(Guid id, IDocumentSession session)
{
    // 通过 ID 加载
    return await session.LoadAsync<Member>(id);
}

// 查询列表
public async Task<List<Member>> QueryMembersAsync(IDocumentSession session)
{
    return await session.Query<Member>()
        .Where(x => x.Level == MembershipLevel.Gold)
        .OrderBy(x => x.CreatedAt)
        .ToListAsync();
}

// 更新
public async Task UpdateMemberAsync(Guid id, IDocumentSession session)
{
    var member = await session.LoadAsync<Member>(id);
    if (member != null)
    {
        member.Name = "新名称";
        session.Store(member);
    }
}

// 删除
public async Task DeleteMemberAsync(Guid id, IDocumentSession session)
{
    session.Delete<Member>(id);
}
```

### 2.5 高级查询

```csharp
// 复杂条件查询
var results = await session.Query<TableSession>()
    .Where(x => x.TableId == tableId && x.Status == SessionStatus.Active)
    .OrderByDescending(x => x.StartTime)
    .Take(10)
    .ToListAsync();

// JSON 路径查询（查询嵌套属性）
var members = await session.Query<Member>()
    .Where(x => x.Profile.Address.City == "深圳")
    .ToListAsync();

// 只读查询优化（无需跟踪变化）
var members = await session.Query<Member>()
    .Where(x => x.Level == MembershipLevel.Premium)
    .ToListAsync();  // Marten 默认已优化
```

### 2.6 架构管理和迁移

#### 开发环境（自动迁移）

```csharp
// Program.cs
opts.AutoCreateSchemaObjects = AutoCreate.All;  // 开发环境自动创建
```

#### 生产环境（脚本迁移）

```bash
# 生成迁移 SQL 脚本
dotnet run --project YourProject -- marten-schema-patch > migration.sql

# 检查脚本后在生产环境执行
psql -h production-host -d billiard_hall -f migration.sql
```

### 2.7 性能优化

#### 批量操作

```csharp
// 批量插入
var members = new List<Member> { /* ... */ };
session.StoreObjects(members);
```

#### 索引优化

```csharp
// 在配置中添加索引
opts.Schema.For<Member>()
    .Index(x => x.Phone)
    .Index(x => x.Email);

opts.Schema.For<TableSession>()
    .Index(x => x.TableId)
    .Index(x => x.Status)
    .Index(x => x.StartTime);
```

### 2.8 常见问题

**Q1: 如何处理并发冲突？**
```csharp
// 使用乐观并发控制
opts.Schema.For<Member>().UseOptimisticConcurrency(true);

// 更新时检测冲突
try
{
    session.Store(member);
    await session.SaveChangesAsync();
}
catch (ConcurrencyException)
{
    // 处理冲突
}
```

**Q2: 如何实现软删除？**
```csharp
// 实体添加软删除标记
public class Member
{
    public bool IsDeleted { get; set; }
    public DateTime? DeletedAt { get; set; }
}

// 配置全局查询过滤器
opts.Schema.For<Member>()
    .AddDeletedAtIndex();  // 添加索引
    
// 查询时过滤已删除数据
var activeMembers = await session.Query<Member>()
    .Where(x => !x.IsDeleted)
    .ToListAsync();
```

---

## 第三节：EF Core 开发工作流

### 3.1 环境准备

#### 安装 EF Core 工具

```bash
# 安装 EF Core 工具
dotnet tool install --global dotnet-ef

# 验证安装
dotnet ef --version
```

#### 项目结构

```
src/
├── Domain/                       # 领域层（实体定义）
├── EntityFrameworkCore/          # 数据访问层（DbContext、配置）
├── DbMigrator/                   # 迁移工具项目
└── HttpApi.Host/                 # Web API 项目
```

#### 连接字符串配置

```json
// appsettings.json
{
  "ConnectionStrings": {
    "Default": "Server=localhost;Database=BilliardHall_Dev;Trusted_Connection=true;TrustServerCertificate=true;"
  }
}
```

### 3.2 实体定义

#### 实体基类选择

```csharp
// 完整审计实体（推荐用于业务核心实体）
public class Store : FullAuditedAggregateRoot<long>
{
    public string Name { get; set; } = string.Empty;
    // CreatedAt, UpdatedAt, DeletedAt 由基类提供
}

// 基础审计实体（用于配置类实体）
public class PricingRule : AuditedEntity<long>
{
    public decimal HourlyRate { get; set; }
}

// 简单实体（用于值对象表）
public class Address : Entity<long>
{
    public string Province { get; set; } = string.Empty;
    public string City { get; set; } = string.Empty;
}
```

#### 实体属性规范

```csharp
public class BilliardTable : FullAuditedAggregateRoot<long>
{
    // 字符串：明确长度、非空约束
    [Required]
    [StringLength(100)]
    public string Name { get; set; } = string.Empty;
    
    // 枚举：存储为字符串便于维护
    [Column(TypeName = "varchar(20)")]
    public TableStatus Status { get; set; }
    
    // 金额：使用 decimal(18, 2)
    [Column(TypeName = "decimal(18, 2)")]
    public decimal HourlyRate { get; set; }
    
    // 外键：约定命名
    public long StoreId { get; set; }
    
    // 导航属性：虚拟属性支持延迟加载
    public virtual Store Store { get; set; } = null!;
}
```

### 3.3 DbContext 配置

```csharp
public class BilliardHallDbContext : DbContext
{
    public DbSet<Store> Stores { get; set; }
    public DbSet<BilliardTable> BilliardTables { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        base.OnModelCreating(modelBuilder);
        
        // 应用所有配置
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(BilliardHallDbContext).Assembly);
        
        // 配置表前缀
        foreach (var entity in modelBuilder.Model.GetEntityTypes())
        {
            entity.SetTableName("BH_" + entity.GetTableName());
        }
    }
}

// 实体配置类
public class StoreConfiguration : IEntityTypeConfiguration<Store>
{
    public void Configure(EntityTypeBuilder<Store> builder)
    {
        builder.ToTable("BH_Stores");
        
        builder.Property(x => x.Name)
            .IsRequired()
            .HasMaxLength(100);
            
        builder.HasMany(x => x.Tables)
            .WithOne(x => x.Store)
            .HasForeignKey(x => x.StoreId)
            .OnDelete(DeleteBehavior.Restrict);
    }
}
```

### 3.4 迁移管理

#### 创建迁移

```bash
# 创建迁移
dotnet ef migrations add AddMembershipModule -p EntityFrameworkCore -s HttpApi.Host

# 查看迁移 SQL
dotnet ef migrations script -p EntityFrameworkCore -s HttpApi.Host

# 应用迁移
dotnet ef database update -p EntityFrameworkCore -s HttpApi.Host
```

#### 迁移命名规范

```bash
# 添加新功能
dotnet ef migrations add AddMembershipModule

# 修改现有结构
dotnet ef migrations add UpdateUserAddBalance

# 性能优化
dotnet ef migrations add OptimizeTableSessionIndexes
```

#### 迁移质量检查

```csharp
// ✅ 好的迁移
public partial class AddMembershipModule : Migration
{
    protected override void Up(MigrationBuilder migrationBuilder)
    {
        migrationBuilder.CreateTable(
            name: "BH_Memberships",
            columns: table => new
            {
                Id = table.Column<long>(nullable: false)
                    .Annotation("SqlServer:Identity", "1, 1"),
                // ...
            });
            
        migrationBuilder.CreateIndex(
            name: "IX_Memberships_UserId",
            table: "BH_Memberships",
            column: "UserId");
    }
}
```

### 3.5 查询优化

#### 避免 N+1 问题

```csharp
// ❌ N+1 问题
var stores = await _dbContext.Stores.ToListAsync();
foreach (var store in stores)
{
    // 每次循环触发一次查询
    var tables = store.Tables.ToList();  // ❌
}

// ✅ 使用 Include 预加载
var stores = await _dbContext.Stores
    .Include(x => x.Tables)
    .ToListAsync();

// ✅ 使用投影（只查询需要的字段）
var storeNames = await _dbContext.Stores
    .Select(x => new { x.Id, x.Name })
    .ToListAsync();
```

#### 只读查询优化

```csharp
// 只读查询使用 AsNoTracking
var tables = await _dbContext.BilliardTables
    .AsNoTracking()
    .Where(x => x.Status == TableStatus.Available)
    .ToListAsync();
```

### 3.6 数据种子

```csharp
// 在 OnModelCreating 中配置种子数据
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    base.OnModelCreating(modelBuilder);
    
    modelBuilder.Entity<Store>().HasData(
        new Store { Id = 1, Name = "总店", CreatedAt = DateTime.UtcNow }
    );
}
```

### 3.7 生产部署策略

#### 自动迁移（小型项目）

```csharp
// Program.cs
var app = builder.Build();

// 应用迁移
using (var scope = app.Services.CreateScope())
{
    var dbContext = scope.ServiceProvider.GetRequiredService<BilliardHallDbContext>();
    await dbContext.Database.MigrateAsync();
}
```

#### 手动迁移（推荐生产环境）

```bash
# 生成 SQL 脚本
dotnet ef migrations script -o migration.sql

# 在生产环境执行
sqlcmd -S server -d database -i migration.sql
```

---

## 第四节：通用最佳实践

### 4.1 Handler 直接使用持久化 API

```csharp
// ✅ Marten: Handler 直接注入 IDocumentSession
public class RegisterMemberHandler
{
    public async Task<Member> Handle(RegisterMember command, IDocumentSession session)
    {
        var member = new Member { /* ... */ };
        session.Store(member);
        return member;  // Wolverine [Transactional] 自动保存
    }
}

// ✅ EF Core: Handler 直接注入 DbContext
public class CreateStoreHandler
{
    public async Task<Store> Handle(CreateStore command, BilliardHallDbContext dbContext)
    {
        var store = new Store { /* ... */ };
        dbContext.Stores.Add(store);
        // Wolverine [Transactional] 自动 SaveChangesAsync
        return store;
    }
}

// ❌ 不要创建 Repository 抽象层
```

### 4.2 异常处理

```csharp
// 数据库唯一约束冲突 → 翻译成业务错误
public async Task<Result<Member>> Handle(RegisterMember command, IDocumentSession session)
{
    // 检查手机号是否已存在
    var exists = await session.Query<Member>()
        .AnyAsync(x => x.Phone == command.Phone);
    
    if (exists)
    {
        return Result.Fail("Members:PhoneExists", "手机号已被注册");
    }
    
    // ...
}
```

### 4.3 批量查询优化

```csharp
// ✅ 使用 AnyAsync() 检查存在性
var exists = await session.Query<Member>()
    .AnyAsync(x => x.Phone == phone);

// ❌ 不要使用 Count() > 0
var count = await session.Query<Member>()
    .CountAsync(x => x.Phone == phone);  // ❌ 性能差
```

### 4.4 事务处理

```csharp
// Wolverine Handler 使用 [Transactional] 自动事务
[Transactional]
public class CompletePaymentHandler
{
    public async Task Handle(CompletePayment command, IDocumentSession session)
    {
        var payment = await session.LoadAsync<Payment>(command.PaymentId);
        payment.Complete();
        session.Store(payment);
        
        // 所有操作在同一事务中
        // SaveChanges 由 Wolverine 自动调用
    }
}
```

---

## 附录：快速参考

### Marten 常用 API

```csharp
// 插入/更新
session.Store(entity);
session.StoreObjects(entities);

// 查询
await session.LoadAsync<T>(id);
await session.Query<T>().Where(...).ToListAsync();

// 删除
session.Delete<T>(id);
session.DeleteWhere<T>(x => x.Status == "Inactive");
```

### EF Core 常用 API

```csharp
// 插入
dbContext.Add(entity);
dbContext.AddRange(entities);

// 查询
await dbContext.Set<T>().FindAsync(id);
await dbContext.Set<T>().Where(...).ToListAsync();

// 更新
dbContext.Update(entity);

// 删除
dbContext.Remove(entity);
```

### 迁移命令速查

```bash
# Marten
dotnet run -- marten-schema-patch > migration.sql

# EF Core
dotnet ef migrations add <Name> -p <Project> -s <Startup>
dotnet ef migrations script -o migration.sql
dotnet ef database update
```

---

**版本**: 1.0.0  
**维护者**: 架构团队  
**最后更新**: 2026-01-13
