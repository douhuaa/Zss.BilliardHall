# 架构违规记录表（Architecture Violations Registry）

**目的**：记录所有架构破例，确保可追溯和可审计  
**维护责任**：架构师团队  
**更新频率**：每次批准破例时立即更新  

---

## 使用说明

1. **所有破例必须记录**：任何违反 ADR-0000 至 ADR-0005 的行为都必须在此记录
2. **记录即审批**：记录在此表中的破例视为已批准
3. **未记录的破例**：如果违规未记录，视为未授权违规，必须立即修复
4. **定期审计**：每季度审计一次，检查破例是否已归还

---

## 当前活跃破例（Active Violations）

> 这些是当前系统中存在的架构破例，尚未归还

| ID | 违反的 ADR | 违规描述 | 影响范围 | 批准人 | 批准日期 | 计划归还日期 | 状态 |
|----|-----------|---------|---------|--------|---------|------------|------|
| ARCH-001 | ADR-0005 | [示例] Members 模块同步调用 Orders 模块查询会员积分 | Members/Features/CreateOrder | @architect | 2026-01-15 | 2026-02-15 | 🟡 进行中 |

**ID**: ARCH-001  
**违反的 ADR**: ADR-0005（模块间应异步通信）  
**违规详情**：  
```
Members 模块的 CreateOrderHandler 中直接注入了 Orders 模块的 IPointsQuery，
进行同步查询以验证会员积分是否足够。

违反了"模块间默认异步"的原则。
```

**理由**：  
创建订单时需要实时验证积分，异步方案会导致用户体验下降（需等待事件传播）。

**已评估的替代方案**：
1. 通过事件查询 - 不可行，延迟不可接受
2. 在 Application 层编排 - 不可行，Application 不应依赖 Modules

**影响范围**：
- 模块：Members、Orders
- 文件：`Members/Features/CreateOrder/CreateOrderHandler.cs`

**缓解措施**：
- 将 IPointsQuery 定义为 Platform.Contracts 中的契约接口
- 明确标记为"临时同步调用，待优化"
- 设置超时和降级策略

**归还计划**：
1. 实现积分数据的本地缓存（Read Model）
2. 通过事件保持缓存同步
3. 将同步调用替换为本地缓存查询

**负责人**：@developer-name  
**审批人**：@architect-name  
**审批日期**：2026-01-15  
**计划归还日期**：2026-02-15  

**状态更新**：
- 2026-01-15: 破例批准，开始实施
- 2026-01-20: 本地缓存设计完成，待实现

---

## 已归还破例（Resolved Violations）

> 这些破例已经被修复，记录在此作为历史审计

| ID | 违反的 ADR | 违规描述 | 批准日期 | 归还日期 | 归还方式 |
|----|-----------|---------|---------|---------|---------|
| ARCH-000 | ADR-0001 | [示例] 初始版本中 Members 模块引用了 Orders 模块 | 2025-12-01 | 2025-12-15 | 将共享契约移到 Platform.Contracts |

**ID**: ARCH-000  
**违反的 ADR**: ADR-0001（模块隔离）  
**违规详情**：  
初始版本中 Members 模块直接引用了 Orders 模块，用于获取会员的订单历史。

**归还方式**：
1. 创建 `Platform.Contracts.Orders.MemberOrderHistoryDto`
2. Orders 模块实现查询接口
3. Members 模块通过 Platform 层契约调用

**归还日期**：2025-12-15  
**验证**：架构测试 ADR-0001.1 通过

---

## 永久破例（Permanent Exceptions）

> 这些是经过架构委员会批准的永久性破例，不需要归还

| ID | 违反的 ADR | 违规描述 | 批准人 | 批准日期 | 理由 |
|----|-----------|---------|--------|---------|------|
| - | - | 目前无永久破例 | - | - | - |

**说明**：永久破例需要架构委员会全体成员一致同意，且必须记录充分的理由。

---

## 被拒绝的破例申请（Rejected Exceptions）

> 这些破例申请被拒绝，记录在此作为决策参考
> 
> **重要**：公开拒绝案例是防止"违规白名单"的关键机制。
> 不是所有申请都会通过，这个列表让团队看到架构委员会的决策标准。

| ID | 违反的 ADR | 申请描述 | 申请人 | 申请日期 | 拒绝理由 | 替代方案 |
|----|-----------|---------|--------|---------|---------|---------|
| ARCH-REJ-001 | ADR-0005 | [示例] 请求允许 Endpoint 直接查询数据库 | @developer | 2026-01-10 | 违反职责分离原则 | 创建 QueryHandler |
| ARCH-REJ-002 | ADR-0001 | [示例] 请求 Members 模块直接引用 Orders 模块 | @developer | 2026-01-12 | 破坏模块隔离 | 通过 Platform.Contracts |
| ARCH-REJ-003 | ADR-0002 | [示例] 请求在 Program.cs 中添加环境判断逻辑 | @developer | 2026-01-15 | Program.cs 应保持简洁 | 移到 Bootstrapper |

---

### 详细案例

**ID**: ARCH-REJ-001  
**违反的 ADR**: ADR-0005（Endpoint 不应包含业务逻辑）  
**申请描述**：  
希望在 Endpoint 中直接注入 DbContext 查询会员列表，理由是"这只是简单的查询，不需要 Handler"。

**拒绝理由**：
1. 即使是简单查询，也应该通过 QueryHandler 执行
2. Endpoint 直接依赖 DbContext 会破坏测试隔离
3. 未来查询可能变复杂，届时重构成本高

**替代方案**：
创建 `GetMembersQueryHandler`，Endpoint 通过 Mediator 调用。

**拒绝人**：@architect  
**拒绝日期**：2026-01-10

---

**ID**: ARCH-REJ-002  
**违反的 ADR**: ADR-0001（模块隔离）  
**申请描述**：  
希望 Members 模块直接引用 Orders 模块以获取会员订单统计，理由是"只读取数据，不修改"。

**拒绝理由**：
1. 只读引用仍然是依赖，会造成模块耦合
2. 未来 Orders 模块的变更会影响 Members 模块
3. 违反了模块隔离的核心原则

**替代方案**：
1. 将共享的查询 DTO 移到 `Platform.Contracts.Orders`
2. Orders 模块实现查询接口，Members 通过契约调用
3. 或者 Orders 发布领域事件，Members 维护本地投影

**拒绝人**：@architect  
**拒绝日期**：2026-01-12

---

**ID**: ARCH-REJ-003  
**违反的 ADR**: ADR-0002（Program.cs 简洁性）  
**申请描述**：  
希望在 Program.cs 中添加 `if (env.IsDevelopment())` 判断以加载开发环境专用配置。

**拒绝理由**：
1. 环境判断逻辑应该封装在 Bootstrapper 内部
2. Program.cs 应该只是"启动入口"，不包含任何业务判断
3. 允许这种做法会导致 Program.cs 逐渐膨胀

**替代方案**：
在 `PlatformBootstrapper.Configure()` 方法内部进行环境判断：
```csharp
public static void Configure(IServiceCollection services, IConfiguration config)
{
    var env = services.BuildServiceProvider().GetRequiredService<IHostEnvironment>();
    if (env.IsDevelopment())
    {
        // 开发环境配置
    }
}
```

**拒绝人**：@architect  
**拒绝日期**：2026-01-15

---

## 破例统计（Violation Statistics）

### 当前状态（2026-01-20）

- 活跃破例：1
- 已归还破例：1
- 永久破例：0
- 被拒绝申请：1

### 趋势分析

| 月份 | 新增破例 | 归还破例 | 净增长 |
|------|---------|---------|--------|
| 2025-12 | 1 | 0 | +1 |
| 2026-01 | 0 | 1 | -1 |

**健康指标**：
- ✅ 破例数量下降趋势
- ✅ 平均归还时长：15 天
- ⚠️ 需关注：新增破例速率

---

## 破例申请流程

### 1. 提交申请

在 PR 中填写架构违规声明部分（见 `.github/PULL_REQUEST_TEMPLATE.md`）

### 2. 初步审查

架构师进行初步审查：
- 是否有充分理由？
- 是否评估过替代方案？
- 是否有归还计划？

### 3. 架构委员会审批

- 临时破例（< 1 个月）：架构师单独批准
- 短期破例（1-3 个月）：需至少 2 位架构师批准
- 长期破例（> 3 个月）：需架构委员会全体批准
- 永久破例：需架构委员会一致同意

### 4. 记录归档

批准后，架构师负责将破例记录在本文档中。

### 5. 定期审计

每季度审计一次：
- 检查已归还破例是否真正修复
- 检查未归还破例是否超期
- 评估破例趋势，决定是否需要修订 ADR

---

## 常见问题

### Q: 什么情况下需要申请破例？

A: 当你的代码无法通过 `dotnet test src/tests/ArchitectureTests` 时，或者你明知违反了 ADR-0000 至 ADR-0005 的约束。

### Q: 破例申请会被拒绝吗？

A: 会。如果有更好的替代方案，或者破例会导致长期技术债务，申请会被拒绝。

### Q: 可以先实现，后补申请吗？

A: 不可以。所有破例必须**先申请、后实现**。未经批准的违规会被要求立即修复。

### Q: 破例记录会被删除吗？

A: 不会。即使破例已归还，记录也会永久保留在"已归还破例"部分，作为历史审计依据。

---

## 审计历史

| 审计日期 | 审计人 | 发现问题 | 处理结果 |
|---------|--------|---------|---------|
| 2026-01-20 | @architect | 无 | 系统健康 |

---

**最后更新**：2026-01-20  
**维护人**：@architect-name  
**下次审计**：2026-04-20
