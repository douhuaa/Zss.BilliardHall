# 领域异常处理规范

> 版本：v1.0.0  
> 更新时间：2026-01-14

## 概述

本文档定义了 Zss.BilliardHall 项目中领域异常处理的统一规范，基于以下四个优化维度：

1. **异常建模**：让异常能表达"这是哪个 Bounded Context 的哪个业务错误"
2. **错误码与本地化**：错误码稳定，文案可本地化、可替换
3. **跨模块一致性**：Members / Tables / Sessions 等模块用同一套约定
4. **与 Wolverine + Marten 垂直切片对齐**：异常只在"应用边界"转换一次

---

## 核心概念

### 1. 错误描述符（ErrorDescriptor）

`ErrorDescriptor` 是新的错误表达方式，取代简单的错误码字符串：

```csharp
public sealed record ErrorDescriptor
{
    /// <summary>错误码：格式 {Module}:{Category}.{Specific}</summary>
    public string Code { get; }
    
    /// <summary>错误类别（NotFound, Validation, Business, Conflict, Forbidden）</summary>
    public ErrorCategory Category { get; }
    
    /// <summary>所属模块/领域上下文（Members, Tables, Sessions）</summary>
    public string Module { get; }
    
    /// <summary>默认错误消息（中文）</summary>
    public string DefaultMessage { get; }
    
    /// <summary>附加上下文数据（用于消息模板参数）</summary>
    public IReadOnlyDictionary<string, object>? Context { get; init; }
}
```

**错误码格式**：`{Module}:{Category}.{Specific}`

示例：
- `Members:Validation.InvalidTopUpAmount` - 会员模块，验证类错误，充值金额无效
- `Members:Business.InsufficientBalance` - 会员模块，业务规则错误，余额不足
- `Tables:NotFound.Table` - 台球桌模块，资源未找到，台球桌不存在

### 2. 错误类别（ErrorCategory）

```csharp
public enum ErrorCategory
{
    NotFound,        // 资源未找到 → HTTP 404
    Validation,      // 输入验证失败 → HTTP 400
    Business,        // 业务规则违反 → HTTP 422
    Conflict,        // 资源冲突 → HTTP 409
    Forbidden,       // 权限不足 → HTTP 403
    InvalidStatus    // 无效状态 → HTTP 409
}
```

### 3. 模块领域异常（ModuleDomainException）

每个模块可以定义自己的领域异常：

```csharp
public abstract class ModuleDomainException : Exception
{
    public ErrorDescriptor ErrorDescriptor { get; }
    public string Code => ErrorDescriptor.Code;
    public ErrorCategory Category => ErrorDescriptor.Category;
    public string Module => ErrorDescriptor.Module;
}
```

---

## 使用指南

### 1. 定义模块错误描述符

在模块内创建 `{Module}ErrorDescriptors.cs`，定义所有错误：

```csharp
// Modules/Members/MemberErrorDescriptors.cs
internal static class MemberErrorDescriptors
{
    private const string ModuleName = "Members";

    // NotFound errors
    public static ErrorDescriptor MemberNotFound(Guid memberId) =>
        ErrorCodeBuilder.ForModule(ModuleName)
            .WithCode($"{ModuleName}:NotFound.Member")
            .WithCategory(ErrorCategory.NotFound)
            .WithMessage("会员不存在: {MemberId}")
            .AddContext("MemberId", memberId)
            .Build();

    // Validation errors
    public static ErrorDescriptor InvalidTopUpAmount(decimal amount) =>
        ErrorCodeBuilder.ForModule(ModuleName)
            .WithCode($"{ModuleName}:Validation.InvalidTopUpAmount")
            .WithCategory(ErrorCategory.Validation)
            .WithMessage("充值金额必须大于0，实际: {Amount:F2}")
            .AddContext("Amount", amount)
            .Build();

    // Business rule errors
    public static ErrorDescriptor InsufficientBalance(decimal required, decimal available) =>
        ErrorCodeBuilder.ForModule(ModuleName)
            .WithCode($"{ModuleName}:Business.InsufficientBalance")
            .WithCategory(ErrorCategory.Business)
            .WithMessage("余额不足，需要: {Required:F2}，可用: {Available:F2}")
            .AddContext("Required", required)
            .AddContext("Available", available)
            .Build();
}
```

**命名约定**：
- 文件名：`{Module}ErrorDescriptors.cs`（internal static class）
- 方法名：描述性英文，参数化（如 `MemberNotFound(Guid id)`）
- 错误码：`{Module}:{Category}.{Specific}`

### 2. 在聚合根中使用

```csharp
public class Member
{
    public DomainResult TopUp(decimal amount)
    {
        if (amount <= 0)
            return DomainResult.Fail(
                MemberErrorDescriptors.InvalidTopUpAmount(amount));

        Balance += amount;
        return DomainResult.Success();
    }

    public DomainResult Deduct(decimal amount)
    {
        if (amount <= 0)
            return DomainResult.Fail(
                MemberErrorDescriptors.InvalidDeductAmount(amount));

        if (Balance < amount)
            return DomainResult.Fail(
                MemberErrorDescriptors.InsufficientBalance(amount, Balance));

        Balance -= amount;
        return DomainResult.Success();
    }
}
```

**原则**：
- ✅ 聚合根方法返回 `DomainResult`，不抛出异常
- ✅ 使用 `ErrorDescriptor` 描述失败原因
- ✅ 包含相关上下文（如金额、余额）
- ❌ 不在聚合根中硬编码错误消息

### 3. 在 Handler 中处理

```csharp
public sealed class TopUpBalanceHandler
{
    [Transactional]
    public async Task<(Result Result, BalanceToppedUp? Event)> Handle(
        TopUpBalance command,
        IDocumentSession session,
        ILogger<TopUpBalanceHandler> logger,
        CancellationToken ct = default)
    {
        // 1. 加载聚合根
        var member = await session.LoadAsync<Member>(command.MemberId, ct);
        if (member == null)
        {
            var error = MemberErrorDescriptors.MemberNotFound(command.MemberId);
            logger.LogWarning(
                "充值失败: {ErrorCode}, {Message}",
                error.Code,
                error.FormatMessage()
            );
            return (Result.Fail(error.FormatMessage(), error.Code), null);
        }

        // 2. 调用领域方法
        var domainResult = member.TopUp(command.Amount);
        if (!domainResult.IsSuccess)
        {
            // 使用统一的异常处理器转换 DomainResult
            var (result, _) = DomainExceptionHandler.ToResult(domainResult, logger);
            return (result, null);
        }

        // 3. 持久化并返回事件
        session.Store(member);
        var @event = new BalanceToppedUp(...);
        
        logger.LogInformation(
            "会员充值成功: {MemberId}, 金额: {Amount:F2}",
            member.Id,
            command.Amount
        );

        return (Result.Success(), @event);
    }
}
```

**原则**：
- ✅ Handler 使用 `DomainExceptionHandler.ToResult()` 统一转换
- ✅ 记录结构化日志（包含错误码和上下文）
- ✅ 返回 `Result` 而不是抛出异常
- ❌ 不在 Handler 中使用 switch-case 映射错误消息（已由 ErrorDescriptor 处理）

### 4. 在 Endpoint 中处理（可选）

Endpoint 通常只做转发，由 Handler 返回的 `Result` 已经包含了正确的错误信息：

```csharp
public sealed class TopUpBalanceEndpoint
{
    [WolverinePost("/api/members/{memberId:guid}/topup")]
    public static async Task<IResult> Post(
        Guid memberId,
        TopUpBalanceRequest request,
        IMessageBus bus)
    {
        var command = new TopUpBalance(memberId, request.Amount, request.PaymentMethod);
        var result = await bus.InvokeAsync<Result>(command);

        return result.IsSuccess
            ? Results.Ok(new { message = "充值成功" })
            : Results.BadRequest(new { error = result.Error, code = result.ErrorCode });
    }
}
```

---

## 跨模块一致性

### 错误码命名规范

| 模块 | NotFound | Validation | Business | Conflict |
|------|----------|------------|----------|----------|
| Members | `Members:NotFound.Member` | `Members:Validation.InvalidTopUpAmount` | `Members:Business.InsufficientBalance` | `Members:Conflict.DuplicatePhone` |
| Tables | `Tables:NotFound.Table` | `Tables:Validation.InvalidCapacity` | `Tables:Business.TableOccupied` | `Tables:Conflict.DuplicateNumber` |
| Sessions | `Sessions:NotFound.Session` | `Sessions:Validation.InvalidDuration` | `Sessions:Business.SessionEnded` | `Sessions:Conflict.ActiveSessionExists` |

### 错误类别使用指南

| 类别 | 使用场景 | HTTP 状态码 | 日志级别 |
|------|---------|------------|---------|
| **NotFound** | 资源不存在（如会员、台球桌） | 404 | Warning |
| **Validation** | 输入参数验证失败（如金额 ≤ 0） | 400 | Warning |
| **Business** | 业务规则违反（如余额不足） | 422 | Information |
| **Conflict** | 资源冲突（如手机号重复） | 409 | Warning |
| **Forbidden** | 权限不足 | 403 | Warning |
| **InvalidStatus** | 状态不符合预期 | 409 | Warning |

---

## 本地化支持

### 消息模板

`ErrorDescriptor` 的 `DefaultMessage` 支持占位符（`{Key}`）：

```csharp
.WithMessage("余额不足，需要: {Required:F2}，可用: {Available:F2}")
.AddContext("Required", 150.00m)
.AddContext("Available", 100.00m)
```

调用 `FormatMessage()` 时自动替换：

```csharp
errorDescriptor.FormatMessage()
// 输出: "余额不足，需要: 150.00，可用: 100.00"
```

### 未来扩展：多语言支持

可以通过资源文件或数据库实现：

```csharp
public interface IErrorMessageProvider
{
    string GetMessage(string errorCode, string culture, IReadOnlyDictionary<string, object>? context);
}

// 使用示例
var message = messageProvider.GetMessage(
    "Members:Business.InsufficientBalance",
    "en-US",
    new Dictionary<string, object> { ["Required"] = 150.00m, ["Available"] = 100.00m }
);
// 输出: "Insufficient balance, required: 150.00, available: 100.00"
```

---

## 与 Wolverine 架构对齐

### 单一转换点原则

异常只在**应用边界**（Handler → Result）转换一次：

```
┌─────────────┐
│  Aggregate  │ → DomainResult
└─────────────┘
       ↓
┌─────────────┐
│   Handler   │ → Result (via DomainExceptionHandler.ToResult)
└─────────────┘
       ↓
┌─────────────┐
│  Endpoint   │ → IResult (HTTP Response)
└─────────────┘
```

**禁止**：
- ❌ 在 Aggregate 中抛出异常（使用 `DomainResult`）
- ❌ 在 Handler 中使用 try-catch 包裹领域逻辑
- ❌ 在 Endpoint 中重新映射错误消息

**允许**：
- ✅ 在 Aggregate 中返回 `DomainResult`
- ✅ 在 Handler 中使用 `DomainExceptionHandler.ToResult()` 转换
- ✅ 在 Endpoint 中直接返回 Handler 的 `Result`

### DomainExceptionHandler 工具类

```csharp
public static class DomainExceptionHandler
{
    /// <summary>
    /// 将 DomainResult 转换为 Result 和 HTTP 状态码
    /// </summary>
    public static (Result Result, int StatusCode) ToResult(
        DomainResult domainResult,
        ILogger logger)
    {
        if (!domainResult.IsSuccess && domainResult.ErrorDescriptor != null)
        {
            var descriptor = domainResult.ErrorDescriptor;
            
            // 自动记录日志
            logger.LogWarning(
                "领域规则违反: {Module}:{Category}, 错误码: {Code}",
                descriptor.Module,
                descriptor.Category,
                descriptor.Code
            );

            // 自动映射 HTTP 状态码
            var statusCode = descriptor.Category switch
            {
                ErrorCategory.NotFound => 404,
                ErrorCategory.Validation => 400,
                ErrorCategory.Business => 422,
                ErrorCategory.Conflict => 409,
                ErrorCategory.Forbidden => 403,
                _ => 400
            };

            return (Result.Fail(descriptor.FormatMessage(), descriptor.Code), statusCode);
        }

        return (Result.Success(), 200);
    }
}
```

---

## 测试指南

### 单元测试（聚合根）

```csharp
[Fact]
public void TopUp_WithZeroAmount_ShouldFail()
{
    // Arrange
    var member = CreateMember(balance: 100m);

    // Act
    var result = member.TopUp(0m);

    // Assert
    result.IsSuccess.Should().BeFalse();
    result.ErrorDescriptor.Should().NotBeNull();
    result.ErrorDescriptor!.Code.Should().Be("Members:Validation.InvalidTopUpAmount");
    result.ErrorDescriptor.Category.Should().Be(ErrorCategory.Validation);
    result.ErrorDescriptor.FormatMessage().Should().Contain("充值金额必须大于0");
}

[Fact]
public void Deduct_WithInsufficientBalance_ShouldFail()
{
    // Arrange
    var member = CreateMember(balance: 100m);

    // Act
    var result = member.Deduct(150m);

    // Assert
    result.IsSuccess.Should().BeFalse();
    result.ErrorDescriptor!.Code.Should().Be("Members:Business.InsufficientBalance");
    result.ErrorDescriptor.Category.Should().Be(ErrorCategory.Business);
    result.ErrorDescriptor.Context.Should().ContainKey("Required");
    result.ErrorDescriptor.Context.Should().ContainKey("Available");
}
```

### 集成测试（Handler）

```csharp
[Fact]
public async Task Handle_WithNonExistentMember_ShouldReturnNotFoundError()
{
    // Arrange
    var command = new TopUpBalance(Guid.NewGuid(), 100m, "Cash");

    // Act
    var (result, _) = await handler.Handle(command, session, logger);

    // Assert
    result.IsSuccess.Should().BeFalse();
    result.ErrorCode.Should().Be("Members:NotFound.Member");
}
```

---

## 向后兼容

旧版 `ErrorCode` 标记为 `[Obsolete]`，但仍可使用：

```csharp
// 旧版（已废弃）
return DomainResult.Fail(MemberErrorCodes.InvalidTopUpAmount);

// 新版（推荐）
return DomainResult.Fail(MemberErrorDescriptors.InvalidTopUpAmount(amount));
```

`DomainExceptionHandler.ToResult()` 同时支持新旧格式，确保平滑迁移。

---

## 迁移检查清单

从旧版错误处理迁移到新版：

- [ ] 创建 `{Module}ErrorDescriptors.cs` 文件
- [ ] 定义所有错误描述符（遵循命名规范）
- [ ] 更新聚合根方法使用 `ErrorDescriptor`
- [ ] 更新 Handler 使用 `DomainExceptionHandler.ToResult()`
- [ ] 更新单元测试断言 `ErrorDescriptor` 属性
- [ ] 移除 Handler 中的 switch-case 错误消息映射
- [ ] （可选）移除旧版 `{Module}ErrorCodes.cs` 文件

---

## 常见问题

### Q1: 什么时候使用异常，什么时候使用 DomainResult？

**A**: 在 Wolverine 垂直切片架构中：
- ✅ **业务规则违反**：使用 `DomainResult`（如余额不足、金额无效）
- ✅ **资源未找到**：Handler 中返回 `Result.Fail`（不是异常）
- ❌ **技术异常**：可以抛出（如数据库连接失败），由框架处理

### Q2: ErrorDescriptor 和旧版 ErrorCode 有什么区别？

**A**: 
- `ErrorCode`：简单的字符串包装（如 `"Member.InvalidTopUpAmount"`）
- `ErrorDescriptor`：包含类别、模块、消息模板、上下文数据，支持本地化

### Q3: 如何处理跨模块错误？

**A**: 每个模块定义自己的 `ErrorDescriptors`，跨模块通信通过事件，不直接抛出异常。

### Q4: 能否在 BuildingBlocks 中定义通用错误？

**A**: **不建议**。根据垂直切片原则，错误应该表达特定模块的业务语义。
- ❌ 错误：`BuildingBlocks.Errors.NotFound`（太抽象）
- ✅ 正确：`Members:NotFound.Member`（明确上下文）

---

## 参考资料

- [代码风格规范](./代码风格.md) - 异常处理基础规范
- [Wolverine 端点约定](./Wolverine端点约定.md) - Endpoint 异常处理
- [级联消息与副作用](./级联消息与副作用.md) - Handler 返回值约定
- [切片约束](./切片约束.md) - 垂直切片架构原则

---

## 版本历史

- **v1.0.0** (2026-01-14): 初始版本，定义四维优化规范
