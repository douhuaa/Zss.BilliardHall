# 切片约束

## 1. 概述

本文档定义垂直切片架构下的代码组织约束和最佳实践，替代传统分层架构中的分层约束规则。

## 2. 核心约束

### 2.1 切片独立性约束

**规则**: 每个切片应该是自包含的，包含实现该功能所需的全部代码。

**✅ 允许**:
```csharp
Features/
  Members/
    CreateMember/
      CreateMemberCommand.cs       # 命令
      CreateMemberHandler.cs       # 处理器
      CreateMemberValidator.cs     # 验证
      MemberCreatedEvent.cs        # 事件
```

**❌ 禁止**:
```csharp
// 不要按技术层次组织
Commands/
  CreateMemberCommand.cs
Handlers/
  CreateMemberHandler.cs
Validators/
  CreateMemberValidator.cs
```

### 2.2 切片间通信约束

**规则**: 切片间不能直接调用，只能通过消息总线通信。

**✅ 允许**:
```csharp
// 通过消息总线发送命令
public class EndSessionHandler
{
    public async Task Handle(EndSessionCommand cmd, IMessageBus bus)
    {
        // 结束会话逻辑...
        
        // 通过消息总线触发计费
        await bus.InvokeAsync(new CalculateBillingCommand(sessionId));
    }
}

// 通过事件通知
public class PaymentCompletedHandler
{
    public async Task Handle(PaymentCompletedCommand cmd, IMessageBus bus)
    {
        // 支付逻辑...
        
        // 发布事件
        await bus.PublishAsync(new PaymentCompletedEvent(orderId));
    }
}
```

**❌ 禁止**:
```csharp
// 不要直接调用其他切片的处理器
public class EndSessionHandler
{
    private readonly CalculateBillingHandler _billingHandler;
    
    public EndSessionHandler(CalculateBillingHandler billingHandler)
    {
        _billingHandler = billingHandler;
    }
    
    public async Task Handle(EndSessionCommand cmd)
    {
        // ❌ 不要这样做
        await _billingHandler.Handle(new CalculateBillingCommand(sessionId));
    }
}

// 不要直接查询其他切片的内部状态
public class SomeHandler
{
    private readonly IDocumentSession _session;
    
    public async Task Handle(SomeCommand cmd)
    {
        // ❌ 不要跨切片直接查询其他切片的私有内部数据
        // 注意：这里的 OtherSliceData 是指切片特有的内部数据类型
        // 如果是 Domain/ 目录下的共享领域实体，则可以访问
        var otherData = await _session.LoadAsync<OtherSliceData>(id);
    }
}
```

**例外**: 可以访问共享的领域实体（在 Domain/ 目录下）。例如，访问 `Domain/Entities/Member.cs` 或 `Domain/Entities/Table.cs` 是允许的。

### 2.3 数据访问约束

**规则**: 每个切片直接使用 `IDocumentSession`，不使用仓储模式。

**✅ 允许**:
```csharp
public class GetMemberByIdHandler
{
    public async Task<Member?> Handle(
        GetMemberByIdQuery query,
        IDocumentSession session)  // ✅ 直接注入 IDocumentSession
    {
        return await session.LoadAsync<Member>(query.Id);
    }
}
```

**❌ 禁止**:
```csharp
// 不要创建仓储层
public interface IMemberRepository
{
    Task<Member?> GetByIdAsync(Guid id);
}

public class MemberRepository : IMemberRepository
{
    // ❌ 不需要仓储抽象
}

public class GetMemberByIdHandler
{
    private readonly IMemberRepository _repository;  // ❌
    
    public GetMemberByIdHandler(IMemberRepository repository)
    {
        _repository = repository;
    }
}
```

**例外**: 如果确实需要封装复杂的数据访问逻辑，可以创建查询服务（在 Domain/Services 下）。

## 3. 命名约束

### 3.1 切片命名

**规则**: 切片名称 = 动词 + 名词

**示例**:
```
✅ CreateMember
✅ UpdateMemberProfile
✅ GetMemberById
✅ SearchMembers
✅ StartSession
✅ EndSession
✅ ProcessPayment
✅ RefundPayment

❌ Member（太宽泛）
❌ MemberManagement（不是具体功能）
❌ MemberService（技术术语）
```

### 3.2 命令命名

**规则**: 
- 命令：动词 + 名词 + `Command`
- 事件：名词 + 动词过去式 + `Event`
- 查询：Get/Find/Search + 名词 + `Query`

**示例**:
```csharp
// 命令
public record CreateMemberCommand(...);
public record UpdateMemberProfileCommand(...);
public record StartSessionCommand(...);

// 事件
public record MemberCreatedEvent(...);
public record SessionStartedEvent(...);
public record PaymentCompletedEvent(...);

// 查询
public record GetMemberByIdQuery(Guid Id);
public record SearchMembersQuery(string Keyword, int Page);
public record FindActiveSessionsQuery(DateTime StartDate);
```

### 3.3 处理器命名

**规则**: 切片名 + `Handler`

**示例**:
```csharp
public class CreateMemberHandler { }
public class UpdateMemberProfileHandler { }
public class GetMemberByIdHandler { }
```

## 4. 文件组织约束

### 4.1 目录结构

**标准结构**:
```
src/Zss.BilliardHall/
  Features/                      # 所有功能切片
    {Domain}/                    # 业务领域（复数）
      {Feature}/                 # 功能切片（动词+名词）
        {Feature}Command.cs      # 命令（或 Query）
        {Feature}Handler.cs      # 处理器
        {Feature}Validator.cs    # 验证（可选）
        {Feature}Tests.cs        # 测试（可选）
        {Event}Event.cs          # 事件（可选）
  Domain/                        # 共享领域
    Entities/                    # 实体
    ValueObjects/                # 值对象
    Services/                    # 领域服务
    Exceptions/                  # 领域异常
  Infrastructure/                # 基础设施
    Persistence/
    Messaging/
    External/
```

**示例**:
```
Features/
  Members/
    CreateMember/
      CreateMemberCommand.cs
      CreateMemberHandler.cs
      CreateMemberValidator.cs
      MemberCreatedEvent.cs
    UpdateMemberProfile/
      UpdateMemberProfileCommand.cs
      UpdateMemberProfileHandler.cs
    GetMemberById/
      GetMemberByIdQuery.cs
      GetMemberByIdHandler.cs
  TableSessions/
    StartSession/
      StartSessionCommand.cs
      StartSessionHandler.cs
      SessionStartedEvent.cs
    EndSession/
      EndSessionCommand.cs
      EndSessionHandler.cs
```

### 4.2 文件数量约束

**规则**: 每个切片文件夹中的文件数量应保持最少。

**推荐**:
- 小切片（查询）：2个文件（Query + Handler）
- 中切片（命令）：3-4个文件（Command + Handler + Validator + Event）
- 大切片：不超过 6 个文件

**如果超过 6 个文件**，考虑：
1. 切片是否太大，需要拆分
2. 是否有逻辑应该下沉到领域层

## 5. 共享代码约束

### 5.1 何时共享

**✅ 应该共享**:
```csharp
// 领域实体（Domain/Entities/）
public class Member { }
public class Table { }
public class TableSession { }

// 值对象（Domain/ValueObjects/）
public record Money(decimal Amount, string Currency = "CNY");
public record DateRange(DateTime Start, DateTime End);

// 领域服务（Domain/Services/）
public interface IPricingService { }

// 技术基础设施（Infrastructure/）
public class EmailService { }
public class SmsService { }
```

**❌ 不应该共享**:
```csharp
// 命令/查询/事件（特定于切片）
public record CreateMemberCommand(...);  // 在 CreateMember/ 切片中

// DTO（特定于切片）
public class MemberDto { }  // 在需要它的切片中定义

// 验证器（特定于切片）
public class CreateMemberValidator { }  // 在 CreateMember/ 切片中
```

### 5.2 重复 vs 抽象

**原则**: "重复优于错误的抽象"（Duplication is cheaper than the wrong abstraction）

**示例**:
```csharp
// 可接受：两个切片有相似但独立的验证
// CreateMember/CreateMemberValidator.cs
public class CreateMemberValidator : AbstractValidator<CreateMemberCommand>
{
    public CreateMemberValidator()
    {
        RuleFor(x => x.Phone).Matches(@"^1[3-9]\d{9}$");
    }
}

// UpdateMemberPhone/UpdateMemberPhoneValidator.cs
public class UpdateMemberPhoneValidator : AbstractValidator<UpdateMemberPhoneCommand>
{
    public UpdateMemberPhoneValidator()
    {
        RuleFor(x => x.Phone).Matches(@"^1[3-9]\d{9}$");  // 相同的验证
    }
}

// 如果验证逻辑变得复杂（如需要数据库查询），再考虑提取
```

## 6. 处理器约束

### 6.1 处理器签名

**规则**: 处理器方法必须命名为 `Handle` 或 `HandleAsync`。

**✅ 正确**:
```csharp
public class CreateMemberHandler
{
    // 方式 1：同步命名，异步实现
    public async Task<Result<Guid>> Handle(
        CreateMemberCommand command,
        IDocumentSession session,
        CancellationToken ct)
    {
        // ...
    }
    
    // 方式 2：异步命名
    public async Task<Result<Guid>> HandleAsync(
        CreateMemberCommand command,
        IDocumentSession session)
    {
        // ...
    }
}
```

**❌ 错误**:
```csharp
public class CreateMemberHandler
{
    // ❌ 错误的方法名
    public async Task<Result<Guid>> Execute(CreateMemberCommand command) { }
    public async Task<Result<Guid>> Process(CreateMemberCommand command) { }
    public async Task<Result<Guid>> Create(CreateMemberCommand command) { }
}
```

### 6.2 依赖注入

**规则**: Wolverine 通过方法参数自动注入依赖，不使用构造函数注入。

**✅ 推荐**:
```csharp
public class CreateMemberHandler
{
    // Wolverine 自动注入方法参数
    public async Task<Result<Guid>> Handle(
        CreateMemberCommand command,         // 第一个参数是消息
        IDocumentSession session,            // 自动注入
        IEmailService emailService,          // 自动注入
        ILogger<CreateMemberHandler> logger, // 自动注入
        CancellationToken ct)                // 自动注入
    {
        // ...
    }
}
```

**⚠️ 可选**（构造函数注入，用于无状态服务）:
```csharp
public class CreateMemberHandler
{
    private readonly IPricingService _pricingService;
    
    public CreateMemberHandler(IPricingService pricingService)
    {
        _pricingService = pricingService;
    }
    
    public async Task<Result<Guid>> Handle(
        CreateMemberCommand command,
        IDocumentSession session)
    {
        var price = _pricingService.Calculate(...);
        // ...
    }
}
```

### 6.3 处理器职责

**规则**: 处理器应该是薄的编排层，复杂逻辑在领域层。

**✅ 好的处理器**:
```csharp
public class StartSessionHandler
{
    public async Task<Result<Guid>> Handle(
        StartSessionCommand command,
        IDocumentSession session,
        IMessageBus bus)
    {
        // 1. 加载聚合
        var table = await session.LoadAsync<Table>(command.TableId);
        if (table == null)
            return Result.Fail<Guid>("台球桌不存在");

        // 2. 调用领域方法
        var sessionResult = TableSession.Start(command.TableId, command.MemberId);
        if (sessionResult.IsFailure)
            return Result.Fail<Guid>(sessionResult.Error);

        // 3. 持久化
        session.Store(sessionResult.Value);
        await session.SaveChangesAsync();

        // 4. 发布事件
        await bus.PublishAsync(new SessionStartedEvent(sessionResult.Value.Id));

        // 5. 返回结果
        return Result.Ok(sessionResult.Value.Id);
    }
}
```

**❌ 糟糕的处理器**（包含太多业务逻辑）:
```csharp
public class StartSessionHandler
{
    public async Task<Result<Guid>> Handle(...)
    {
        // ❌ 不要在处理器中写复杂的业务规则
        if (table.Status == TableStatus.Available)
        {
            if (member != null && member.Balance >= minimumBalance)
            {
                if (currentTime.Hour >= openingHour && currentTime.Hour < closingHour)
                {
                    // 一大堆业务规则...
                }
            }
        }
        
        // ❌ 这些逻辑应该在领域层
    }
}
```

## 7. 测试约束

### 7.1 测试组织

**规则**: 测试可以与切片代码在一起，或在独立的测试项目中。

**选项 1：测试在切片中**（推荐小项目）:
```
Features/
  Members/
    CreateMember/
      CreateMemberCommand.cs
      CreateMemberHandler.cs
      CreateMemberTests.cs  // 测试在同一文件夹
```

**选项 2：独立测试项目**（推荐大项目）:
```
test/
  Zss.BilliardHall.Tests/
    Features/
      Members/
        CreateMemberTests.cs
        UpdateMemberTests.cs
```

### 7.2 测试范围

**规则**: 每个关键切片至少一个集成测试。

**示例**:
```csharp
[Fact]
public async Task Should_Create_Member_Successfully()
{
    // Arrange
    var command = new CreateMemberCommand("张三", "13800138000", "zhang@example.com");
    
    // Act
    var result = await Send(command);
    
    // Assert
    result.IsSuccess.ShouldBeTrue();
    
    var member = await LoadAsync<Member>(result.Value);
    member.ShouldNotBeNull();
    member.Name.ShouldBe("张三");
}
```

## 8. 异常情况

### 8.1 大型切片

**问题**: 切片变得太大（超过 500 行代码）。

**解决方案**:
1. 拆分成更小的切片
2. 提取领域服务
3. 使用策略模式

### 8.2 跨切片查询

**问题**: 需要从多个切片聚合数据。

**解决方案**:
1. 创建专门的查询切片（如 `GetMemberSummary`）
2. 使用原始 SQL 查询（Marten 支持）
3. 考虑引入读模型（CQRS）

### 8.3 共享验证逻辑

**问题**: 多个切片有相同的验证规则。

**解决方案**:
1. 如果验证简单，接受重复
2. 如果验证复杂（如需数据库查询），提取为验证服务
3. 使用 FluentValidation 的自定义验证器

## 9. 检查清单

在代码审查时，检查以下约束：

- [ ] 切片按功能组织，不按技术层次
- [ ] 切片间通过消息总线通信，不直接调用
- [ ] 处理器直接使用 `IDocumentSession`，不使用仓储
- [ ] 命令/查询/事件命名符合约定
- [ ] 处理器方法命名为 `Handle` 或 `HandleAsync`
- [ ] 处理器是薄的编排层，复杂逻辑在领域层
- [ ] 共享代码有充分的理由
- [ ] 关键切片有测试覆盖

## 10. 违规示例与修正

### 示例 1：直接调用其他处理器

**❌ 违规**:
```csharp
public class EndSessionHandler
{
    private readonly CalculateBillingHandler _billingHandler;
    
    public async Task Handle(EndSessionCommand cmd)
    {
        // 结束会话...
        
        await _billingHandler.Handle(new CalculateBillingCommand(sessionId));
    }
}
```

**✅ 修正**:
```csharp
public class EndSessionHandler
{
    public async Task Handle(EndSessionCommand cmd, IMessageBus bus)
    {
        // 结束会话...
        
        await bus.InvokeAsync(new CalculateBillingCommand(sessionId));
    }
}
```

### 示例 2：创建仓储层

**❌ 违规**:
```csharp
public interface IMemberRepository
{
    Task<Member?> GetByIdAsync(Guid id);
    Task SaveAsync(Member member);
}

public class GetMemberByIdHandler
{
    private readonly IMemberRepository _repository;
    
    public async Task<Member?> Handle(GetMemberByIdQuery query)
    {
        return await _repository.GetByIdAsync(query.Id);
    }
}
```

**✅ 修正**:
```csharp
public class GetMemberByIdHandler
{
    public async Task<Member?> Handle(
        GetMemberByIdQuery query,
        IDocumentSession session)
    {
        return await session.LoadAsync<Member>(query.Id);
    }
}
```

### 示例 3：处理器包含过多业务逻辑

**❌ 违规**:
```csharp
public class CalculatePriceHandler
{
    public async Task<decimal> Handle(CalculatePriceCommand cmd)
    {
        var price = cmd.BasePrice;
        
        // ❌ 复杂的计算逻辑在处理器中
        if (cmd.MemberLevel == MembershipLevel.Premium)
        {
            price *= 0.8m;
        }
        else if (cmd.MemberLevel == MembershipLevel.Gold)
        {
            price *= 0.9m;
        }
        
        if (cmd.Duration > TimeSpan.FromHours(2))
        {
            price *= 0.95m;
        }
        
        return price;
    }
}
```

**✅ 修正**:
```csharp
// 领域服务
public interface IPricingService
{
    decimal CalculatePrice(TableSession session, MembershipLevel level);
}

// 处理器
public class CalculatePriceHandler
{
    public async Task<decimal> Handle(
        CalculatePriceCommand cmd,
        IPricingService pricingService)
    {
        // 委托给领域服务
        return pricingService.CalculatePrice(cmd.Session, cmd.MemberLevel);
    }
}
```

## 11. 参考资源

- [Wolverine模块化架构蓝图](../03_系统架构设计/Wolverine模块化架构蓝图.md) - 包含垂直切片架构理念、框架特性详解
- [设计原则](../03_系统架构设计/设计原则.md)

---

**最后更新**: 2026-01-13  
**负责人**: 架构团队  
**审核状态**: 已批准
