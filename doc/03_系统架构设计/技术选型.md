# 技术选型

## 1. 后端框架

### ABP Framework 9.3.5
- **选择理由**：
  - 基于 ASP.NET Core 的现代化企业级应用框架
  - 内置 DDD（领域驱动设计）最佳实践
  - 模块化架构，易于扩展和维护
  - 完善的多租户、权限管理、审计日志等企业级功能
  - 活跃的社区支持和完善的文档

### .NET 9
- **选择理由**：
  - 最新的长期支持（LTS）版本
  - 高性能、跨平台
  - 完善的生态系统
  - 原生支持容器化部署

## 2. 前端框架

### Blazor Web App
- **选择理由**：
  - 使用 C# 进行全栈开发，减少学习成本
  - 组件化开发，易于维护
  - 支持服务器端渲染和客户端交互
  - 与 .NET 生态系统无缝集成
  - 适合企业内部管理系统

## 3. 数据库

### PostgreSQL
- **选择理由**：
  - 开源、免费、功能强大
  - 支持复杂查询和事务
  - 原生支持 JSON 数据类型（适合灵活的业务数据）
  - 优秀的性能和可靠性
  - 支持分区表、全文搜索等高级特性
  - 活跃的社区和成熟的生态系统

### Entity Framework Core 9.0
- **ORM 框架选择理由**：
  - 官方支持的 ORM 框架
  - Code First 开发模式
  - 强大的 LINQ 查询
  - 完善的迁移管理
  - 支持多种数据库提供程序

## 4. 测试框架

### xUnit
- **选择理由**：
  - .NET 社区主流测试框架
  - 与 ABP Framework 集成良好
  - 支持并行测试执行
  - 丰富的断言库

## 5. API 文档

### Swagger (Swashbuckle)
- **选择理由**：
  - 自动生成 API 文档
  - 提供交互式 API 测试界面
  - 支持 OpenAPI 标准
  - 便于前后端协作

## 6. 依赖注入

### Autofac
- **选择理由**：
  - ABP Framework 推荐的 DI 容器
  - 功能强大，支持高级场景
  - 性能优秀

## 7. 未来扩展技术栈（待实施）

### 缓存
- **Redis**：分布式缓存，用于会话数据、热点数据缓存

### 消息队列
- **RabbitMQ**：异步任务处理、事件总线

### 监控与日志
- **Serilog**：结构化日志
- **ELK Stack**：日志分析和可视化

### 容器化
- **Docker**：容器化部署
- **Kubernetes**：容器编排（多门店部署场景）

### CI/CD
- **GitHub Actions**：自动化构建、测试和部署

## 8. 技术栈总结

| 类别 | 技术 | 版本 |
|------|------|------|
| 应用框架 | ABP Framework | 9.3.5 |
| 运行时 | .NET | 9.0 |
| 前端 | Blazor Web App | 9.0 |
| 数据库 | PostgreSQL | 推荐 12+ |
| ORM | Entity Framework Core | 9.0 |
| API 文档 | Swagger/Swashbuckle | 8.1.1 |
| 测试框架 | xUnit | 最新 |
| DI 容器 | Autofac | 最新 |

## 9. 技术决策记录（ADR）

### ADR-001: 选择 ABP Framework
- **日期**: 2025-10-01
- **状态**: 已接受
- **背景**: 需要快速搭建企业级应用基础框架
- **决策**: 采用 ABP Framework
- **后果**: 
  - 正面：快速开发，减少重复代码，内置最佳实践
  - 负面：需要学习 ABP 的约定和模式

### ADR-002: 选择 PostgreSQL 作为主数据库
- **日期**: 2025-10-01
- **状态**: 已接受
- **背景**: 需要支持复杂查询和 JSON 数据存储
- **决策**: 采用 PostgreSQL
- **后果**:
  - 正面：开源、功能强大、支持 JSON
  - 负面：团队可能需要学习 PostgreSQL 特性

### ADR-003: 选择 Blazor 作为前端技术
- **日期**: 2025-10-01
- **状态**: 已接受
- **背景**: 希望使用 C# 进行全栈开发
- **决策**: 采用 Blazor Web App
- **后果**:
  - 正面：统一技术栈，减少学习成本
  - 负面：生态系统不如 React/Vue 成熟
