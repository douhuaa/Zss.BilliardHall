# 设计原则

## 1. 垂直切片架构原则

### 1.1 功能内聚（Feature Cohesion）

**原则**: 一个功能切片包含实现该功能所需的全部代码。

**实践**:
```
Features/
  TableSessions/
    StartSession/
      StartSessionCommand.cs      # 命令定义
      StartSessionHandler.cs      # 业务处理
      StartSessionValidator.cs    # 验证逻辑
      StartSessionEndpoint.cs     # HTTP 端点（可选）
```

**反例**: 将 Command 放在 `Commands/` 文件夹，Handler 放在 `Handlers/` 文件夹。

### 1.2 独立演化（Independent Evolution）

**原则**: 每个切片应该能够独立修改、测试和部署，不影响其他切片。

**实践**:
- 切片间通过消息/事件通信，而非直接调用
- 避免共享可变状态
- 最小化跨切片依赖

**示例**:
```csharp
// ✅ 好的实践：通过消息通信
public class EndSessionHandler
{
    public async Task Handle(EndSessionCommand cmd, IMessageBus bus)
    {
        // 结束会话...
        
        // 发送消息触发计费
        await bus.PublishAsync(new SessionEndedEvent(sessionId));
    }
}

// ❌ 避免：直接调用其他切片的处理器
public class EndSessionHandler
{
    private readonly CalculateBillingHandler _billingHandler;
    
    public async Task Handle(EndSessionCommand cmd)
    {
        // 不要这样做
        await _billingHandler.Handle(new CalculateBillingCommand(...));
    }
}
```

### 1.3 接受适度重复（Accept Duplication）

**原则**: 优先考虑独立性而非代码复用，接受适度的代码重复。

**实践**:
- 每个切片可以有自己的 DTO / 验证逻辑
- 不强制提取共享代码，除非真正通用
- "重复优于错误的抽象"（Duplication is better than wrong abstraction）

**何时共享**:
- ✅ 核心领域逻辑（如价格计算算法）
- ✅ 技术基础设施（日志、认证、缓存）
- ✅ 跨切片的实体定义

**何时不共享**:
- ❌ 特定于切片的 DTO / Command / Query
- ❌ 验证规则（即使看起来相似）
- ❌ 业务流程编排

**示例**:
```csharp
// ✅ 可接受：两个切片有相似的验证逻辑
// CreateMember/CreateMemberValidator.cs
public class CreateMemberValidator : AbstractValidator<CreateMemberCommand>
{
    public CreateMemberValidator()
    {
        RuleFor(x => x.Phone).NotEmpty().Matches(@"^1[3-9]\d{9}$");
    }
}

// UpdateMemberPhone/UpdateMemberPhoneValidator.cs
public class UpdateMemberPhoneValidator : AbstractValidator<UpdateMemberPhoneCommand>
{
    public UpdateMemberPhoneValidator()
    {
        RuleFor(x => x.Phone).NotEmpty().Matches(@"^1[3-9]\d{9}$");
    }
}

// 如果电话验证逻辑复杂且频繁变化，再考虑提取
```

## 2. 命令查询职责分离（CQRS）

### 2.1 明确区分命令和查询

**原则**: 命令改变状态但不返回数据，查询返回数据但不改变状态。

**实践**:
```csharp
// 命令：改变状态
public record CreateMemberCommand(string Name, string Phone, string Email);
public class CreateMemberHandler
{
    public async Task<Result<Guid>> Handle(CreateMemberCommand cmd, IDocumentSession session)
    {
        // 创建会员并返回 ID
        var member = new Member { /* ... */ };
        session.Store(member);
        return Result.Ok(member.Id);
    }
}

// 查询：返回数据
public record GetMemberByIdQuery(Guid Id);
public class GetMemberByIdHandler
{
    public async Task<Member?> Handle(GetMemberByIdQuery query, IDocumentSession session)
    {
        return await session.LoadAsync<Member>(query.Id);
    }
}
```

### 2.2 查询优化独立于命令

**原则**: 查询可以使用专门的优化技术，不受领域模型约束。

**实践**:
```csharp
// 查询可以使用投影、编译查询等优化
public class GetMemberListHandler
{
    public async Task<List<MemberListDto>> Handle(
        GetMemberListQuery query,
        IDocumentSession session)
    {
        return await session.Query<Member>()
            .Select(m => new MemberListDto  // 投影，只查询需要的字段
            {
                Id = m.Id,
                Name = m.Name,
                Level = m.Level
            })
            .ToListAsync();
    }
}
```

## 3. 领域驱动设计（DDD Light）

### 3.1 领域模型纯粹性

**原则**: 领域实体只包含业务逻辑，不依赖基础设施。

**实践**:
```csharp
// ✅ 好的领域实体
public class TableSession
{
    public Guid Id { get; private set; }
    public Guid TableId { get; private set; }
    public DateTime StartTime { get; private set; }
    public DateTime? EndTime { get; private set; }
    public SessionStatus Status { get; private set; }

    // 工厂方法
    public static TableSession Start(Guid tableId, Guid? memberId)
    {
        return new TableSession
        {
            Id = Guid.NewGuid(),
            TableId = tableId,
            StartTime = DateTime.UtcNow,
            Status = SessionStatus.Active
        };
    }

    // 领域行为
    public void End()
    {
        if (Status != SessionStatus.Active)
            throw new InvalidOperationException("会话已结束");
            
        EndTime = DateTime.UtcNow;
        Status = SessionStatus.Ended;
    }

    public void Pause()
    {
        if (Status != SessionStatus.Active)
            throw new InvalidOperationException("只有活动会话可以暂停");
            
        Status = SessionStatus.Paused;
    }
}

// ❌ 避免：领域实体依赖基础设施
public class TableSession
{
    public void End(IDocumentSession session, ILogger logger)  // ❌ 不要在实体中注入基础设施
    {
        EndTime = DateTime.UtcNow;
        session.Update(this);
        logger.LogInformation("会话已结束");
    }
}
```

### 3.2 值对象不可变

**原则**: 值对象应该是不可变的，表示概念而非身份。

**实践**:
```csharp
// 值对象
public record Money(decimal Amount, string Currency = "CNY")
{
    public static Money Zero => new(0);
    
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("货币类型不匹配");
            
        return new Money(Amount + other.Amount, Currency);
    }
    
    public static Money operator +(Money left, Money right) => left.Add(right);
}

public record SessionDuration(DateTime Start, DateTime? End)
{
    public TimeSpan CalculateDuration()
    {
        var endTime = End ?? DateTime.UtcNow;
        return endTime - Start;
    }
}
```

### 3.3 共享领域服务

**原则**: 复杂的领域逻辑可以提取为领域服务。

**实践**:
```csharp
// 领域服务接口
public interface IPricingService
{
    decimal CalculateSessionPrice(TableSession session, TableType tableType);
}

// 实现
public class PricingService : IPricingService
{
    public decimal CalculateSessionPrice(TableSession session, TableType tableType)
    {
        var duration = session.CalculateDuration();
        var hourlyRate = GetHourlyRate(tableType);
        
        // 复杂的价格计算逻辑
        var hours = (decimal)duration.TotalHours;
        var basePrice = hours * hourlyRate;
        
        // 应用折扣等
        return ApplyDiscounts(basePrice, session);
    }
    
    private decimal GetHourlyRate(TableType tableType) { /* ... */ }
    private decimal ApplyDiscounts(decimal basePrice, TableSession session) { /* ... */ }
}

// 在处理器中使用
public class CalculateBillingHandler
{
    public async Task<BillingResult> Handle(
        CalculateBillingCommand cmd,
        IDocumentSession session,
        IPricingService pricingService)  // 注入领域服务
    {
        var tableSession = await session.LoadAsync<TableSession>(cmd.SessionId);
        var table = await session.LoadAsync<Table>(tableSession.TableId);
        
        var price = pricingService.CalculateSessionPrice(tableSession, table.Type);
        
        // ...
    }
}
```

## 4. 消息驱动架构

### 4.1 异步优先

**原则**: 非关键路径的操作应该异步执行。

**实践**:
```csharp
// 关键路径：同步执行
public class StartSessionHandler
{
    public async Task<Result<Guid>> Handle(
        StartSessionCommand cmd,
        IDocumentSession session,
        IMessageBus bus)
    {
        // 同步：创建会话（关键操作）
        var tableSession = TableSession.Start(cmd.TableId, cmd.MemberId);
        session.Store(tableSession);
        await session.SaveChangesAsync();
        
        // 异步：发送通知（非关键操作）
        await bus.PublishAsync(new SessionStartedEvent(tableSession.Id));
        
        return Result.Ok(tableSession.Id);
    }
}

// 非关键路径：异步处理
public class SessionStartedEventHandler
{
    public async Task Handle(SessionStartedEvent evt, IEmailService email)
    {
        // 异步执行，不阻塞主流程
        await email.SendNotificationAsync(evt.SessionId);
    }
}
```

### 4.2 持久化收件箱/发件箱

**原则**: 关键业务消息必须持久化，保证不丢失。

**实践**:
```csharp
// 配置持久化消息
builder.Host.UseWolverine(opts =>
{
    opts.PersistMessagesWithMarten();
    
    // 关键业务队列：持久化
    opts.LocalQueue("billing").UseDurableInbox();
    opts.LocalQueue("payments").UseDurableInbox();
    
    // 非关键队列：内存
    opts.LocalQueue("notifications"); // 不持久化，失败可接受
});
```

### 4.3 幂等性设计

**原则**: 消息处理器应该是幂等的，重复执行不产生副作用。

**实践**:
```csharp
// 使用唯一 ID 保证幂等性
public class ProcessPaymentHandler
{
    public async Task<PaymentResult> Handle(
        ProcessPaymentCommand cmd,
        IDocumentSession session)
    {
        // 检查是否已处理
        var existingPayment = await session.Query<Payment>()
            .FirstOrDefaultAsync(p => p.OrderId == cmd.OrderId);
            
        if (existingPayment != null)
        {
            // 已处理，直接返回
            return PaymentResult.AlreadyProcessed(existingPayment.Id);
        }
        
        // 处理支付...
        var payment = new Payment { OrderId = cmd.OrderId, /* ... */ };
        session.Store(payment);
        
        return PaymentResult.Success(payment.Id);
    }
}
```

## 5. 可测试性

### 5.1 依赖注入

**原则**: 所有外部依赖通过构造函数或方法参数注入。

**实践**:
```csharp
// Wolverine 自动注入方法参数
public class CreateMemberHandler
{
    public async Task<Result<Guid>> Handle(
        CreateMemberCommand cmd,
        IDocumentSession session,     // 自动注入
        IEmailService emailService,   // 自动注入
        ILogger<CreateMemberHandler> logger,  // 自动注入
        CancellationToken ct)         // 自动注入
    {
        // 业务逻辑...
    }
}
```

### 5.2 测试友好设计

**原则**: 处理器应该是纯函数式的，易于测试。

**实践**:
```csharp
// 测试
[Fact]
public async Task Should_Create_Member_Successfully()
{
    // Arrange
    var handler = new CreateMemberHandler();
    var session = CreateTestDocumentSession();
    var emailService = Substitute.For<IEmailService>();
    var logger = Substitute.For<ILogger<CreateMemberHandler>>();
    
    var command = new CreateMemberCommand("张三", "138...", "zhang@...");
    
    // Act
    var result = await handler.Handle(command, session, emailService, logger, CancellationToken.None);
    
    // Assert
    result.IsSuccess.ShouldBeTrue();
    
    var member = await session.LoadAsync<Member>(result.Value);
    member.ShouldNotBeNull();
    member.Name.ShouldBe("张三");
}
```

## 6. 可观测性

### 6.1 结构化日志

**原则**: 使用结构化日志，包含关键上下文信息。

**实践**:
```csharp
// ✅ 好的日志
logger.LogInformation(
    "会话已创建: {SessionId}, 台球桌: {TableId}, 会员: {MemberId}",
    sessionId, tableId, memberId);

// ❌ 避免：字符串拼接
logger.LogInformation($"会话已创建: {sessionId}");
```

### 6.2 关键指标追踪

**原则**: 关键业务操作应该记录开始、结束和耗时。

**实践**:
```csharp
public class ProcessPaymentHandler
{
    public async Task<PaymentResult> Handle(
        ProcessPaymentCommand cmd,
        IPaymentGateway gateway,
        ILogger logger)
    {
        logger.LogInformation("开始处理支付: {OrderId}, 金额: {Amount:F2}", 
            cmd.OrderId, cmd.Amount);
        
        var sw = Stopwatch.StartNew();
        
        try
        {
            var result = await gateway.ChargeAsync(cmd.Amount);
            sw.Stop();
            
            logger.LogInformation(
                "支付成功: {OrderId}, 交易ID: {TransactionId}, 耗时: {ElapsedMs}ms",
                cmd.OrderId, result.TransactionId, sw.ElapsedMilliseconds);
                
            return PaymentResult.Success(result.TransactionId);
        }
        catch (Exception ex)
        {
            sw.Stop();
            
            logger.LogError(ex,
                "支付失败: {OrderId}, 耗时: {ElapsedMs}ms",
                cmd.OrderId, sw.ElapsedMilliseconds);
                
            throw;
        }
    }
}
```

## 7. 安全性

### 7.1 输入验证

**原则**: 所有外部输入必须验证。

**实践**:
```csharp
// 使用 FluentValidation
public class CreateMemberValidator : AbstractValidator<CreateMemberCommand>
{
    public CreateMemberValidator()
    {
        RuleFor(x => x.Name)
            .NotEmpty().WithMessage("姓名不能为空")
            .MaximumLength(50).WithMessage("姓名最多50个字符");
            
        RuleFor(x => x.Phone)
            .NotEmpty()
            .Matches(@"^1[3-9]\d{9}$").WithMessage("手机号格式不正确");
            
        RuleFor(x => x.Email)
            .NotEmpty()
            .EmailAddress().WithMessage("邮箱格式不正确");
    }
}

// Wolverine 自动执行验证
```

### 7.2 授权检查

**原则**: 所有敏感操作必须进行授权检查。

**实践**:
```csharp
// 使用特性或中间件
[Authorize(Roles = "Admin")]
public class DeleteMemberHandler
{
    public async Task Handle(DeleteMemberCommand cmd, IDocumentSession session)
    {
        // 只有管理员可以删除会员
    }
}

// 或在处理器中显式检查
public class UpdateMemberProfileHandler
{
    public async Task<Result> Handle(
        UpdateMemberProfileCommand cmd,
        IDocumentSession session,
        ICurrentUser currentUser)
    {
        // 只能修改自己的资料
        if (cmd.MemberId != currentUser.Id && !currentUser.IsAdmin())
        {
            return Result.Fail("无权限");
        }
        
        // 更新逻辑...
    }
}
```

### 7.3 敏感数据保护

**原则**: 不在日志或异常中输出敏感数据。

**实践**:
```csharp
// ✅ 好的实践
logger.LogInformation("用户登录: {UserId}", userId);

// ❌ 避免
logger.LogInformation("用户登录: {Phone}, 密码: {Password}", phone, password);

// 异常消息中不包含敏感信息
if (member == null)
    throw new NotFoundException("会员不存在");  // ✅
    
// 避免
throw new NotFoundException($"会员不存在: {email}");  // ❌ 可能泄露邮箱
```

## 8. 性能优化

### 8.1 延迟加载和批量加载

**原则**: 避免 N+1 查询，使用批量加载。

**实践**:
```csharp
// ❌ N+1 查询
foreach (var session in sessions)
{
    var table = await _session.LoadAsync<Table>(session.TableId);
    // ...
}

// ✅ 批量加载
var tableIds = sessions.Select(s => s.TableId).ToList();
var tables = await _session.LoadManyAsync<Table>(tableIds);
var tableDict = tables.ToDictionary(t => t.Id);
```

### 8.2 使用编译查询

**原则**: 频繁执行的查询应该编译。

**实践**:
```csharp
// 定义编译查询
public static class CompiledQueries
{
    public static readonly Func<IQuerySession, string, Task<Member?>> GetMemberByEmail =
        CompiledQuery.For((IQuerySession session, string email) =>
            session.Query<Member>().FirstOrDefault(m => m.Email == email)
        );
}

// 使用
var member = await CompiledQueries.GetMemberByEmail(session, email);
```

### 8.3 适当的缓存策略

**原则**: 缓存不常变化的数据。

**实践**:
```csharp
public class GetPricingRulesHandler
{
    private readonly IMemoryCache _cache;
    
    public async Task<List<PricingRule>> Handle(
        GetPricingRulesQuery query,
        IDocumentSession session,
        IMemoryCache cache)
    {
        return await cache.GetOrCreateAsync("PricingRules", async entry =>
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromHours(1);
            return await session.Query<PricingRule>().ToListAsync();
        });
    }
}
```

## 9. 总结

### 核心原则优先级

1. **功能内聚** - 垂直切片架构的基石
2. **独立演化** - 保证系统的灵活性
3. **CQRS** - 命令查询分离
4. **异步优先** - 提高系统吞吐量
5. **可测试性** - 保证代码质量
6. **可观测性** - 生产环境问题诊断
7. **安全性** - 保护用户数据
8. **性能优化** - 在满足功能的前提下优化

### 权衡考虑

- **重复 vs 抽象**: 适度重复优于错误的抽象
- **一致性 vs 可用性**: 关键操作保证一致性，非关键操作优先可用性
- **简单 vs 完美**: 先实现简单可工作的方案，再优化

---

**最后更新**: 2024-01-15  
**负责人**: 架构团队  
**审核状态**: 已批准
