
---
title: "总体架构图"
description: "自助台球系统总体架构设计图和说明"
section: "3.2"
version: "1.0.0"
author: "架构师"
maintainer: "架构师"
created: "2024-01-15"
updated: "2024-01-15"
category: "系统架构"
level: "必读"
audience: ["架构师", "开发工程师", "技术主管", "项目经理"]
keywords: ["架构图", "系统设计", "分层架构", "部署架构", "微服务"]
tags: ["architecture", "system-design", "layered-architecture"]
status: "完成"
dependencies: ["技术选型", "系统模块划分"]
related_docs: ["技术选型.md", "系统模块划分.md", "设计原则.md"]
---

# 🏗️ 3.2 总体架构图

<!-- Breadcrumb Navigation -->
**导航路径**: [🏠 项目文档首页](../自助台球系统项目文档.md) > [🏗️ 系统架构设计](README.md) > 🏗️ 总体架构图

<!-- Keywords for Search -->
**关键词**: `架构图` `系统设计` `分层架构` `部署架构` `微服务`

## 🎯 架构设计概述

自助台球系统采用**分层架构**结合**领域驱动设计(DDD)**的架构模式，基于ABP框架构建，确保系统的可维护性、可扩展性和可测试性。

## 🏛️ 1. 逻辑架构设计

### 1.1 四层架构总览

```mermaid
graph TB
    subgraph "表现层 (Presentation Layer)"
        A1[管理后台 Vue3]
        A2[H5用户端]
        A3[小程序端]
        A4[设备终端API]
    end
    
    subgraph "应用层 (Application Layer)"
        B1[Application Services]
        B2[DTOs & AutoMapper]
        B3[权限验证]
        B4[事件处理器]
    end
    
    subgraph "领域层 (Domain Layer)"
        C1[聚合根]
        C2[实体对象]
        C3[值对象]
        C4[领域服务]
        C5[领域事件]
        C6[仓储接口]
    end
    
    subgraph "基础设施层 (Infrastructure Layer)"
        D1[Entity Framework Core]
        D2[MySQL数据库]
        D3[Redis缓存]
        D4[RabbitMQ消息]
        D5[第三方服务]
    end
    
    A1 --> B1
    A2 --> B1
    A3 --> B1
    A4 --> B1
    
    B1 --> C1
    B2 --> C2
    B3 --> C4
    B4 --> C5
    
    C1 --> D1
    C4 --> D2
    C6 --> D1
    
    style A1 fill:#42b883
    style B1 fill:#ffd700
    style C1 fill:#ff6b6b
    style D1 fill:#4ecdc4
```

### 1.2 核心模块架构

```mermaid
graph LR
    subgraph "用户界面层"
        UI1[管理后台]
        UI2[用户端H5]
        UI3[设备终端]
    end
    
    subgraph "API网关层"
        GW[Nginx Gateway]
        AUTH[JWT认证]
        RATE[限流控制]
    end
    
    subgraph "业务应用层"
        APP1[会员管理]
        APP2[台球桌管理]
        APP3[计费结算]
        APP4[支付管理]
        APP5[设备管理]
        APP6[报表统计]
    end
    
    subgraph "领域核心层"
        DOM1[用户聚合]
        DOM2[台球桌聚合]
        DOM3[会话聚合]
        DOM4[支付聚合]
        DOM5[设备聚合]
    end
    
    subgraph "数据持久层"
        DB[(MySQL)]
        CACHE[(Redis)]
        MQ[(RabbitMQ)]
        FILE[文件存储]
    end
    
    UI1 --> GW
    UI2 --> GW
    UI3 --> GW
    
    GW --> AUTH
    AUTH --> APP1
    AUTH --> APP2
    AUTH --> APP3
    
    APP1 --> DOM1
    APP2 --> DOM2
    APP3 --> DOM3
    
    DOM1 --> DB
    DOM2 --> CACHE
    DOM3 --> MQ
```

## 🌐 2. 物理部署架构

### 2.1 生产环境部署

```mermaid
graph TB
    subgraph "负载均衡层"
        LB[Nginx Load Balancer]
        SSL[SSL终端]
    end
    
    subgraph "Web服务层"
        WEB1[Web Server 1]
        WEB2[Web Server 2]
        WEB3[Web Server N...]
    end
    
    subgraph "应用服务层"
        API1[API Server 1<br/>ASP.NET Core]
        API2[API Server 2<br/>ASP.NET Core]
        API3[API Server N...]
    end
    
    subgraph "缓存层"
        REDIS1[Redis Master]
        REDIS2[Redis Slave]
    end
    
    subgraph "消息队列层"
        MQ1[RabbitMQ Node 1]
        MQ2[RabbitMQ Node 2]
    end
    
    subgraph "数据库层"
        DB1[MySQL Master]
        DB2[MySQL Slave 1]
        DB3[MySQL Slave 2]
    end
    
    subgraph "监控层"
        MONITOR[Prometheus + Grafana]
        LOG[ELK Stack]
    end
    
    LB --> WEB1
    LB --> WEB2
    LB --> WEB3
    
    WEB1 --> API1
    WEB2 --> API2
    WEB3 --> API3
    
    API1 --> REDIS1
    API2 --> REDIS1
    API3 --> REDIS1
    
    REDIS1 --> REDIS2
    
    API1 --> MQ1
    API2 --> MQ2
    
    API1 --> DB1
    API2 --> DB2
    API3 --> DB3
    
    DB1 --> DB2
    DB1 --> DB3
    
    API1 --> MONITOR
    API2 --> LOG
    
    style LB fill:#ff9999
    style API1 fill:#99ccff
    style DB1 fill:#99ff99
    style REDIS1 fill:#ffcc99
```

### 2.2 Docker容器化部署

```mermaid
graph TB
    subgraph "Docker Host"
        subgraph "Web容器"
            NGINX[nginx:alpine]
            WEB[node:alpine<br/>Vue3 Static Files]
        end
        
        subgraph "API容器"
            API[mcr.microsoft.com/dotnet/aspnet:8.0<br/>ASP.NET Core API]
        end
        
        subgraph "数据库容器"
            MYSQL[mysql:8.0]
        end
        
        subgraph "缓存容器"
            REDIS[redis:6.0-alpine]
        end
        
        subgraph "消息容器"
            RABBIT[rabbitmq:3.11-management]
        end
        
        subgraph "监控容器"
            PROM[prometheus/prometheus]
            GRAF[grafana/grafana]
        end
    end
    
    subgraph "Docker Volumes"
        VOL1[mysql-data]
        VOL2[redis-data]
        VOL3[rabbitmq-data]
        VOL4[app-logs]
    end
    
    NGINX --> WEB
    NGINX --> API
    API --> MYSQL
    API --> REDIS
    API --> RABBIT
    
    MYSQL --> VOL1
    REDIS --> VOL2
    RABBIT --> VOL3
    API --> VOL4
    
    PROM --> API
    GRAF --> PROM
```

## 🔧 3. 技术架构集成

### 3.1 技术栈集成图

```mermaid
graph LR
    subgraph "前端技术栈"
        VUE[Vue 3.3]
        TS[TypeScript 5.0]
        VITE[Vite 4.0]
        ELEM[Element Plus]
        AXIOS[Axios HTTP]
    end
    
    subgraph "后端技术栈"
        NET[.NET 8.0]
        ABP[ABP 7.0]
        EF[EF Core 8.0]
        SERI[Serilog]
        MASS[MassTransit]
    end
    
    subgraph "数据存储"
        MYSQL[MySQL 8.0]
        REDIS[Redis 6.0]
        RABBIT[RabbitMQ 3.11]
    end
    
    subgraph "运维工具"
        DOCKER[Docker]
        GITHUB[GitHub Actions]
        NGINX[Nginx]
    end
    
    VUE --> TS
    TS --> VITE
    VITE --> ELEM
    ELEM --> AXIOS
    
    NET --> ABP
    ABP --> EF
    EF --> SERI
    SERI --> MASS
    
    AXIOS -.->|HTTP API| NET
    EF -.->|ORM| MYSQL
    MASS -.->|Message| RABBIT
    ABP -.->|Cache| REDIS
    
    DOCKER --> NET
    DOCKER --> VUE
    GITHUB -.->|CI/CD| DOCKER
    NGINX -.->|Proxy| NET
```

### 3.2 数据流向架构

```mermaid
sequenceDiagram
    participant U as 用户端
    participant G as API网关
    participant A as 应用层
    participant D as 领域层
    participant I as 基础设施层
    participant DB as 数据库
    participant C as 缓存
    participant MQ as 消息队列
    
    U->>G: HTTP请求
    G->>G: 认证授权
    G->>A: 路由请求
    
    A->>C: 查询缓存
    alt 缓存命中
        C-->>A: 返回缓存数据
    else 缓存未命中
        A->>D: 调用领域服务
        D->>I: 仓储操作
        I->>DB: 数据库查询
        DB-->>I: 查询结果
        I-->>D: 返回实体
        D-->>A: 返回领域对象
        A->>C: 更新缓存
    end
    
    A->>MQ: 发布领域事件
    A-->>G: 返回响应
    G-->>U: HTTP响应
    
    MQ->>A: 异步事件处理
    A->>I: 后续操作
```

## 🏢 4. 模块架构设计

### 4.1 业务模块架构

```mermaid
graph TB
    subgraph "用户管理模块"
        USER1[用户注册登录]
        USER2[用户信息管理]
        USER3[会员权益管理]
    end
    
    subgraph "台球桌管理模块"
        TABLE1[台球桌状态管理]
        TABLE2[开台关台控制]
        TABLE3[预约管理]
    end
    
    subgraph "计费结算模块"
        BILL1[实时计费]
        BILL2[费用结算]
        BILL3[优惠券管理]
    end
    
    subgraph "支付管理模块"
        PAY1[支付渠道对接]
        PAY2[支付状态管理]
        PAY3[退款处理]
    end
    
    subgraph "设备管理模块"
        DEV1[设备状态监控]
        DEV2[设备控制指令]
        DEV3[故障告警]
    end
    
    subgraph "报表统计模块"
        RPT1[经营数据统计]
        RPT2[用户行为分析]
        RPT3[设备使用分析]
    end
    
    subgraph "基础服务模块"
        BASE1[权限管理]
        BASE2[系统配置]
        BASE3[日志审计]
    end
    
    USER1 --> BASE1
    TABLE1 --> DEV1
    BILL1 --> PAY1
    RPT1 --> BASE3
    
    style USER1 fill:#e1f5fe
    style TABLE1 fill:#f3e5f5
    style BILL1 fill:#e8f5e8
    style PAY1 fill:#fff3e0
```

### 4.2 跨模块交互

```mermaid
graph LR
    subgraph "核心业务流程"
        A[用户扫码] --> B[开台请求]
        B --> C[台球桌分配]
        C --> D[计费开始]
        D --> E[使用过程监控]
        E --> F[结束计费]
        F --> G[支付处理]
        G --> H[台球桌释放]
    end
    
    subgraph "支撑服务"
        S1[用户认证]
        S2[设备控制]
        S3[消息通知]
        S4[数据统计]
    end
    
    A -.-> S1
    C -.-> S2
    F -.-> S3
    H -.-> S4
```

## 🚀 5. 高可用架构

### 5.1 服务高可用

```mermaid
graph TB
    subgraph "高可用策略"
        HA1[负载均衡]
        HA2[服务冗余]
        HA3[故障转移]
        HA4[熔断降级]
    end
    
    subgraph "数据高可用"
        DATA1[主从复制]
        DATA2[读写分离]
        DATA3[定期备份]
        DATA4[实时同步]
    end
    
    subgraph "监控告警"
        MON1[健康检查]
        MON2[性能监控]
        MON3[异常告警]
        MON4[自动恢复]
    end
    
    HA1 --> HA2
    HA2 --> HA3
    HA3 --> HA4
    
    DATA1 --> DATA2
    DATA2 --> DATA3
    DATA3 --> DATA4
    
    MON1 --> MON2
    MON2 --> MON3
    MON3 --> MON4
    
    HA4 -.-> MON1
    DATA4 -.-> MON2
```

### 5.2 性能优化架构

```mermaid
graph LR
    subgraph "缓存策略"
        C1[L1本地缓存]
        C2[L2分布式缓存]
        C3[CDN静态缓存]
        C4[数据库查询缓存]
    end
    
    subgraph "数据库优化"
        DB1[索引优化]
        DB2[分库分表]
        DB3[连接池管理]
        DB4[慢查询优化]
    end
    
    subgraph "应用优化"
        APP1[异步处理]
        APP2[批量操作]
        APP3[资源池化]
        APP4[代码优化]
    end
    
    C1 --> C2
    C2 --> C3
    C3 --> C4
    
    DB1 --> DB2
    DB2 --> DB3
    DB3 --> DB4
    
    APP1 --> APP2
    APP2 --> APP3
    APP3 --> APP4
```

## 📊 6. 架构质量属性

### 6.1 质量属性支撑

| 质量属性 | 架构支撑策略 | 实现方案 |
|---------|-------------|----------|
| **可扩展性** | 分层架构、模块化设计 | 水平扩展、垂直扩展 |
| **可维护性** | DDD设计、代码分离 | 清晰边界、统一规范 |
| **高可用性** | 冗余部署、故障转移 | 99.9%可用性目标 |
| **高性能** | 缓存优化、异步处理 | <3s响应时间 |
| **安全性** | 分层防护、权限控制 | 多重安全机制 |
| **可测试性** | 依赖注入、接口抽象 | 单元测试、集成测试 |

### 6.2 架构演进路径

```mermaid
graph LR
    V1[V1.0 单体架构<br/>快速上线] --> V2[V2.0 模块化架构<br/>功能完善]
    V2 --> V3[V3.0 微服务架构<br/>水平扩展]
    V3 --> V4[V4.0 云原生架构<br/>弹性伸缩]
    
    style V1 fill:#ffeb3b
    style V2 fill:#4caf50
    style V3 fill:#2196f3
    style V4 fill:#9c27b0
```

## 🔍 7. 架构决策记录(ADR)

### ADR-001: 采用分层架构
**决策**: 采用经典的四层架构模式
**理由**: 职责分离清晰，便于团队协作和维护
**状态**: ✅ 已采纳

### ADR-002: 选择MySQL作为主数据库
**决策**: 使用MySQL 8.0作为主要数据存储
**理由**: 性能优秀、成本可控、团队熟悉
**状态**: ✅ 已采纳

### ADR-003: 使用EF Core Code First
**决策**: 采用Code First数据库开发方式
**理由**: 保持代码与数据库同步，便于版本控制
**状态**: ✅ 已采纳

### ADR-004: 引入Redis缓存
**决策**: 使用Redis作为分布式缓存
**理由**: 提升查询性能，支持复杂数据结构
**状态**: ✅ 已采纳

## 🔗 相关文档

- [技术选型](技术选型.md) - 详细的技术选型说明
- [系统模块划分](系统模块划分.md) - 业务模块设计
- [外部接口](外部接口.md) - 第三方系统集成
- [设计原则](设计原则.md) - 架构设计原则

---

💡 **说明**: 架构图将随着系统演进持续更新，请及时关注版本变更。如需高清矢量图，请联系架构团队。
