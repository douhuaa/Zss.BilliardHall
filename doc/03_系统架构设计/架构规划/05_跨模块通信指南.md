# 跨模块通信指南

> **定位**: 模块间通信的方式与最佳实践
> 
> **适用范围**: 所有涉及跨模块交互的场景

---

## 一、通信方式选择

### 1.1 通信方式对照表

| 场景 | 方式 | 工具 | 示例 |
|------|------|------|------|
| 同模块内 | 直接方法调用 | - | Handler 内调用领域服务 |
| 跨模块同步 | Command Bus | `IMessageBus.InvokeAsync()` | 结账时触发计费 |
| 跨模块异步 | Event | `IMessageBus.PublishAsync()` | 会员注册后发送欢迎邮件 |
| 跨服务 | Message Queue | RabbitMQ/Kafka | 支付完成通知第三方系统 |

### 1.2 选择决策树

```
需要跨模块通信？
├─ 是，且需要等待结果 → 使用 InvokeAsync（同步）
│  └─ 示例：结账时需要立即获取账单金额
│
└─ 是，但不需要等待结果 → 使用 PublishAsync（异步）
   └─ 示例：会员注册后发送通知邮件
```

---

## 二、同步通信（Command Bus）

### 2.1 使用场景

**何时使用同步通信**:
- 需要立即获取返回结果
- 后续流程依赖返回值
- 需要确保操作完成

### 2.2 实现示例

```csharp
// EndSession Handler（Sessions 模块）
public class EndSessionHandler
{
    [Transactional]
    public async Task<Result<Guid>> Handle(
        EndSession command,
        IDocumentSession session,
        IMessageBus bus,
        CancellationToken ct)
    {
        // 1. 结束会话
        var tableSession = await session.LoadAsync<TableSession>(command.SessionId, ct);
        tableSession.End();
        session.Store(tableSession);
        
        // 2. 同步调用 Billing 模块计算账单
        var billResult = await bus.InvokeAsync<BillResult>(
            new CalculateBill(
                command.SessionId,
                tableSession.Duration
            ),
            ct
        );
        
        if (!billResult.IsSuccess)
            return Result.Fail<Guid>(billResult.Error);
        
        // 3. 返回账单ID
        return Result.Ok(billResult.BillId);
    }
}

// CalculateBill Handler（Billing 模块）
public class CalculateBillHandler
{
    public async Task<BillResult> Handle(
        CalculateBill command,
        IDocumentSession session,
        CancellationToken ct)
    {
        // 计算账单逻辑
        var bill = new Bill
        {
            Id = Guid.NewGuid(),
            SessionId = command.SessionId,
            Amount = CalculateAmount(command.Duration)
        };
        
        session.Store(bill);
        await session.SaveChangesAsync(ct);
        
        return new BillResult(bill.Id, bill.Amount, true, string.Empty);
    }
}

// 共享结果类型
public record BillResult(
    Guid BillId,
    decimal Amount,
    bool IsSuccess,
    string Error
);
```

---

## 三、异步通信（Event）

### 3.1 使用场景

**何时使用异步通信**:
- 不需要立即获取返回结果
- 解耦模块依赖
- 一个事件触发多个处理器
- 后台任务

### 3.2 实现示例

```csharp
// RegisterMember Handler（Members 模块）
public class RegisterMemberHandler
{
    [Transactional]
    public async Task<Guid> Handle(
        RegisterMember command,
        IDocumentSession session,
        IMessageBus bus,
        CancellationToken ct)
    {
        // 1. 注册会员
        var member = new Member
        {
            Id = Guid.NewGuid(),
            Name = command.Name,
            Phone = command.Phone
        };
        
        session.Store(member);
        
        // 2. 发布事件（异步）
        await bus.PublishAsync(
            new MemberRegistered(member.Id, member.Name, member.Phone),
            ct
        );
        
        return member.Id;
    }
}

// 事件定义（BuildingBlocks/Contracts）
public sealed record MemberRegistered(
    Guid MemberId,
    string Name,
    string Phone,
    DateTimeOffset RegisteredAt
)
{
    public MemberRegistered(Guid memberId, string name, string phone)
        : this(memberId, name, phone, DateTimeOffset.UtcNow)
    {
    }
}

// 事件处理器 1：发送欢迎邮件（Notifications 模块）
public class SendWelcomeEmailHandler
{
    public async Task Handle(
        MemberRegistered @event,
        IEmailService emailService,
        ILogger logger)
    {
        await emailService.SendAsync(
            "welcome-email",
            new { @event.Name, @event.Phone }
        );
        
        logger.LogInformation(
            "已发送欢迎邮件给会员 {MemberId}",
            @event.MemberId
        );
    }
}

// 事件处理器 2：发放新人优惠（Promotions 模块）
public class GrantNewMemberCouponHandler
{
    public async Task Handle(
        MemberRegistered @event,
        IDocumentSession session)
    {
        var coupon = new Coupon
        {
            Id = Guid.NewGuid(),
            MemberId = @event.MemberId,
            Type = CouponType.NewMember,
            Amount = 10m
        };
        
        session.Store(coupon);
        await session.SaveChangesAsync();
    }
}
```

---

## 四、反模式：共享服务层

### 4.1 错误示范

❌ **不要创建 Shared Service**:
```csharp
// 错误：创建共享服务
public class SharedBillingService
{
    public decimal CalculatePrice(TimeSpan duration) { }
}

// 多个模块都依赖它
public class EndSessionHandler
{
    private readonly SharedBillingService _billingService;
    
    public async Task Handle(EndSession command)
    {
        // 直接调用共享服务
        var price = _billingService.CalculatePrice(duration);
    }
}
```

**问题**:
- 模块隐式耦合
- 难以独立演化
- 测试复杂度提高

### 4.2 正确做法

✅ **通过命令/查询通信**:
```csharp
public class EndSessionHandler
{
    public async Task Handle(
        EndSession command,
        IMessageBus bus)
    {
        // 发送命令到 Billing 模块
        var bill = await bus.InvokeAsync<BillResult>(
            new CalculateBill(sessionId, duration)
        );
    }
}
```

**优势**:
- 模块显式通信
- 易于追踪调用链
- 支持消息持久化

---

## 五、跨模块实体关系

### 5.1 方案 1：通过 ID 关联（推荐）

```csharp
// Sessions 模块
public class TableSession
{
    public Guid Id { get; set; }
    public Guid TableId { get; set; }  // 只存 ID，不存对象
    public Guid MemberId { get; set; }
}

// 需要完整数据时，通过消息查询
public class GetSessionDetailsHandler
{
    public async Task<SessionDetails> Handle(
        GetSessionDetails query,
        IDocumentSession session,
        IMessageBus bus)
    {
        var tableSession = await session.LoadAsync<TableSession>(query.SessionId);
        
        // 查询 Table 信息
        var table = await bus.InvokeAsync<Table>(
            new GetTable(tableSession.TableId)
        );
        
        // 查询 Member 信息
        var member = await bus.InvokeAsync<Member>(
            new GetMember(tableSession.MemberId)
        );
        
        return new SessionDetails(tableSession, table, member);
    }
}
```

### 5.2 方案 2：数据冗余（特定场景）

```csharp
// 为了性能，可以冗余少量只读数据
public class TableSession
{
    public Guid TableId { get; set; }
    public string TableName { get; set; }  // 冗余数据，仅用于展示
    public Guid MemberId { get; set; }
    public string MemberName { get; set; } // 冗余数据，仅用于展示
}

// 通过事件保持数据同步
public class TableNameChangedHandler
{
    public async Task Handle(
        TableNameChanged @event,
        IDocumentSession session)
    {
        // 更新所有相关会话的冗余数据
        var sessions = await session
            .Query<TableSession>()
            .Where(x => x.TableId == @event.TableId)
            .ToListAsync();
            
        foreach (var session in sessions)
        {
            session.TableName = @event.NewName;
            session.Store(session);
        }
        
        await session.SaveChangesAsync();
    }
}
```

### 5.3 方案 3：视图/投影（CQRS）

```csharp
// 创建专门的查询视图
public class SessionSummaryView
{
    public Guid SessionId { get; set; }
    public string TableName { get; set; }
    public string MemberName { get; set; }
    public decimal Amount { get; set; }
    // ... 聚合多个模块的数据
}

// 通过事件更新视图
public class UpdateSessionSummaryViewHandler
{
    public async Task Handle(
        SessionEnded @event,
        IDocumentSession session,
        IMessageBus bus)
    {
        // 从多个模块获取数据
        var table = await bus.InvokeAsync<Table>(new GetTable(@event.TableId));
        var member = await bus.InvokeAsync<Member>(new GetMember(@event.MemberId));
        var bill = await bus.InvokeAsync<Bill>(new GetBill(@event.SessionId));
        
        // 创建或更新视图
        var view = new SessionSummaryView
        {
            SessionId = @event.SessionId,
            TableName = table.Name,
            MemberName = member.Name,
            Amount = bill.Amount
        };
        
        session.Store(view);
        await session.SaveChangesAsync();
    }
}
```

---

## 六、消息路由配置

### 6.1 本地队列

```csharp
// Program.cs
builder.Host.UseWolverine(opts =>
{
    // 配置本地队列
    opts.LocalQueue("billing")
        .UseDurableInbox()
        .Sequential();  // 顺序处理
    
    opts.LocalQueue("notifications")
        .UseDurableInbox()
        .MaximumParallelMessages(5);  // 并行处理
    
    // 消息路由
    opts.PublishMessage<MemberRegistered>()
        .ToLocalQueue("notifications");
        
    opts.PublishMessage<SessionEnded>()
        .ToLocalQueue("billing");
});
```

### 6.2 外部队列（RabbitMQ）

```csharp
builder.Host.UseWolverine(opts =>
{
    // 配置 RabbitMQ
    opts.UseRabbitMq(rabbit =>
    {
        rabbit.HostName = configuration["RabbitMQ:Host"]!;
        rabbit.AutoProvision();
    });
    
    // 发布到外部队列
    opts.PublishMessage<PaymentCompleted>()
        .ToRabbitQueue("external-payment-events");
    
    // 从外部队列订阅
    opts.ListenToRabbitQueue("incoming-orders")
        .UseDurableInbox();
});
```

---

## 七、最佳实践

### 7.1 通信原则

**DO（应该做）**:
- ✅ 模块间只通过消息通信
- ✅ 同步调用返回轻量级结果
- ✅ 异步事件用于通知
- ✅ 事件包含必要的上下文信息

**DON'T（不应该做）**:
- ❌ 不创建 Shared Service
- ❌ 不跨模块直接访问数据库
- ❌ 不在事件中传递大量数据
- ❌ 不循环依赖（A → B → A）

### 7.2 消息设计

**Command**:
- 命令式命名（`CreateOrder`）
- 包含操作所需的所有数据
- 只有一个 Handler

**Event**:
- 过去式命名（`OrderCreated`）
- 表示已发生的事实
- 可以有多个 Handler

### 7.3 错误处理

```csharp
// 同步调用：处理失败
var billResult = await bus.InvokeAsync<BillResult>(command);
if (!billResult.IsSuccess)
{
    return Result.Fail(billResult.Error);
}

// 异步事件：重试策略
builder.Host.UseWolverine(opts =>
{
    opts.Policies.OnException<HttpRequestException>()
        .RetryWithCooldown(50.Milliseconds(), 100.Milliseconds());
});
```

---

## 八、参考资源

### 相关文档
- [核心架构原则](./01_核心架构原则.md) - 通信原则
- [系统模块划分](../系统模块划分.md) - 模块间通信矩阵
- [Wolverine快速上手指南](../Wolverine快速上手指南.md) - 代码示例

### 外部资源
- [Wolverine Messaging Documentation](https://wolverine.netlify.app/guide/messaging/)
- [Message Bus Pattern](https://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageBus.html)

---

## 版本历史

| 版本 | 日期 | 变更说明 |
|------|------|----------|
| 1.0.0 | 2024-01-15 | 从 Wolverine模块化架构蓝图 拆分 |

---

**最后更新**: 2024-01-15  
**负责人**: 架构团队  
**审核状态**: ✅ 已审核
