# 实战建议与最佳实践

> **定位**: 实际开发中的经验与陷阱
> 
> **适用范围**: 所有 Wolverine 项目开发

---

## 一、先照抄，再优化

### 1.1 第一阶段：照抄官方 Sample

**策略**: 直接使用官方示例的风格

```csharp
// 直接使用官方示例的风格
public class CreateOrderHandler
{
    public async Task<Guid> Handle(
        CreateOrder command,
        IDocumentSession session)
    {
        var order = new Order { /* ... */ };
        session.Store(order);
        await session.SaveChangesAsync();
        return order.Id;
    }
}
```

**目标**:
- 快速上手
- 理解约定
- 建立信心

### 1.2 第二阶段：根据项目调整

**策略**: 加入项目规范

```csharp
// 加入项目规范（如 Result 类型）
public class CreateOrderHandler
{
    public async Task<Result<Guid>> Handle(
        CreateOrder command,
        IDocumentSession session)
    {
        // 校验逻辑
        if (command.Amount <= 0)
            return Result.Fail<Guid>("金额必须大于0");

        var order = new Order { /* ... */ };
        session.Store(order);
        await session.SaveChangesAsync();
        return Result.Ok(order.Id);
    }
}
```

**目标**:
- 符合团队规范
- 添加必要抽象
- 保持简洁

---

## 二、不要"重复洁癖"

### 2.1 接受适度重复

**反模式：过早抽象**
```csharp
// ❌ 只有 2 个 Handler 就开始抽象
public abstract class BaseHandler<TCommand, TResult>
{
    protected abstract Task<TResult> ExecuteAsync(TCommand command);
}
```

**正确做法：接受重复**
```csharp
// ✅ 允许适度重复
public class CreateOrderHandler
{
    public async Task<Guid> Handle(CreateOrder cmd, IDocumentSession session)
    {
        // 直接实现，不抽象
    }
}

public class CreateMemberHandler
{
    public async Task<Guid> Handle(CreateMember cmd, IDocumentSession session)
    {
        // 即使有相似逻辑，也不要过早抽象
    }
}
```

### 2.2 经验法则

**抽象时机**:
- 重复 2 次：观察
- 重复 3 次：考虑抽象
- 重复 5 次：必须抽象

**抽象标准**:
- 逻辑完全相同
- 多处使用
- 易于理解

---

## 三、宁可重复代码，也别提前抽象

### 3.1 示例场景：多个模块都需要发送通知

**过早抽象**:
```csharp
// ❌ 创建共享通知服务
public interface INotificationService
{
    Task SendAsync(string template, object data);
}

// 多个模块依赖
public class CreateOrderHandler
{
    private readonly INotificationService _notification;
}
```

**接受重复**:
```csharp
// ✅ 每个模块独立实现
// Orders 模块
public class OrderCreatedHandler
{
    public async Task Handle(OrderCreated evt, IEmailService email)
    {
        await email.SendAsync("order-created", new { evt.OrderId });
    }
}

// Members 模块
public class MemberRegisteredHandler
{
    public async Task Handle(MemberRegistered evt, IEmailService email)
    {
        await email.SendAsync("member-welcome", new { evt.MemberId });
    }
}
```

### 3.2 何时抽象

**抽象条件**:
- 当通知逻辑变得复杂（模板管理、多渠道）
- 当需要统一审计/监控
- 当业务要求统一行为（如失败重试策略）

---

## 四、Handler 复杂度信号

### 4.1 警告信号

**文件复杂度**:
- ⚠️ Handler 超过 50 行
- ⚠️ 包含多个 if/else 分支
- ⚠️ 需要注入 5+ 个依赖

**解决方案**:
1. **拆分 Handler**: 将一个大 Command 拆成多个小 Command
2. **引入领域服务**: 复杂逻辑下沉到领域层
3. **使用 Saga**: 跨步骤流程用 Saga 编排

### 4.2 拆分示例

**拆分前**:
```csharp
// ❌ Handler 太复杂
public class ProcessOrderHandler
{
    public async Task Handle(ProcessOrder cmd)
    {
        // 50+ 行代码
        // 包含库存检查、价格计算、优惠券、积分...
    }
}
```

**拆分后**:
```csharp
// ✅ 拆分成多个步骤
public class ProcessOrderSaga : Saga
{
    public void Handle(OrderCreated evt) => /* 触发库存检查 */;
    public void Handle(StockReserved evt) => /* 触发价格计算 */;
    public void Handle(PriceCalculated evt) => /* 触发支付 */;
}
```

---

## 五、测试策略

### 5.1 单元测试（隔离 Handler）

```csharp
public class CreateOrderHandlerTests
{
    [Fact]
    public async Task Should_Create_Order_Successfully()
    {
        // 使用 In-Memory Marten
        await using var store = DocumentStore.For(opts =>
        {
            opts.Connection(ConnectionSource.InMemoryConnectionString);
        });
        
        await using var session = store.LightweightSession();
        
        var handler = new CreateOrderHandler();
        var command = new CreateOrder(/* ... */);
        
        var result = await handler.Handle(command, session);
        
        result.IsSuccess.ShouldBeTrue();
    }
}
```

### 5.2 集成测试（完整流程）

```csharp
public class OrderFlowTests : IAsyncLifetime
{
    private IHost _host = null!;

    public async Task InitializeAsync()
    {
        _host = await Host.CreateDefaultBuilder()
            .UseWolverine(opts =>
            {
                opts.Services.AddMarten(/* test DB */);
            })
            .StartAsync();
    }

    [Fact]
    public async Task Should_Complete_Order_Flow()
    {
        var bus = _host.Services.GetRequiredService<IMessageBus>();
        
        // 创建订单
        var orderId = await bus.InvokeAsync<Guid>(
            new CreateOrder(/* ... */)
        );
        
        // 处理支付
        await bus.InvokeAsync(new ProcessPayment(orderId, 100m));
        
        // 验证结果
        var session = _host.Services.GetRequiredService<IDocumentSession>();
        var order = await session.LoadAsync<Order>(orderId);
        order.Status.ShouldBe(OrderStatus.Completed);
    }

    public async Task DisposeAsync()
    {
        await _host.StopAsync();
        _host.Dispose();
    }
}
```

---

## 六、性能优化建议

### 6.1 查询优化

**使用投影**:
```csharp
// ❌ 加载完整实体
var orders = await session.Query<Order>()
    .Where(x => x.Status == OrderStatus.Pending)
    .ToListAsync();

// ✅ 使用投影
var orders = await session.Query<Order>()
    .Where(x => x.Status == OrderStatus.Pending)
    .Select(x => new OrderSummary
    {
        Id = x.Id,
        TotalAmount = x.TotalAmount,
        CreatedAt = x.CreatedAt
    })
    .ToListAsync();
```

**批量操作**:
```csharp
// ❌ 循环查询（N+1 问题）
foreach (var orderId in orderIds)
{
    var order = await session.LoadAsync<Order>(orderId);
    // 处理
}

// ✅ 批量加载
var orders = await session.LoadManyAsync<Order>(orderIds);
foreach (var order in orders)
{
    // 处理
}
```

### 6.2 消息处理优化

**并行处理**:
```csharp
// 配置并行处理
opts.LocalQueue("notifications")
    .UseDurableInbox()
    .MaximumParallelMessages(10);  // 并行处理 10 条消息
```

**批量处理**:
```csharp
// Handler 支持批量
public class ProcessBatchHandler
{
    public async Task Handle(
        IEnumerable<OrderCreated> events,
        IDocumentSession session)
    {
        foreach (var evt in events)
        {
            // 批量处理
        }
        
        await session.SaveChangesAsync();
    }
}
```

---

## 七、常见错误与解决

### 7.1 Handler 未被发现

**问题**:
```csharp
// Handler 未生效
public class CreateOrderHandler
{
    public Task Handle(CreateOrder cmd) { }  // 未被发现
}
```

**解决**:
```csharp
// 方法名必须是 Handle 或 HandleAsync
public class CreateOrderHandler
{
    public async Task Handle(CreateOrder cmd, IDocumentSession session)
    {
        // 实现
    }
}
```

### 7.2 事务未生效

**问题**:
```csharp
// 数据未保存
public class CreateOrderHandler
{
    public async Task<Guid> Handle(CreateOrder cmd, IDocumentSession session)
    {
        var order = new Order();
        session.Store(order);
        // 缺少 SaveChangesAsync 或 [Transactional]
        return order.Id;
    }
}
```

**解决**:
```csharp
// 方案 1：使用 [Transactional]
[Transactional]
public class CreateOrderHandler
{
    public async Task<Guid> Handle(CreateOrder cmd, IDocumentSession session)
    {
        var order = new Order();
        session.Store(order);
        // 自动保存
        return order.Id;
    }
}

// 方案 2：手动 SaveChangesAsync
public class CreateOrderHandler
{
    public async Task<Guid> Handle(CreateOrder cmd, IDocumentSession session)
    {
        var order = new Order();
        session.Store(order);
        await session.SaveChangesAsync();
        return order.Id;
    }
}
```

### 7.3 循环依赖

**问题**:
```
OrderModule → BillingModule → OrderModule  // 循环依赖
```

**解决**:
- 使用事件解耦
- 引入中间模块
- 重新设计模块边界

---

## 八、性能监控

### 8.1 日志结构化

```csharp
public class CreateOrderHandler
{
    public async Task Handle(
        CreateOrder cmd,
        ILogger<CreateOrderHandler> logger)
    {
        logger.LogInformation(
            "处理订单创建 {OrderId} {MemberId} {Amount:F2}",
            cmd.OrderId,
            cmd.MemberId,
            cmd.Amount
        );
    }
}
```

### 8.2 OpenTelemetry

```csharp
// Program.cs
builder.Services.AddOpenTelemetry()
    .WithTracing(tracing =>
    {
        tracing.AddAspNetCoreInstrumentation();
        tracing.AddWolverineInstrumentation();
        tracing.AddMartenInstrumentation();
    });
```

---

## 九、参考资源

### 相关文档
- [核心架构原则](./01_核心架构原则.md) - 架构的核心原则
- [Wolverine快速上手指南](../Wolverine快速上手指南.md) - 快速上手
- [06_开发规范/代码风格.md](../../06_开发规范/代码风格.md) - 代码规范

### 外部资源
- [Wolverine Documentation](https://wolverine.netlify.app/)
- [Refactoring Guru - Code Smells](https://refactoring.guru/refactoring/smells)

---

## 版本历史

| 版本 | 日期 | 变更说明 |
|------|------|----------|
| 1.0.0 | 2024-01-15 | 从 Wolverine模块化架构蓝图 拆分 |

---

**最后更新**: 2024-01-15  
**负责人**: 架构团队  
**审核状态**: ✅ 已审核
