# 垂直切片架构说明

## 1. 概述

垂直切片架构（Vertical Slice Architecture）是一种以功能特性为中心的软件架构模式，每个功能切片包含从 UI 到数据库的完整实现路径。与传统的水平分层架构（如 ABP 的 Domain/Application/HttpApi/Infrastructure）不同，垂直切片架构强调按业务功能组织代码。

## 2. 核心理念

### 2.1 高内聚、低耦合

- **每个切片独立**: 一个业务功能的所有代码（处理器、验证、数据访问）都在同一个切片中
- **最小化跨切片依赖**: 不同切片之间通过消息、事件或领域服务通信
- **独立演化**: 每个切片可以独立修改、测试和部署

### 2.2 以业务为中心

```
传统分层架构：              垂直切片架构：
Controller/                Features/
  UserController             Users/
  TableController              CreateUser/
Application/                     CreateUserCommand.cs
  UserService                    CreateUserHandler.cs
  TableService                   CreateUserValidator.cs
Domain/                        GetUser/
  User                           GetUserQuery.cs
  Table                          GetUserHandler.cs
Infrastructure/                UpdateUser/
  UserRepository                 UpdateUserCommand.cs
  TableRepository                UpdateUserHandler.cs
                               Tables/
                                 ReserveTable/
                                   ReserveTableCommand.cs
                                   ReserveTableHandler.cs
                                 ReleaseTable/
                                   ReleaseTableCommand.cs
                                   ReleaseTableHandler.cs
```

## 3. 在本项目中的应用

### 3.1 切片示例：开台功能

```
Features/
  TableSessions/
    StartSession/
      StartSessionCommand.cs          # 命令定义
      StartSessionHandler.cs          # 业务处理器
      StartSessionValidator.cs        # 输入验证
      StartSessionEndpoint.cs         # HTTP 端点（可选）
```

**StartSessionCommand.cs**:
```csharp
public record StartSessionCommand(
    Guid TableId,
    Guid? MemberId,
    SessionType Type
);
```

**StartSessionHandler.cs**:
```csharp
public class StartSessionHandler
{
    private readonly IDocumentSession _session;
    private readonly ILogger<StartSessionHandler> _logger;

    public async Task<Result<SessionStarted>> Handle(
        StartSessionCommand command,
        CancellationToken ct)
    {
        // 1. 加载台球桌
        var table = await _session.LoadAsync<Table>(command.TableId, ct);
        if (table == null)
            return Result.Fail<SessionStarted>("台球桌不存在");

        // 2. 检查台球桌状态
        if (table.Status != TableStatus.Available)
            return Result.Fail<SessionStarted>("台球桌不可用");

        // 3. 创建会话
        var session = TableSession.Create(
            command.TableId,
            command.MemberId,
            command.Type
        );

        // 4. 更新台球桌状态
        table.MarkAsOccupied(session.Id);

        // 5. 持久化
        _session.Store(session);
        await _session.SaveChangesAsync(ct);

        // 6. 发布领域事件
        await _bus.PublishAsync(new SessionStarted(session.Id), ct);

        return Result.Ok(new SessionStarted(session.Id));
    }
}
```

### 3.2 跨切片通信

当一个切片需要与另一个切片交互时，使用以下方式：

#### 方式 1：命令/查询
```csharp
// 在 EndSessionHandler 中触发计费
public class EndSessionHandler
{
    private readonly IMessageBus _bus;

    public async Task Handle(EndSessionCommand command)
    {
        // ... 结束会话逻辑

        // 触发计费命令
        await _bus.InvokeAsync(new CalculateBillingCommand(
            sessionId,
            startTime,
            endTime
        ));
    }
}
```

#### 方式 2：领域事件
```csharp
// 会话结束后发布事件
await _bus.PublishAsync(new SessionEndedEvent(sessionId));

// 计费切片监听事件
public class SessionEndedEventHandler
{
    public async Task Handle(SessionEndedEvent evt)
    {
        // 执行计费逻辑
    }
}
```

#### 方式 3：共享领域服务
```csharp
// 对于真正的核心领域逻辑，可以创建共享服务
public interface IPricingService
{
    decimal CalculatePrice(TimeSpan duration, TableType type);
}

// 在多个切片中注入使用
```

## 4. 与传统分层架构的对比

| 维度 | 传统分层架构 | 垂直切片架构 |
|------|-------------|-------------|
| 代码组织 | 按技术层次（Controller/Service/Repository） | 按业务功能（Features/Users/Tables） |
| 依赖方向 | 单向向下（UI → Application → Domain → Infrastructure） | 每个切片独立，通过消息通信 |
| 变更影响 | 一个功能改动可能涉及多层 | 功能改动集中在单个切片内 |
| 测试策略 | 需要 Mock 多层依赖 | 切片可独立集成测试 |
| 新人理解 | 需要理解完整分层结构 | 只需理解单个切片即可开始 |
| 代码复用 | 通过共享服务层实现 | 接受适度重复，共享真正通用的 |

## 5. 最佳实践

### 5.1 切片大小

- **单一职责**: 一个切片只做一件事
- **完整性**: 包含该功能的所有必要代码
- **示例**: `CreateUser`、`UpdateUserProfile`、`DeactivateUser` 是三个独立切片，而不是一个 `UserManagement` 切片

### 5.2 共享代码原则

**何时共享**:
- 真正的领域逻辑（如价格计算算法）
- 技术基础设施（如日志、认证）
- 跨切片的数据模型（实体、值对象）

**何时不共享**:
- DTO / 命令 / 查询对象（每个切片自己定义）
- 特定于切片的验证逻辑
- 业务流程编排（由切片内部处理）

### 5.3 文件夹结构建议

```
src/
  Zss.BilliardHall/
    Features/                       # 所有功能切片
      TableSessions/                # 台球桌会话领域
        StartSession/               # 开台切片
          StartSessionCommand.cs
          StartSessionHandler.cs
          StartSessionValidator.cs
        EndSession/                 # 关台切片
        PauseSession/              # 暂停切片
        ResumeSession/             # 恢复切片
      Members/                      # 会员领域
        RegisterMember/
        TopUpBalance/
        GetMemberProfile/
      Payments/                     # 支付领域
        ProcessPayment/
        RefundPayment/
        ReconcilePayments/
    Domain/                         # 共享领域模型
      Entities/
        Table.cs
        TableSession.cs
        Member.cs
      ValueObjects/
        Money.cs
        SessionDuration.cs
      Services/
        IPricingService.cs
    Infrastructure/                 # 技术基础设施
      Persistence/
        MartenRegistry.cs
      Messaging/
        WolverineSetup.cs
```

## 6. 迁移指南

### 6.1 从 ABP 分层架构迁移

**步骤**:

1. **识别现有功能**: 列出所有用例（如 CreateUser、StartSession）
2. **创建切片目录**: 为每个用例创建独立目录
3. **迁移代码**: 将 Controller → Service → Repository 的代码合并到 Handler
4. **提取共享逻辑**: 识别真正需要共享的领域服务
5. **重构通信**: 将直接调用改为消息传递

**示例对比**:

**迁移前（ABP）**:
```csharp
// Controller
public class TableController : AbpController
{
    private readonly ITableAppService _tableService;
    
    [HttpPost]
    public async Task<TableSessionDto> StartSession(StartSessionDto dto)
    {
        return await _tableService.StartSessionAsync(dto);
    }
}

// Application Service
public class TableAppService : ApplicationService, ITableAppService
{
    private readonly ITableSessionRepository _repository;
    private readonly ITableRepository _tableRepository;
    
    public async Task<TableSessionDto> StartSessionAsync(StartSessionDto dto)
    {
        var table = await _tableRepository.GetAsync(dto.TableId);
        var session = new TableSession(/* ... */);
        await _repository.InsertAsync(session);
        return ObjectMapper.Map<TableSession, TableSessionDto>(session);
    }
}
```

**迁移后（Wolverine + Vertical Slice）**:
```csharp
// Features/TableSessions/StartSession/StartSessionEndpoint.cs
public class StartSessionEndpoint : Endpoint<StartSessionCommand, Result<Guid>>
{
    [HttpPost("/api/table-sessions")]
    public async Task<Result<Guid>> HandleAsync(
        [FromBody] StartSessionCommand command,
        [FromServices] IMessageBus bus)
    {
        return await bus.InvokeAsync<Result<Guid>>(command);
    }
}

// Features/TableSessions/StartSession/StartSessionHandler.cs
public class StartSessionHandler
{
    public async Task<Result<Guid>> Handle(
        StartSessionCommand command,
        IDocumentSession session)
    {
        var table = await session.LoadAsync<Table>(command.TableId);
        if (table?.Status != TableStatus.Available)
            return Result.Fail<Guid>("台球桌不可用");

        var tableSession = TableSession.Start(command.TableId, command.MemberId);
        
        session.Store(tableSession);
        await session.SaveChangesAsync();

        return Result.Ok(tableSession.Id);
    }
}
```

## 7. 优势与权衡

### 7.1 优势

- ✅ **更快的开发速度**: 无需在多层之间跳转
- ✅ **更好的可维护性**: 功能变更限制在单个切片内
- ✅ **更简单的测试**: 减少 Mock 和测试设置
- ✅ **更清晰的代码**: 业务逻辑集中，易于理解
- ✅ **更好的团队协作**: 不同开发者可以并行开发不同切片

### 7.2 权衡

- ⚠️ **代码重复**: 可能有适度的代码重复（这是可接受的）
- ⚠️ **学习曲线**: 团队需要适应新的思维方式
- ⚠️ **工具支持**: IDE 的"按层查看"功能不再适用

### 7.3 何时使用垂直切片架构

**适合**:
- 快速变化的业务需求
- 团队规模中等（3-20人）
- 强调交付速度和灵活性

**不太适合**:
- 需要严格的分层和边界控制的企业应用
- 极其复杂的领域逻辑（DDD 战术模式更合适）

## 8. 参考资源

- [Vertical Slice Architecture - Jimmy Bogard](https://www.jimmybogard.com/vertical-slice-architecture/)
- [Wolverine Documentation](https://wolverine.netlify.app/)
- [Marten Documentation](https://martendb.io/)
- [Feature Folders vs. Technical Folders](https://www.youtube.com/watch?v=yF6VL35l914)

---

**最后更新**: 2024-01-15  
**负责人**: 架构团队  
**审核状态**: 待审核
